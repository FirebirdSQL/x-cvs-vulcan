/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version SO-V2.0.0.4027 Vulcan 1.0 Development **********************/
#line 1 "restore.epp"
/*
 *	PROGRAM:	JRD Backup and Restore Program
 *	MODULE:		restore.epp
 *	DESCRIPTION:	Restore routine
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Toni Martir: Verbose records restored as RESTORE_VERBOSE_INTERVAL,
 * also verbose restoring indexes as DEFERRED when verbose
 * 2003.08.17 Claudio Valderrama: Fix SF Bug #750659.
 */
/*
$Id$
*/

#include "firebird.h"
#include "../jrd/ib_stdio.h"
#include <string.h>
#include <errno.h>
#include "../burp/burp.h"
#include "../jrd/align.h"
#include "../jrd/common.h"
#include "../jrd/flags.h"
#include "../jrd/license.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../jrd/thd_proto.h"
#include "../burp/burp_proto.h"
#include "../burp/canon_proto.h"
#include "../burp/misc_proto.h"
#include "../burp/mvol_proto.h"
#include "../burp/resto_proto.h"
#include "../jrd/gdsassert.h"
#include "../remote/protocol.h"
#ifdef DEBUG
#include "../gpre/prett_proto.h"
#endif

//  For service APIs the follow DB handle is a value stored
//  in thread data.  This is also done for other statics generated by
//  GPRE.  This is to avoid multiple threading problems with module
//  level statics.

/*DATABASE DB = STATIC FILENAME "yachts.lnk";*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static const ISC_QUAD
   isc_blob_null = {0,0};	/* initializer for blobs */
static isc_db_handle
   DB = 0;		/* database handle */

static isc_tr_handle
   gds_trans = 0;		/* default transaction handle */
static ISC_STATUS
   isc_status [20],	/* status vector */
   isc_status2 [20];	/* status vector */
static SLONG
   isc_array_length, 	/* array return size */
   SQLCODE;		/* SQL status code */
static const char
   isc_tpb_26 [4] = {1,9,2,6};

static const char
   isc_tpb_25 [5] = {1,9,2,6,20};

static const char
   isc_tpb_24 [4] = {1,9,2,6};

static const char
   isc_tpb_23 [5] = {1,9,2,6,20};

static const char
   isc_tpb_22 [5] = {1,9,15,6,18};

static const char
   isc_tpb_21 [4] = {1,9,2,6};

static const char
   isc_tpb_20 [5] = {1,9,2,6,20};

static const char
   isc_tpb_19 [4] = {1,9,2,6};

static const char
   isc_tpb_18 [5] = {1,9,2,6,20};

static const char
   isc_tpb_17 [4] = {1,9,2,6};

static const char
   isc_tpb_16 [5] = {1,9,2,6,20};

static const char
   isc_tpb_15 [4] = {1,9,2,6};

static const char
   isc_tpb_14 [5] = {1,9,2,6,20};

static const char
   isc_tpb_13 [4] = {1,9,2,6};

static const char
   isc_tpb_12 [5] = {1,9,2,6,20};

static const char
   isc_tpb_11 [4] = {1,9,2,6};

static const char
   isc_tpb_10 [5] = {1,9,2,6,20};

static const char
   isc_tpb_9 [4] = {1,9,2,6};

static const char
   isc_tpb_8 [5] = {1,9,2,6,20};

static const char
   isc_tpb_7 [4] = {1,9,2,6};

static const char
   isc_tpb_6 [5] = {1,9,2,6,20};

static const char
   isc_tpb_5 [4] = {1,9,2,6};

static const char
   isc_tpb_4 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_3 [4] = {1,9,2,6};

static const char
   isc_tpb_2 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_1 [4] = {1,9,2,6};

static const char
   isc_tpb_0 [6] = {1,9,15,6,18,20};

static const short
   isc_27l = 254;
static const char
   isc_27 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 4,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 1, 5,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
			      blr_parameter2, 1, 0,0, 3,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
			      blr_parameter2, 1, 1,0, 4,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter2, 2, 1,0, 3,0, 
					     blr_field, 1, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
					  blr_assignment, 
					     blr_parameter2, 2, 0,0, 2,0, 
					     blr_field, 1, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_27 */

static const short
   isc_43l = 59;
static const char
   isc_43 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','G','E','N','E','R','A','T','O','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 18, 'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_43 */

static const short
   isc_46l = 168;
static const char
   isc_46 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_quad, 0, 
	 blr_message, 1, 2,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 20, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 7, 'R','D','B','$','A','C','L', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 1,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 7, 'R','D','B','$','A','C','L', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_46 */

static const short
   isc_56l = 138;
static const char
   isc_56 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 9, 'R','D','B','$','F','I','L','E','S', 0, 
		  blr_boolean, 
		     blr_and, 
			blr_not, 
			   blr_missing, 
			      blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
			blr_neq, 
			   blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
			   blr_literal, blr_long, 0, 0,0,0,0,
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 0,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_erase, 0, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 0,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_56 */

static const short
   isc_63l = 156;
static const char
   isc_63 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_cstring, 32,0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_63 */

static const short
   isc_71l = 140;
static const char
   isc_71 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_quad, 0, 
	 blr_message, 0, 2,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_71 */

static const short
   isc_79l = 139;
static const char
   isc_79 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','N','T','E','X','T','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 13, 'R','D','B','$','V','I','E','W','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_79 */

static const short
   isc_85l = 243;
static const char
   isc_85 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 7,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','U','S','E','R','_','P','R','I','V','I','L','E','G','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 4,0, 
		     blr_field, 0, 13, 'R','D','B','$','U','S','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 16, 'R','D','B','$','G','R','A','N','T','_','O','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 11,0, 
		     blr_field, 0, 13, 'R','D','B','$','P','R','I','V','I','L','E','G','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 11, 'R','D','B','$','G','R','A','N','T','O','R', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 8, 'R','D','B','$','U','S','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 15, 'R','D','B','$','O','B','J','E','C','T','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_85 */

static const short
   isc_99l = 150;
static const char
   isc_99 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','T','Y','P','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 8, 'R','D','B','$','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 13, 'R','D','B','$','T','Y','P','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 4,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_99 */

static const short
   isc_108l = 113;
static const char
   isc_108 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_cstring, 79,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','M','E','S','S','A','G','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 11, 'R','D','B','$','M','E','S','S','A','G','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','M','E','S','S','A','G','E','_','N','U','M','B','E','R', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_108 */

static const short
   isc_113l = 130;
static const char
   isc_113 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
		     blr_first, 
			blr_literal, blr_long, 0, 1,0,0,0,
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			      blr_literal, blr_long, 0, 1,0,0,0,
			   blr_eql, 
			      blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_113 */

static const short
   isc_118l = 311;
static const char
   isc_118 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 15,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','I','N','A','C','T','I','V','E', 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 7,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 12,0, 
		     blr_field, 0, 18, 'R','D','B','$','T','R','I','G','G','E','R','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','T','R','I','G','G','E','R','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 14,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_118 */

static const short
   isc_135l = 254;
static const char
   isc_135 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 11,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 7,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 8,0, 
		     blr_field, 0, 18, 'R','D','B','$','T','R','I','G','G','E','R','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','T','R','I','G','G','E','R','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_135 */

static const short
   isc_148l = 111;
static const char
   isc_148 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 20, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 7, 'R','D','B','$','A','C','L', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 3,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_148 */

static const short
   isc_154l = 82;
static const char
   isc_154 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','R','O','L','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 2,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 3,0, 
		     blr_field, 0, 13, 'R','D','B','$','R','O','L','E','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_154 */

static const short
   isc_160l = 235;
static const char
   isc_160 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 4,0, 
	    blr_cstring, 4,0, 
	    blr_cstring, 12,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 24, 'R','D','B','$','R','E','L','A','T','I','O','N','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 6,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 7,0, 
		     blr_field, 0, 22, 'R','D','B','$','I','N','I','T','I','A','L','L','Y','_','D','E','F','E','R','R','E','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 8,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','E','F','E','R','R','A','B','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 9,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 10,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 11,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_160 */

static const short
   isc_174l = 321;
static const char
   isc_174 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 19,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','F','I','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 9,0, 
		     blr_field, 0, 24, 'R','D','B','$','E','X','T','E','R','N','A','L','_','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 10,0, 
		     blr_field, 0, 11, 'R','D','B','$','R','U','N','T','I','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 11,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 12,0, 
		     blr_field, 0, 15, 'R','D','B','$','V','I','E','W','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 13,0, 
		     blr_field, 0, 12, 'R','D','B','$','V','I','E','W','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 14,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 16,0, 15,0, 
		     blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 18,0, 17,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_174 */

static const short
   isc_195l = 192;
static const char
   isc_195 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring, 8,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 12,0, 
	    blr_cstring, 12,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','R','E','F','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 5,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','L','E','T','E','_','R','U','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','R','U','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 7,0, 
		     blr_field, 0, 16, 'R','D','B','$','M','A','T','C','H','_','O','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 8,0, 
		     blr_field, 0, 17, 'R','D','B','$','C','O','N','S','T','_','N','A','M','E','_','U','Q', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_195 */

static const short
   isc_207l = 212;
static const char
   isc_207 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 24, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','P','A','R','A','M','E','T','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','U','M','B','E','R', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_207 */

static const short
   isc_216l = 276;
static const char
   isc_216 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 13,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 21, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','O','U','T','P','U','T','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','I','N','P','U','T','S', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 11,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 12,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','S','O','U','R','C','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_216 */

static const short
   isc_231l = 127;
static const char
   isc_231 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 0,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_erase, 0, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_231 */

static const short
   isc_240l = 186;
static const char
   isc_240 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_and, 
			      blr_eql, 
				 blr_field, 1, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
				 blr_parameter, 0, 1,0, 
			      blr_eql, 
				 blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
				 blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_240 */

static const short
   isc_246l = 112;
static const char
   isc_246 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_246 */

static const short
   isc_251l = 314;
static const char
   isc_251 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 15,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 17, 'R','D','B','$','S','E','G','M','E','N','T','_','C','O','U','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 7,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 8,0, 
		     blr_field, 0, 21, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','O','R','E','I','G','N','_','K','E','Y', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 11,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 13,0, 
		     blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
		  blr_assignment, 
		     blr_parameter, 0, 14,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','N','I','Q','U','E','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_251 */

static const short
   isc_268l = 846;
static const char
   isc_268 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 51,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 126,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 13,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 14,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 18,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 19,0, 
		     blr_field, 0, 18, 'R','D','B','$','M','I','S','S','I','N','G','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 21,0, 20,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 24,0, 23,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','T','E','R','N','A','L','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 26,0, 25,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 28,0, 27,0, 
		     blr_field, 0, 19, 'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 30,0, 29,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 31,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 33,0, 32,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 35,0, 34,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 36,0, 
		     blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 37,0, 
		     blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 38,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 39,0, 
		     blr_field, 0, 17, 'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 40,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 42,0, 41,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 43,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 44,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 45,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 46,0, 17,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 47,0, 15,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 48,0, 16,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 49,0, 22,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 50,0, 12,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_268 */

static const short
   isc_321l = 879;
static const char
   isc_321 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 53,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 126,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 13,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 14,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 16,0, 15,0, 
		     blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 20,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 21,0, 
		     blr_field, 0, 18, 'R','D','B','$','M','I','S','S','I','N','G','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 23,0, 22,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 26,0, 25,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','T','E','R','N','A','L','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 28,0, 27,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 30,0, 29,0, 
		     blr_field, 0, 19, 'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 32,0, 31,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 33,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 35,0, 34,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 37,0, 36,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 38,0, 
		     blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 39,0, 
		     blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 40,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 41,0, 
		     blr_field, 0, 17, 'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 42,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 44,0, 43,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 45,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 46,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 47,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 48,0, 19,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 49,0, 17,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 50,0, 18,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 51,0, 24,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 52,0, 12,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_321 */

static const short
   isc_376l = 261;
static const char
   isc_376 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 13, 'R','D','B','$','M','E','C','H','A','N','I','S','M', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_376 */

static const short
   isc_388l = 294;
static const char
   isc_388 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 13, 'R','D','B','$','M','E','C','H','A','N','I','S','M', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 10,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_388 */

static const short
   isc_402l = 214;
static const char
   isc_402 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 13, 'R','D','B','$','F','U','N','C','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 19, 'R','D','B','$','R','E','T','U','R','N','_','A','R','G','U','M','E','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','M','O','D','U','L','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_402 */

static const short
   isc_411l = 192;
static const char
   isc_411 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 11, 'R','D','B','$','F','I','L','T','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 19, 'R','D','B','$','O','U','T','P','U','T','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 18, 'R','D','B','$','I','N','P','U','T','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 15, 'R','D','B','$','M','O','D','U','L','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_411 */

static const short
   isc_420l = 176;
static const char
   isc_420 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 6,0, 
	    blr_long, 0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','F','I','L','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','L','E','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','S','T','A','R','T', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','I','L','E','_','S','E','Q','U','E','N','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 13, 'R','D','B','$','F','I','L','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','F','L','A','G','S', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_420 */

static const short
   isc_428l = 134;
static const char
   isc_428 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring, 32,0, 
	    blr_long, 0, 
	    blr_long, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 20, 'R','D','B','$','F','I','E','L','D','_','D','I','M','E','N','S','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','P','P','E','R','_','B','O','U','N','D', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','L','O','W','E','R','_','B','O','U','N','D', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 13, 'R','D','B','$','D','I','M','E','N','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_428 */

static const short
   isc_434l = 566;
static const char
   isc_434 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 33,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 126,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 11,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 15,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 16,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 18,0, 17,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 19,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','L','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 21,0, 20,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 23,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 25,0, 24,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 26,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 28,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 29,0, 
		     blr_field, 0, 14, 'R','D','B','$','B','A','S','E','_','F','I','E','L','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 31,0, 30,0, 
		     blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 27,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 32,0, 22,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 10,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_434 */

static const short
   isc_469l = 114;
static const char
   isc_469 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 5,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 79,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','E','X','C','E','P','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','C','E','P','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 2,0, 
		     blr_field, 0, 11, 'R','D','B','$','M','E','S','S','A','G','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 3,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_469 */

static const short
   isc_476l = 176;
static const char
   isc_476 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 1,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 2, 0,0, 
					  blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
				       blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_476 */

static const short
   isc_486l = 255;
static const char
   isc_486 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 14,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','C','O','L','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 3,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 4,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 5,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 24, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','A','T','T','R','I','B','U','T','E','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 9,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 11,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 13,0, 
		     blr_field, 0, 18, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_486 */

static const short
   isc_502l = 102;
static const char
   isc_502 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 21, 'R','D','B','$','C','H','E','C','K','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 2,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 3,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_502 */

static const short
   isc_508l = 339;
static const char
   isc_508 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 18,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 23, 'R','D','B','$','B','Y','T','E','S','_','P','E','R','_','C','H','A','R','A','C','T','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 8,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 13,0, 12,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 14,0, 
		     blr_field, 0, 24, 'R','D','B','$','D','E','F','A','U','L','T','_','C','O','L','L','A','T','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 15,0, 
		     blr_field, 0, 24, 'R','D','B','$','N','U','M','B','E','R','_','O','F','_','C','H','A','R','A','C','T','E','R','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 16,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','O','R','M','_','O','F','_','U','S','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 17,0, 
		     blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_508 */

static const short
   isc_528l = 110;
static const char
   isc_528 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 1,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		  blr_first, 
		     blr_literal, blr_long, 0, 1,0,0,0,
		  blr_boolean, 
		     blr_eql, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_literal, blr_text, 14,0, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S',
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 0,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 0,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_528 */

static const short
   isc_531l = 108;
static const char
   isc_531 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 1,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		  blr_first, 
		     blr_literal, blr_long, 0, 1,0,0,0,
		  blr_boolean, 
		     blr_eql, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_literal, blr_text, 12,0, 'R','D','B','$','T','R','I','G','G','E','R','S',
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 0,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 0,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_531 */

static const short
   isc_534l = 73;
static const char
   isc_534 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 2,0, 
	    blr_long, 0, 
	    blr_cstring, 254,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','F','I','L','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','S','T','A','R','T', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 13, 'R','D','B','$','F','I','L','E','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_534 */

static const short
   isc_538l = 148;
static const char
   isc_538 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_cstring, 32,0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_538 */

static const short
   isc_546l = 233;
static const char
   isc_546 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_cstring, 32,0, 
	 blr_message, 1, 4,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','C','L','A','S','S', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			      blr_parameter, 1, 2,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 3,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 3,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_546 */

static const short
   isc_558l = 207;
static const char
   isc_558 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_cstring, 32,0, 
	 blr_message, 1, 3,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 14, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_558 */

static const short
   isc_569l = 339;
static const char
   isc_569 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 4, 1,0, 
	    blr_short, 0, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 3,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 12,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 24, 'R','D','B','$','R','E','L','A','T','I','O','N','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','T','Y','P','E', 
			      blr_parameter, 0, 0,0, 
			   blr_and, 
			      blr_eql, 
				 blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
				 blr_field, 1, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			      blr_eql, 
				 blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
				 blr_parameter, 0, 1,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 1, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 1, 3, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 3, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
					  blr_end, 
			      blr_receive, 4, 
				 blr_handler, 
				    blr_modify, 1, 2, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 4, 0,0, 
					     blr_field, 2, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_569 */

static const short
   isc_583l = 265;
static const char
   isc_583 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 4, 1,0, 
	    blr_short, 0, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 3,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 0, 0,0, 
			   blr_missing, 
			      blr_field, 0, 15, 'R','D','B','$','F','O','R','E','I','G','N','_','K','E','Y', 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 2, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 2, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
					  blr_end, 
			      blr_receive, 4, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 4, 0,0, 
					     blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_583 */

static const short
   isc_596l = 176;
static const char
   isc_596 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 1,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 2, 0,0, 
					  blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
				       blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_596 */


#define gds_blob_null	isc_blob_null	/* compatibility symbols */
#define gds_status	isc_status
#define gds_status2	isc_status2
#define gds_array_length	isc_array_length
#define gds_count	isc_count
#define gds_slack	isc_slack
#define gds_utility	isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
    Generate a compile-time error.
    Picking up a V3 include file after preprocessing with V4 GPRE.
#endif

/**** end of GPRE definitions ****/

#line 59 "restore.epp"

#define DB			tdgbl->db_handle
#define gds_trans	tdgbl->tr_handle
#define isc_status	tdgbl->status


namespace // unnamed, private
{


const int DB_VERSION_DDL4		= 4;  // ods4 db 
const int DB_VERSION_DDL5		= 5;  // ods5 db 
const int DB_VERSION_DDL8		= 8;  // ods8 db 
const int DB_VERSION_CURRENT	= DB_VERSION_DDL8;  // v4.0 is ods8 
const char* FOREIGN_KEY			= "FOREIGN KEY";

const int DEFERRED_ACTIVE		= 3;	/* RDB$INDEX_INACTIVE setting for Foreign Keys
										* This setting is used temporarily while
										* restoring a database. This was required
										* in order to differentiate a partial
										* "inactive" state of SOME indices from
										* "inactive" state of ALL indices (gbak -i)
										* -bsriram, 11-May-1999      BUG: 10016
										*/

const int RESTORE_VERBOSE_INTERVAL	= 10000;
const int cvtbl_len		= 28;

enum scan_attr_t {
	NO_SKIP		= 0,	// Not in skipping and scanning mode 
	BEFORE_SKIP	= 1,	// After skipping, before scanning next byte for valid attribute 
	AFTER_SKIP	= 2	// After skipping and after scanning next byte for valid attribute 
};

void	add_files(const UCHAR*);
void	bad_attribute(scan_attr_t, ATT_TYPE, USHORT);
USHORT	check_db_version();
void	create_database (const TEXT*);
void	decompress(UCHAR*, USHORT);
void	eat_blob();
BURP_REL	find_relation (const TEXT *);
// CVC: when do these functions return false indeed???
// get_acl and get_index are the only exceptions but ironically their
// returned value is not checked by the caller!
bool	get_acl (const TEXT*, ISC_QUAD*, ISC_QUAD*);
void	get_array (BURP_REL, UCHAR*);
void	get_blob (const burp_fld*, UCHAR*);
void	get_blr_blob (ISC_QUAD*, bool);
bool	get_character_set();
bool	get_chk_constraint();
bool	get_collation();
rec_type	get_data (BURP_REL);
bool	get_exception();
BURP_FLD	get_field (BURP_REL);
bool	get_field_dimensions();
bool	get_files();
bool	get_filter();
bool	get_function();
void	get_function_arg ();
bool get_generator();
bool get_global_field();
bool get_index (const burp_rel*);
void	get_misc_blob (ISC_QUAD*, USHORT, bool);
SLONG	get_numeric();
SINT64   get_int64();
bool	get_procedure();
bool	get_procedure_prm (GDS_NAME );
bool	get_ref_constraint();
bool	get_rel_constraint();
bool	get_relation();
bool	get_relation_data();
bool	get_sql_roles();
bool	get_security_class();
void	get_source_blob (ISC_QUAD*, bool);
USHORT	get_text (TEXT*, ULONG);
bool	get_trigger();
bool	get_trigger_message();
bool	get_trigger_old (BURP_REL);
bool	get_type();
bool	get_user_privilege();
bool	get_view (BURP_REL);
void	ignore_array (BURP_REL);
void	ignore_blob();
rec_type	ignore_data (BURP_REL);
void	realign(UCHAR*, const burp_rel*);
USHORT	recompute_length (BURP_REL);
bool	restore (const TEXT*, const TEXT*);
void	restore_security_class (const TEXT*, const TEXT*);
void	store_blr_gen_id (const TEXT*, SINT64);
void	stuff_string(UCHAR**, const TEXT*);
void	update_global_field();
void	general_on_error();
#ifdef DEBUG
UCHAR	debug_on = 0;   // able to turn this on in the debugger 
#endif

bool	flag_on_line = true;	/* indicates whether we will bring
					   the database on-line :
                                           true - we will
                                           false - we will not */
#ifdef sparc
const SSHORT old_sparcs[] =
    {0, 0, 0, 2, 0, 0, 0, 0, 2, 4, 4, 4, 8, 8, 0, 0, 8, 8, 8};
#endif

//MVOL_read returns int
static inline int get(tgbl* tdgbl)
{
	if (--(tdgbl->io_cnt) >= 0)
		return *(tdgbl->io_ptr)++;
	else // => superfluous here
		return MVOL_read(&tdgbl->io_cnt, &tdgbl->io_ptr);
}

static inline ATT_TYPE get_attribute(ATT_TYPE *att, TGBL tdgbl)
{
	*att = (ATT_TYPE) get(tdgbl);
	return *att;
}

static inline rec_type get_record(rec_type *rec, TGBL tdgbl)
{
	*rec = (rec_type) get(tdgbl);
	return *rec;
}

#define GET_TEXT(text)	get_text((text), sizeof(text))

static inline void get_skip(tgbl* tdgbl, ULONG n)
{
	MVOL_skip_block(tdgbl, n);
}

static inline UCHAR* get_block(tgbl* tdgbl, UCHAR* p, ULONG n)
{
	return MVOL_read_block(tdgbl, p, n);
}

// When skipping started, scan_next_attr will be changed from NO_SKIP
// to BEFORE_SKIP. When scanning for next valid attribute after skipping,
// it will flip-flop between BEFORE_SKIP and AFTER_SKIP. When next valid
// attribute is found, it will be changed back to NO_SKIP by 'skip_scan'

static inline void skip_init(scan_attr_t* scan_next_attr)
{
	*scan_next_attr = NO_SKIP;
}

static inline void skip_scan(scan_attr_t* scan_next_attr)
{
	if (*scan_next_attr == AFTER_SKIP)
		*scan_next_attr = BEFORE_SKIP;
	else if (*scan_next_attr == BEFORE_SKIP)
		*scan_next_attr = NO_SKIP;
	//else 0; => nothing, no change in the original macro
}

// User Privilege Flags

const int USER_PRIV_USER			= 1;
const int USER_PRIV_GRANTOR			= 2;
const int USER_PRIV_PRIVILEGE		= 4;
const int USER_PRIV_GRANT_OPTION	= 8;
const int USER_PRIV_OBJECT_NAME		= 16;
const int USER_PRIV_FIELD_NAME		= 32;
const int USER_PRIV_USER_TYPE		= 64;
const int USER_PRIV_OBJECT_TYPE		= 128;

} // namespace


int RESTORE_restore (const TEXT* file_name,
					 const TEXT* database_name)
{
   struct {
          short isc_545;	/* isc_utility */
   } isc_544;
   struct {
          char  isc_543 [32];	/* RDB$SECURITY_CLASS */
   } isc_542;
   struct {
          char  isc_540 [32];	/* RDB$SECURITY_CLASS */
          short isc_541;	/* isc_utility */
   } isc_539;
   struct {
          short isc_557;	/* isc_utility */
   } isc_556;
   struct {
          char  isc_555 [32];	/* RDB$OWNER_NAME */
   } isc_554;
   struct {
          char  isc_550 [32];	/* RDB$DEFAULT_CLASS */
          char  isc_551 [32];	/* RDB$SECURITY_CLASS */
          char  isc_552 [32];	/* RDB$OWNER_NAME */
          short isc_553;	/* isc_utility */
   } isc_549;
   struct {
          char  isc_548 [32];	/* RDB$RELATION_NAME */
   } isc_547;
   struct {
          short isc_568;	/* isc_utility */
   } isc_567;
   struct {
          char  isc_566 [32];	/* RDB$OWNER_NAME */
   } isc_565;
   struct {
          char  isc_562 [32];	/* RDB$SECURITY_CLASS */
          char  isc_563 [32];	/* RDB$OWNER_NAME */
          short isc_564;	/* isc_utility */
   } isc_561;
   struct {
          char  isc_560 [32];	/* RDB$PROCEDURE_NAME */
   } isc_559;
   struct {
          short isc_582;	/* RDB$INDEX_INACTIVE */
   } isc_581;
   struct {
          short isc_580;	/* isc_utility */
   } isc_579;
   struct {
          short isc_578;	/* RDB$INDEX_INACTIVE */
   } isc_577;
   struct {
          char  isc_574 [32];	/* RDB$INDEX_NAME */
          short isc_575;	/* isc_utility */
          short isc_576;	/* RDB$INDEX_INACTIVE */
   } isc_573;
   struct {
          char  isc_571 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_572;	/* RDB$INDEX_INACTIVE */
   } isc_570;
   struct {
          short isc_595;	/* RDB$INDEX_INACTIVE */
   } isc_594;
   struct {
          short isc_593;	/* isc_utility */
   } isc_592;
   struct {
          short isc_591;	/* RDB$INDEX_INACTIVE */
   } isc_590;
   struct {
          char  isc_587 [32];	/* RDB$INDEX_NAME */
          short isc_588;	/* isc_utility */
          short isc_589;	/* RDB$INDEX_INACTIVE */
   } isc_586;
   struct {
          short isc_585;	/* RDB$INDEX_INACTIVE */
   } isc_584;
   struct {
          short isc_605;	/* isc_utility */
   } isc_604;
   struct {
          short isc_603;	/* RDB$INDEX_INACTIVE */
   } isc_602;
   struct {
          short isc_600;	/* isc_utility */
          short isc_601;	/* RDB$INDEX_INACTIVE */
   } isc_599;
   struct {
          char  isc_598 [32];	/* RDB$INDEX_NAME */
   } isc_597;
#line 233 "restore.epp"
/**************************************
 *
 *	R E S T O R E _ r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Recreate a database from a backup.
 *
 **************************************/
	isc_req_handle  req_handle1 = NULL, req_handle2 = NULL, req_handle3 = NULL;
	isc_req_handle	req_handle4 = NULL;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];

#line 246 "restore.epp"

	TGBL tdgbl = GET_THREAD_DATA;

	tdgbl->io_ptr = NULL;
	tdgbl->io_cnt = 0;

	tdgbl->relations = NULL;
	tdgbl->procedures = NULL;
	tdgbl->RESTORE_format = 0;
	tdgbl->global_trans = 0;

	tdgbl->gbl_sw_transportable = tdgbl->gbl_sw_compress = FALSE;

	if (!restore (file_name, database_name))
		return FINI_ERROR;

	BURP_verbose (76, NULL, NULL, NULL, NULL, NULL);
	// msg 76 creating indexes 

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 266 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 267 "restore.epp"
		/* Fix for bug_no 8055:
		   don't throw away the database just because an index
		   could not be made */
		long error_code;
		while (error_code = tdgbl->status_vector[1])
		{
			switch (error_code)
			{
				case isc_sort_mem_err:
				case isc_no_dup:
					strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
					BURP_print_status(tdgbl->status_vector);
					/*FOR (REQUEST_HANDLE req_handle3)
					 IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
					{
                                        if (!req_handle3)
                                           isc_compile_request ( NULL, (isc_handle*) &DB, (isc_handle*) &req_handle3, (short) sizeof (isc_596), (char *) isc_596);
					isc_vtov ((char*)index_name, (char*)isc_597.isc_598, 32);
                                        isc_start_and_send ( NULL, (isc_handle*) &req_handle3, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_597, (short) 0);
					while (1)
					   {
                                           isc_receive ( NULL, (isc_handle*) &req_handle3, (short) 1, (short) 4, &isc_599, (short) 0);
					   if (!isc_599.isc_600) break;
#line 281 "restore.epp"
					 {
						BURP_verbose(243, index_name, NULL, NULL, NULL, NULL);
						/*MODIFY IDX USING*/
						{ /*IDX.RDB$INDEX_INACTIVE*/
 isc_599.isc_601 = TRUE;
#line 284 "restore.epp"
					 }
						BURP_print(240, index_name, NULL, NULL, NULL, NULL);
						/* msg 240 Index \"%s\" failed to activate because: */
						if ( error_code == isc_no_dup )
						{
							BURP_print(241, NULL, NULL, NULL, NULL, NULL);
							// msg 241 The unique index has duplicate values or NULLs 
							BURP_print(242, NULL, NULL, NULL, NULL, NULL);
							// msg 242 Delete or Update duplicate values or NULLs, and activate index with 
						}
						else
						{
							BURP_print(244, NULL, NULL, NULL, NULL, NULL);
							// msg 244 Not enough disk space to create the sort file for an index 
							BURP_print(245, NULL, NULL, NULL, NULL, NULL);
							// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with 
						}
						BURP_print(243, index_name, NULL, NULL, NULL, NULL);
						/* msg 243 ALTER INDEX \"%s\" ACTIVE; */
						/*END_MODIFY;*/
						isc_602.isc_603 = isc_599.isc_601;
                                                isc_send ( NULL, (isc_handle*) &req_handle3, (short) 2, (short) 2, &isc_602, (short) 0);
						}
#line 304 "restore.epp"
					/*END_FOR;*/
                                           isc_send ( NULL, (isc_handle*) &req_handle3, (short) 3, (short) 2, &isc_604, (short) 0);
					   }
					}
#line 305 "restore.epp"
					// don't bring the database on-line 
					flag_on_line = false;
					break;
				default:
					general_on_error ();
				break;
			}
			/*COMMIT*/
			{
			isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 313 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 314 "restore.epp"
				continue;
			/*END_ERROR*/
			   }
			}
#line 316 "restore.epp"
		}
	/*END_ERROR;*/
	   }
	}
#line 318 "restore.epp"
	// Activate the indices for foreign keys and do another commit  
	if (!(tdgbl->gbl_sw_deactivate_indexes))
	{

		// Block added to verbose index creation by Toni Martir 
		if (tdgbl->gbl_sw_verbose)
		{
			/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_0);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 326 "restore.epp"
			if (gds_status[1])
				/*EXEC SQL SET TRANSACTION;*/
				{
				isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_1);
				SQLCODE = isc_sqlcode (isc_status);
				}
#line 328 "restore.epp"

			// Activate first indexes that are not foreign keys 
			/*FOR (REQUEST_HANDLE req_handle1) IDS IN RDB$INDICES WITH
				IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE AND
				IDS.RDB$FOREIGN_KEY MISSING*/
			{
                        if (!req_handle1)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_583), (char *) isc_583);
			isc_584.isc_585 = DEFERRED_ACTIVE;
			if (req_handle1)
                           isc_start_and_send (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 2, &isc_584, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 1, (short) 36, &isc_586, (short) 0);
			   if (!isc_586.isc_588 || isc_status [1]) break;
#line 333 "restore.epp"
					/*MODIFY IDS USING*/
					{ /*IDS.RDB$INDEX_INACTIVE*/
 isc_586.isc_589 = FALSE;
#line 334 "restore.epp"
				/*END_MODIFY;*/
				isc_594.isc_595 = isc_586.isc_589;
                                isc_send (isc_status, (isc_handle*) &req_handle1, (short) 4, (short) 2, &isc_594, (short) 0);;
#line 335 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 336 "restore.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 338 "restore.epp"

				/*SAVE*/
				{
				isc_commit_retaining (isc_status, (isc_handle*) &gds_trans);;
#line 340 "restore.epp"
				// existing ON_ERROR continues past error, beck 
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 342 "restore.epp"
					BURP_print (173, /*IDS.RDB$INDEX_NAME*/
							 isc_586.isc_587, NULL, NULL, NULL, NULL);
#line 343 "restore.epp"
					BURP_print_status(isc_status);
					/*MODIFY IDS USING*/
					{
#line 345 "restore.epp"
						/*IDS.RDB$INDEX_INACTIVE*/
						isc_586.isc_589 = TRUE;
#line 346 "restore.epp"
					/*END_MODIFY;*/
					isc_590.isc_591 = isc_586.isc_589;
                                        isc_send (isc_status, (isc_handle*) &req_handle1, (short) 2, (short) 2, &isc_590, (short) 0);;
#line 347 "restore.epp"
					/*ON_ERROR*/
					if (isc_status [1])
					   {
#line 348 "restore.epp"
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
#line 350 "restore.epp"
				/*END_ERROR;*/
				   }
				}
#line 351 "restore.epp"
				BURP_verbose(122, /*IDS.RDB$INDEX_NAME*/
						  isc_586.isc_587, NULL, NULL, NULL, NULL);
#line 352 "restore.epp"
			/*END_FOR;*/
                           isc_send (isc_status, (isc_handle*) &req_handle1, (short) 3, (short) 2, &isc_592, (short) 0);
			   }
			   };
#line 353 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 354 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 356 "restore.epp"
			MISC_release_request_silent(req_handle1);
			/*COMMIT;*/
			{
			isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 358 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 359 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 361 "restore.epp"
		}


		/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_2);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 365 "restore.epp"
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_3);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 367 "restore.epp"

		/* Only activate Foreign keys that have been marked for deferred
		 * activation.
		 * -bsriram, 11-May-1999             BUG: 10016
		 */
		/*FOR (REQUEST_HANDLE req_handle1)
			CNST IN RDB$RELATION_CONSTRAINTS
			CROSS IDS IN RDB$INDICES WITH
			CNST.RDB$CONSTRAINT_TYPE EQ FOREIGN_KEY AND
			CNST.RDB$INDEX_NAME EQ IDS.RDB$INDEX_NAME AND
			IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_569), (char *) isc_569);
		isc_vtov ((char*)FOREIGN_KEY, (char*)isc_570.isc_571, 12);
		isc_570.isc_572 = DEFERRED_ACTIVE;
		if (req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 14, &isc_570, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 1, (short) 36, &isc_573, (short) 0);
		   if (!isc_573.isc_575 || isc_status [1]) break;
#line 378 "restore.epp"


			/*MODIFY IDS USING*/
			{
#line 381 "restore.epp"
					/*IDS.RDB$INDEX_INACTIVE*/
					isc_573.isc_576 = FALSE;
#line 382 "restore.epp"
			/*END_MODIFY;*/
			isc_581.isc_582 = isc_573.isc_576;
                        isc_send (isc_status, (isc_handle*) &req_handle1, (short) 4, (short) 2, &isc_581, (short) 0);;
#line 383 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 384 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 386 "restore.epp"

			/*SAVE*/
			{
			isc_commit_retaining (isc_status, (isc_handle*) &gds_trans);;
#line 388 "restore.epp"
			// existing ON_ERROR continues past error, beck 
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 390 "restore.epp"
				BURP_print (173, /*IDS.RDB$INDEX_NAME*/
						 isc_573.isc_574, NULL, NULL, NULL, NULL);
#line 391 "restore.epp"
				BURP_print_status(isc_status);
				/*MODIFY IDS USING*/
				{
#line 393 "restore.epp"
					/*IDS.RDB$INDEX_INACTIVE*/
					isc_573.isc_576 = TRUE;
#line 394 "restore.epp"
				/*END_MODIFY;*/
				isc_577.isc_578 = isc_573.isc_576;
                                isc_send (isc_status, (isc_handle*) &req_handle1, (short) 2, (short) 2, &isc_577, (short) 0);;
#line 395 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 396 "restore.epp"
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 398 "restore.epp"
			/*END_ERROR;*/
			   }
			}
#line 399 "restore.epp"
			BURP_verbose(122, /*IDS.RDB$INDEX_NAME*/
					  isc_573.isc_574, NULL, NULL, NULL, NULL);
#line 400 "restore.epp"
		/*END_FOR;*/
                   isc_send (isc_status, (isc_handle*) &req_handle1, (short) 3, (short) 2, &isc_579, (short) 0);
		   }
		   };
#line 401 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 402 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 404 "restore.epp"
		MISC_release_request_silent(req_handle1);
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 406 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 407 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 409 "restore.epp"
	}

	if (tdgbl->global_trans)
	{
		BURP_verbose (68, NULL, NULL, NULL, NULL, NULL);
		// msg 68 committing meta data 
		/*EXEC SQL COMMIT TRANSACTION tdgbl->global_trans;*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &tdgbl->global_trans);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 416 "restore.epp"
		if (gds_status[1])
			general_on_error ();
		// Check to see if there is a warning 
		if (gds_status[0] == isc_arg_gds && gds_status[1] == 0
			&& gds_status[2] != isc_arg_end)
		{
			BURP_print_warning(gds_status);
		}
	}

	/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_4);
	SQLCODE = isc_sqlcode (isc_status);
	}
#line 427 "restore.epp"
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_5);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 429 "restore.epp"
	/*
	** Change ownership of any procedures necessary
	*/

	for (BURP_PRC procedure = tdgbl->procedures; procedure;
						procedure = procedure->prc_next)
	{
		if (procedure->prc_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle4)
				X IN RDB$PROCEDURES WITH X.RDB$PROCEDURE_NAME EQ procedure->prc_name*/
			{
                        if (!req_handle4)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle4, (short) sizeof (isc_558), (char *) isc_558);
			isc_vtov ((char*)procedure->prc_name, (char*)isc_559.isc_560, 32);
			if (req_handle4)
                           isc_start_and_send (isc_status, (isc_handle*) &req_handle4, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_559, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle4, (short) 1, (short) 66, &isc_561, (short) 0);
			   if (!isc_561.isc_564 || isc_status [1]) break;
#line 440 "restore.epp"

				/*MODIFY X*/
				{
#line 442 "restore.epp"
				strcpy (/*X.RDB$OWNER_NAME*/
					isc_561.isc_563, procedure->prc_owner);
#line 443 "restore.epp"
				/*END_MODIFY;*/
				isc_ftof (isc_561.isc_563, 32, isc_565.isc_566, 32);
                                isc_send (isc_status, (isc_handle*) &req_handle4, (short) 2, (short) 32, &isc_565, (short) 0);;
#line 444 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 445 "restore.epp"
					MISC_release_request_silent(req_handle4);
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 448 "restore.epp"

			restore_security_class (procedure->prc_owner, /*X.RDB$SECURITY_CLASS*/
								      isc_561.isc_562);
#line 450 "restore.epp"

			/*END_FOR;*/
                           isc_send (isc_status, (isc_handle*) &req_handle4, (short) 3, (short) 2, &isc_567, (short) 0);
			   }
			   };
#line 452 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 453 "restore.epp"
				MISC_release_request_silent(req_handle4);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 456 "restore.epp"
		}
	}

	MISC_release_request_silent(req_handle4);

	// Change ownership of any relations necessary 

	for (BURP_REL relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		if (relation->rel_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$RELATIONS WITH X.RDB$RELATION_NAME EQ relation->rel_name*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_546), (char *) isc_546);
			isc_vtov ((char*)relation->rel_name, (char*)isc_547.isc_548, 32);
			if (req_handle2)
                           isc_start_and_send (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_547, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 1, (short) 98, &isc_549, (short) 0);
			   if (!isc_549.isc_553 || isc_status [1]) break;
#line 469 "restore.epp"
				/*MODIFY X*/
				{
#line 470 "restore.epp"
				strcpy (/*X.RDB$OWNER_NAME*/
					isc_549.isc_552, relation->rel_owner);
#line 471 "restore.epp"
				/*END_MODIFY;*/
				isc_ftof (isc_549.isc_552, 32, isc_554.isc_555, 32);
                                isc_send (isc_status, (isc_handle*) &req_handle2, (short) 2, (short) 32, &isc_554, (short) 0);;
#line 472 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 473 "restore.epp"
					MISC_release_request_silent(req_handle2);
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 476 "restore.epp"

			restore_security_class (relation->rel_owner, /*X.RDB$SECURITY_CLASS*/
								     isc_549.isc_551);
#line 478 "restore.epp"
			restore_security_class (relation->rel_owner, /*X.RDB$DEFAULT_CLASS*/
								     isc_549.isc_550);
#line 479 "restore.epp"

			/*END_FOR;*/
                           isc_send (isc_status, (isc_handle*) &req_handle2, (short) 3, (short) 2, &isc_556, (short) 0);
			   }
			   };
#line 481 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 482 "restore.epp"
				MISC_release_request_silent(req_handle2);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 485 "restore.epp"
		}
	}

	MISC_release_request_silent(req_handle2);

	/* Now that changing ownership of tables is over, it is safe to
	   update the database security class in RDB$DATABASE */

	if (tdgbl->database_security_class[0]) // Do it only if it's not NULL 
	{
		/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$DATABASE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_538), (char *) isc_538);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 34, &isc_539, (short) 0);
		   if (!isc_539.isc_541 || isc_status [1]) break;
#line 497 "restore.epp"
			/*MODIFY X USING*/
			{
#line 498 "restore.epp"
			strncpy(/*X.RDB$SECURITY_CLASS*/
				isc_539.isc_540, tdgbl->database_security_class,
#line 499 "restore.epp"
				sizeof(/*X.RDB$SECURITY_CLASS*/
				       isc_539.isc_540));
#line 500 "restore.epp"
			/*END_MODIFY;*/
			isc_ftof (isc_539.isc_540, 32, isc_542.isc_543, 32);
                        isc_send (isc_status, (isc_handle*) &req_handle1, (short) 1, (short) 32, &isc_542, (short) 0);;
#line 501 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 502 "restore.epp"
				MISC_release_request_silent(req_handle1);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 505 "restore.epp"
		/*END_FOR;*/
                   isc_send (isc_status, (isc_handle*) &req_handle1, (short) 2, (short) 2, &isc_544, (short) 0);
		   }
		   };
#line 506 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 507 "restore.epp"
			MISC_release_request_silent(req_handle1);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 510 "restore.epp"

		MISC_release_request_silent(req_handle1);
	}

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 515 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 516 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 518 "restore.epp"

	// Check to see if there is a warning 
	if (gds_status[0] == isc_arg_gds && gds_status[1] == 0
		&& gds_status[2] != isc_arg_end)
	{
		BURP_print_warning(gds_status);
	}

	BURP_verbose (88, NULL, NULL, NULL, NULL, NULL);
	// msg 88 finishing, closing, and going home 

	UINT64 cumul_count = MVOL_fini_read();

	// attach database again to put it online 

	UCHAR dpb[128];
	UCHAR* d = dpb;
	*d++ = (UCHAR) isc_dpb_version1;

	if (flag_on_line)
	{
		*d++ = (UCHAR) isc_dpb_online;
		*d++ = 0;
	}

	if (tdgbl->gbl_sw_user)
	{
		*d++ = (UCHAR) isc_dpb_user_name;
		*d++ = (UCHAR) strlen (tdgbl->gbl_sw_user);
		for (UCHAR* q = (UCHAR*) tdgbl->gbl_sw_user; *q;)
		*d++ = *q++;
	}

	if (tdgbl->gbl_sw_password)
	{
		if (!tdgbl->gbl_sw_service_gbak)
			*d++ = (UCHAR) isc_dpb_password;
		else
			*d++ = (UCHAR) isc_dpb_password_enc;
		*d++ = (UCHAR) strlen (tdgbl->gbl_sw_password);
		for (UCHAR* q = (UCHAR*) tdgbl->gbl_sw_password; *q;)
		*d++ = *q++;
	}

	// set sync writes to engine default 
	
	if (tdgbl->hdr_forced_writes)
		{
		*d++ = (UCHAR) isc_dpb_force_write;
		*d++ = 1;
		*d++ = (UCHAR) tdgbl->hdr_forced_writes;
		// set forced writes to the value which was in the header

		SSHORT l = d - dpb;
		isc_handle db_handle = 0;
		
		if (isc_attach_database (tdgbl->status_vector, 0, database_name,
					(isc_db_handle*) &db_handle, l, (SCHAR*) dpb))
			general_on_error();
		if (isc_detach_database (tdgbl->status_vector, (isc_db_handle*) &db_handle))
			general_on_error();

		/*FINISH*/
		{
		if (DB)
		   isc_detach_database (isc_status, &DB);;
#line 581 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 582 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 584 "restore.epp"
		}

	if (!flag_on_line)
		{
		BURP_print(246, NULL, NULL, NULL, NULL, NULL);
		// msg 246 Database is not online due to failure to activate one or more indices. 
		BURP_print(247, NULL, NULL, NULL, NULL, NULL);
		// msg 247 Run gfix -online to bring database online without active indices. 
		return FINI_DB_NOT_ONLINE;
		}

	/* If the database is to be restored ReadOnly, set it to read_only now! */
	
	if (tdgbl->gbl_sw_mode && tdgbl->gbl_sw_mode_val)
		{
		BURP_verbose (280, NULL, NULL, NULL, NULL, NULL);
		// msg 280: setting database to read-only access 

		d = dpb;
		*d++ = (UCHAR) isc_dpb_version1;
		
		if (tdgbl->gbl_sw_user)
			{
			*d++ = (UCHAR) isc_dpb_user_name;
			*d++ = (UCHAR) strlen (tdgbl->gbl_sw_user);
			for (UCHAR* q = (UCHAR*) tdgbl->gbl_sw_user; *q;)
				*d++ = *q++;
			}

		if (tdgbl->gbl_sw_password)
			{
			if (!tdgbl->gbl_sw_service_gbak)
				*d++ = (UCHAR) isc_dpb_password;
			else
				*d++ = (UCHAR) isc_dpb_password_enc;
			*d++ = (UCHAR) strlen (tdgbl->gbl_sw_password);
			for (UCHAR* q = (UCHAR*) tdgbl->gbl_sw_password; *q;)
				*d++ = *q++;
			}

		*d++ = (UCHAR) isc_dpb_set_db_readonly;
		*d++ = 1;
		*d++ = TRUE;	// set database to readOnly mode 
		SSHORT l = d - dpb;
		isc_handle db_handle = 0;
		
		if (isc_attach_database (tdgbl->status_vector, 0, database_name,
					  (isc_db_handle*) &db_handle, l, (SCHAR*) dpb))
			general_on_error();
			
		if (isc_detach_database (tdgbl->status_vector, (isc_db_handle*) &db_handle))
			general_on_error();
		}

	return FINI_OK;
}

namespace // unnamed, private
{
   struct {
          short isc_42;	/* isc_utility */
   } isc_41;
   struct {
          ISC_QUAD isc_37;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_38;	/* RDB$VALIDATION_SOURCE */
          short isc_39;	/* gds__null_flag */
          short isc_40;	/* gds__null_flag */
   } isc_36;
   struct {
          ISC_QUAD isc_31;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_32;	/* RDB$VALIDATION_BLR */
          short isc_33;	/* isc_utility */
          short isc_34;	/* gds__null_flag */
          short isc_35;	/* gds__null_flag */
   } isc_30;
   struct {
          char  isc_29 [32];	/* RDB$FIELD_NAME */
   } isc_28;
   struct {
          char  isc_45 [32];	/* RDB$GENERATOR_NAME */
   } isc_44;
   struct {
          short isc_55;	/* isc_utility */
   } isc_54;
   struct {
          ISC_QUAD isc_53;	/* RDB$ACL */
   } isc_52;
   struct {
          ISC_QUAD isc_50;	/* RDB$ACL */
          short isc_51;	/* isc_utility */
   } isc_49;
   struct {
          char  isc_48 [32];	/* RDB$SECURITY_CLASS */
   } isc_47;
   struct {
          short isc_62;	/* isc_utility */
   } isc_61;
   struct {
          short isc_60;	/* isc_utility */
   } isc_59;
   struct {
          short isc_58;	/* isc_utility */
   } isc_57;
   struct {
          short isc_70;	/* isc_utility */
   } isc_69;
   struct {
          char  isc_68 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_67;
   struct {
          char  isc_65 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_66;	/* isc_utility */
   } isc_64;
   struct {
          short isc_78;	/* isc_utility */
   } isc_77;
   struct {
          ISC_QUAD isc_76;	/* RDB$DESCRIPTION */
   } isc_75;
   struct {
          ISC_QUAD isc_73;	/* RDB$DESCRIPTION */
          short isc_74;	/* isc_utility */
   } isc_72;
   struct {
          char  isc_81 [32];	/* RDB$CONTEXT_NAME */
          char  isc_82 [32];	/* RDB$RELATION_NAME */
          char  isc_83 [32];	/* RDB$VIEW_NAME */
          short isc_84;	/* RDB$VIEW_CONTEXT */
   } isc_80;
   struct {
          char  isc_87 [32];	/* RDB$RELATION_NAME */
          char  isc_88 [32];	/* RDB$GRANTOR */
          char  isc_89 [32];	/* RDB$USER */
          char  isc_90 [32];	/* RDB$FIELD_NAME */
          short isc_91;	/* gds__null_flag */
          short isc_92;	/* RDB$USER_TYPE */
          short isc_93;	/* gds__null_flag */
          short isc_94;	/* RDB$GRANT_OPTION */
          short isc_95;	/* gds__null_flag */
          short isc_96;	/* RDB$OBJECT_TYPE */
          short isc_97;	/* gds__null_flag */
          char  isc_98 [7];	/* RDB$PRIVILEGE */
   } isc_86;
   struct {
          char  isc_101 [32];	/* RDB$FIELD_NAME */
          char  isc_102 [32];	/* RDB$TYPE_NAME */
          ISC_QUAD isc_103;	/* RDB$DESCRIPTION */
          short isc_104;	/* RDB$TYPE */
          short isc_105;	/* gds__null_flag */
          short isc_106;	/* RDB$SYSTEM_FLAG */
          short isc_107;	/* gds__null_flag */
   } isc_100;
   struct {
          char  isc_110 [32];	/* RDB$TRIGGER_NAME */
          short isc_111;	/* RDB$MESSAGE_NUMBER */
          char  isc_112 [79];	/* RDB$MESSAGE */
   } isc_109;
   struct {
          short isc_117;	/* isc_utility */
   } isc_116;
   struct {
          char  isc_115 [32];	/* RDB$TRIGGER_NAME */
   } isc_114;
   struct {
          char  isc_120 [32];	/* RDB$RELATION_NAME */
          char  isc_121 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_122;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_123;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_124;	/* RDB$DESCRIPTION */
          short isc_125;	/* RDB$TRIGGER_INACTIVE */
          short isc_126;	/* RDB$TRIGGER_SEQUENCE */
          short isc_127;	/* RDB$TRIGGER_TYPE */
          short isc_128;	/* gds__null_flag */
          short isc_129;	/* RDB$FLAGS */
          short isc_130;	/* gds__null_flag */
          short isc_131;	/* RDB$SYSTEM_FLAG */
          short isc_132;	/* gds__null_flag */
          short isc_133;	/* gds__null_flag */
          short isc_134;	/* gds__null_flag */
   } isc_119;
   struct {
          char  isc_137 [32];	/* RDB$RELATION_NAME */
          char  isc_138 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_139;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_140;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_141;	/* RDB$DESCRIPTION */
          short isc_142;	/* RDB$SYSTEM_FLAG */
          short isc_143;	/* RDB$TRIGGER_SEQUENCE */
          short isc_144;	/* RDB$TRIGGER_TYPE */
          short isc_145;	/* gds__null_flag */
          short isc_146;	/* gds__null_flag */
          short isc_147;	/* gds__null_flag */
   } isc_136;
   struct {
          ISC_QUAD isc_150;	/* RDB$ACL */
          char  isc_151 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_152;	/* RDB$DESCRIPTION */
          short isc_153;	/* gds__null_flag */
   } isc_149;
   struct {
          char  isc_156 [32];	/* RDB$OWNER_NAME */
          char  isc_157 [32];	/* RDB$ROLE_NAME */
          short isc_158;	/* gds__null_flag */
          short isc_159;	/* gds__null_flag */
   } isc_155;
   struct {
          char  isc_162 [32];	/* RDB$INDEX_NAME */
          char  isc_163 [32];	/* RDB$RELATION_NAME */
          char  isc_164 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_165 [4];	/* RDB$INITIALLY_DEFERRED */
          char  isc_166 [4];	/* RDB$DEFERRABLE */
          char  isc_167 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_168;	/* gds__null_flag */
          short isc_169;	/* gds__null_flag */
          short isc_170;	/* gds__null_flag */
          short isc_171;	/* gds__null_flag */
          short isc_172;	/* gds__null_flag */
          short isc_173;	/* gds__null_flag */
   } isc_161;
   struct {
          char  isc_176 [32];	/* RDB$RELATION_NAME */
          ISC_QUAD isc_177;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_178;	/* RDB$RUNTIME */
          ISC_QUAD isc_179;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_180;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_181;	/* RDB$VIEW_BLR */
          char  isc_182 [32];	/* RDB$SECURITY_CLASS */
          short isc_183;	/* gds__null_flag */
          char  isc_184 [254];	/* RDB$EXTERNAL_FILE */
          short isc_185;	/* gds__null_flag */
          short isc_186;	/* gds__null_flag */
          short isc_187;	/* gds__null_flag */
          short isc_188;	/* gds__null_flag */
          short isc_189;	/* gds__null_flag */
          short isc_190;	/* gds__null_flag */
          short isc_191;	/* gds__null_flag */
          short isc_192;	/* RDB$FLAGS */
          short isc_193;	/* gds__null_flag */
          short isc_194;	/* RDB$SYSTEM_FLAG */
   } isc_175;
   struct {
          char  isc_197 [8];	/* RDB$MATCH_OPTION */
          char  isc_198 [32];	/* RDB$CONST_NAME_UQ */
          char  isc_199 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_200 [12];	/* RDB$DELETE_RULE */
          char  isc_201 [12];	/* RDB$UPDATE_RULE */
          short isc_202;	/* gds__null_flag */
          short isc_203;	/* gds__null_flag */
          short isc_204;	/* gds__null_flag */
          short isc_205;	/* gds__null_flag */
          short isc_206;	/* gds__null_flag */
   } isc_196;
   struct {
          char  isc_209 [32];	/* RDB$FIELD_SOURCE */
          char  isc_210 [32];	/* RDB$PARAMETER_NAME */
          char  isc_211 [32];	/* RDB$PROCEDURE_NAME */
          ISC_QUAD isc_212;	/* RDB$DESCRIPTION */
          short isc_213;	/* RDB$PARAMETER_NUMBER */
          short isc_214;	/* RDB$PARAMETER_TYPE */
          short isc_215;	/* gds__null_flag */
   } isc_208;
   struct {
          ISC_QUAD isc_218;	/* RDB$PROCEDURE_BLR */
          char  isc_219 [32];	/* RDB$PROCEDURE_NAME */
          char  isc_220 [32];	/* RDB$OWNER_NAME */
          char  isc_221 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_222;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_223;	/* RDB$PROCEDURE_SOURCE */
          short isc_224;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_225;	/* gds__null_flag */
          short isc_226;	/* RDB$PROCEDURE_INPUTS */
          short isc_227;	/* gds__null_flag */
          short isc_228;	/* gds__null_flag */
          short isc_229;	/* gds__null_flag */
          short isc_230;	/* gds__null_flag */
   } isc_217;
   struct {
          short isc_239;	/* isc_utility */
   } isc_238;
   struct {
          short isc_237;	/* isc_utility */
   } isc_236;
   struct {
          short isc_235;	/* isc_utility */
   } isc_234;
   struct {
          char  isc_233 [32];	/* RDB$INDEX_NAME */
   } isc_232;
   struct {
          short isc_245;	/* isc_utility */
   } isc_244;
   struct {
          char  isc_242 [32];	/* RDB$RELATION_NAME */
          char  isc_243 [32];	/* RDB$INDEX_NAME */
   } isc_241;
   struct {
          char  isc_248 [32];	/* RDB$INDEX_NAME */
          char  isc_249 [32];	/* RDB$FIELD_NAME */
          short isc_250;	/* RDB$FIELD_POSITION */
   } isc_247;
   struct {
          char  isc_253 [32];	/* RDB$INDEX_NAME */
          ISC_QUAD isc_254;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_255;	/* RDB$EXPRESSION_SOURCE */
          char  isc_256 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_257;	/* RDB$DESCRIPTION */
          char  isc_258 [32];	/* RDB$RELATION_NAME */
          short isc_259;	/* RDB$SEGMENT_COUNT */
          short isc_260;	/* gds__null_flag */
          short isc_261;	/* gds__null_flag */
          short isc_262;	/* gds__null_flag */
          short isc_263;	/* gds__null_flag */
          short isc_264;	/* gds__null_flag */
          short isc_265;	/* RDB$INDEX_TYPE */
          short isc_266;	/* RDB$INDEX_INACTIVE */
          short isc_267;	/* RDB$UNIQUE_FLAG */
   } isc_252;
   struct {
          char  isc_270 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_271;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_272;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_273;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_274;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_275;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_276;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_277;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_278;	/* RDB$QUERY_HEADER */
          char  isc_279 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_280;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_281;	/* RDB$COMPUTED_BLR */
          short isc_282;	/* gds__null_flag */
          short isc_283;	/* RDB$FIELD_LENGTH */
          short isc_284;	/* RDB$FIELD_TYPE */
          short isc_285;	/* gds__null_flag */
          short isc_286;	/* gds__null_flag */
          short isc_287;	/* gds__null_flag */
          short isc_288;	/* gds__null_flag */
          short isc_289;	/* gds__null_flag */
          short isc_290;	/* gds__null_flag */
          short isc_291;	/* RDB$CHARACTER_LENGTH */
          short isc_292;	/* gds__null_flag */
          short isc_293;	/* gds__null_flag */
          short isc_294;	/* RDB$EXTERNAL_SCALE */
          short isc_295;	/* gds__null_flag */
          short isc_296;	/* RDB$EXTERNAL_TYPE */
          short isc_297;	/* gds__null_flag */
          short isc_298;	/* RDB$EXTERNAL_LENGTH */
          short isc_299;	/* gds__null_flag */
          short isc_300;	/* RDB$DIMENSIONS */
          short isc_301;	/* gds__null_flag */
          short isc_302;	/* gds__null_flag */
          short isc_303;	/* RDB$NULL_FLAG */
          short isc_304;	/* gds__null_flag */
          short isc_305;	/* RDB$SYSTEM_FLAG */
          short isc_306;	/* gds__null_flag */
          short isc_307;	/* gds__null_flag */
          short isc_308;	/* gds__null_flag */
          short isc_309;	/* gds__null_flag */
          short isc_310;	/* gds__null_flag */
          short isc_311;	/* gds__null_flag */
          char  isc_312 [126];	/* RDB$EDIT_STRING */
          short isc_313;	/* gds__null_flag */
          short isc_314;	/* gds__null_flag */
          short isc_315;	/* gds__null_flag */
          short isc_316;	/* RDB$FIELD_SUB_TYPE */
          short isc_317;	/* RDB$COLLATION_ID */
          short isc_318;	/* RDB$CHARACTER_SET_ID */
          short isc_319;	/* RDB$SEGMENT_LENGTH */
          short isc_320;	/* RDB$FIELD_SCALE */
   } isc_269;
   struct {
          char  isc_323 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_324;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_325;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_326;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_327;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_328;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_329;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_330;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_331;	/* RDB$QUERY_HEADER */
          char  isc_332 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_333;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_334;	/* RDB$COMPUTED_BLR */
          short isc_335;	/* gds__null_flag */
          short isc_336;	/* RDB$FIELD_LENGTH */
          short isc_337;	/* RDB$FIELD_TYPE */
          short isc_338;	/* gds__null_flag */
          short isc_339;	/* RDB$FIELD_PRECISION */
          short isc_340;	/* gds__null_flag */
          short isc_341;	/* gds__null_flag */
          short isc_342;	/* gds__null_flag */
          short isc_343;	/* gds__null_flag */
          short isc_344;	/* gds__null_flag */
          short isc_345;	/* gds__null_flag */
          short isc_346;	/* RDB$CHARACTER_LENGTH */
          short isc_347;	/* gds__null_flag */
          short isc_348;	/* gds__null_flag */
          short isc_349;	/* RDB$EXTERNAL_SCALE */
          short isc_350;	/* gds__null_flag */
          short isc_351;	/* RDB$EXTERNAL_TYPE */
          short isc_352;	/* gds__null_flag */
          short isc_353;	/* RDB$EXTERNAL_LENGTH */
          short isc_354;	/* gds__null_flag */
          short isc_355;	/* RDB$DIMENSIONS */
          short isc_356;	/* gds__null_flag */
          short isc_357;	/* gds__null_flag */
          short isc_358;	/* RDB$NULL_FLAG */
          short isc_359;	/* gds__null_flag */
          short isc_360;	/* RDB$SYSTEM_FLAG */
          short isc_361;	/* gds__null_flag */
          short isc_362;	/* gds__null_flag */
          short isc_363;	/* gds__null_flag */
          short isc_364;	/* gds__null_flag */
          short isc_365;	/* gds__null_flag */
          short isc_366;	/* gds__null_flag */
          char  isc_367 [126];	/* RDB$EDIT_STRING */
          short isc_368;	/* gds__null_flag */
          short isc_369;	/* gds__null_flag */
          short isc_370;	/* gds__null_flag */
          short isc_371;	/* RDB$FIELD_SUB_TYPE */
          short isc_372;	/* RDB$COLLATION_ID */
          short isc_373;	/* RDB$CHARACTER_SET_ID */
          short isc_374;	/* RDB$SEGMENT_LENGTH */
          short isc_375;	/* RDB$FIELD_SCALE */
   } isc_322;
   struct {
          char  isc_378 [32];	/* RDB$FUNCTION_NAME */
          short isc_379;	/* RDB$FIELD_LENGTH */
          short isc_380;	/* RDB$FIELD_SCALE */
          short isc_381;	/* RDB$FIELD_TYPE */
          short isc_382;	/* RDB$MECHANISM */
          short isc_383;	/* RDB$ARGUMENT_POSITION */
          short isc_384;	/* gds__null_flag */
          short isc_385;	/* RDB$CHARACTER_SET_ID */
          short isc_386;	/* gds__null_flag */
          short isc_387;	/* RDB$FIELD_SUB_TYPE */
   } isc_377;
   struct {
          char  isc_390 [32];	/* RDB$FUNCTION_NAME */
          short isc_391;	/* RDB$FIELD_LENGTH */
          short isc_392;	/* RDB$FIELD_SCALE */
          short isc_393;	/* RDB$FIELD_TYPE */
          short isc_394;	/* RDB$MECHANISM */
          short isc_395;	/* RDB$ARGUMENT_POSITION */
          short isc_396;	/* gds__null_flag */
          short isc_397;	/* RDB$FIELD_PRECISION */
          short isc_398;	/* gds__null_flag */
          short isc_399;	/* RDB$CHARACTER_SET_ID */
          short isc_400;	/* gds__null_flag */
          short isc_401;	/* RDB$FIELD_SUB_TYPE */
   } isc_389;
   struct {
          char  isc_404 [32];	/* RDB$QUERY_NAME */
          char  isc_405 [32];	/* RDB$ENTRYPOINT */
          ISC_QUAD isc_406;	/* RDB$DESCRIPTION */
          char  isc_407 [32];	/* RDB$FUNCTION_NAME */
          short isc_408;	/* RDB$FUNCTION_TYPE */
          short isc_409;	/* RDB$RETURN_ARGUMENT */
          char  isc_410 [254];	/* RDB$MODULE_NAME */
   } isc_403;
   struct {
          char  isc_413 [32];	/* RDB$ENTRYPOINT */
          char  isc_414 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_415;	/* RDB$DESCRIPTION */
          short isc_416;	/* RDB$OUTPUT_SUB_TYPE */
          short isc_417;	/* RDB$INPUT_SUB_TYPE */
          char  isc_418 [254];	/* RDB$MODULE_NAME */
          short isc_419;	/* gds__null_flag */
   } isc_412;
   struct {
          SLONG isc_422;	/* RDB$FILE_LENGTH */
          SLONG isc_423;	/* RDB$FILE_START */
          short isc_424;	/* RDB$SHADOW_NUMBER */
          short isc_425;	/* RDB$FILE_SEQUENCE */
          char  isc_426 [254];	/* RDB$FILE_NAME */
          short isc_427;	/* RDB$FILE_FLAGS */
   } isc_421;
   struct {
          char  isc_430 [32];	/* RDB$FIELD_NAME */
          SLONG isc_431;	/* RDB$UPPER_BOUND */
          SLONG isc_432;	/* RDB$LOWER_BOUND */
          short isc_433;	/* RDB$DIMENSION */
   } isc_429;
   struct {
          char  isc_436 [32];	/* RDB$FIELD_SOURCE */
          char  isc_437 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_438;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_439;	/* RDB$DEFAULT_SOURCE */
          char  isc_440 [32];	/* RDB$COMPLEX_NAME */
          ISC_QUAD isc_441;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_442;	/* RDB$QUERY_HEADER */
          char  isc_443 [32];	/* RDB$SECURITY_CLASS */
          char  isc_444 [32];	/* RDB$BASE_FIELD */
          char  isc_445 [32];	/* RDB$QUERY_NAME */
          char  isc_446 [32];	/* RDB$RELATION_NAME */
          short isc_447;	/* gds__null_flag */
          short isc_448;	/* RDB$COLLATION_ID */
          short isc_449;	/* gds__null_flag */
          short isc_450;	/* RDB$NULL_FLAG */
          short isc_451;	/* gds__null_flag */
          short isc_452;	/* gds__null_flag */
          short isc_453;	/* gds__null_flag */
          short isc_454;	/* RDB$UPDATE_FLAG */
          short isc_455;	/* gds__null_flag */
          short isc_456;	/* gds__null_flag */
          short isc_457;	/* RDB$SYSTEM_FLAG */
          short isc_458;	/* gds__null_flag */
          short isc_459;	/* gds__null_flag */
          short isc_460;	/* gds__null_flag */
          char  isc_461 [126];	/* RDB$EDIT_STRING */
          short isc_462;	/* gds__null_flag */
          short isc_463;	/* gds__null_flag */
          short isc_464;	/* gds__null_flag */
          short isc_465;	/* gds__null_flag */
          short isc_466;	/* gds__null_flag */
          short isc_467;	/* RDB$VIEW_CONTEXT */
          short isc_468;	/* RDB$FIELD_POSITION */
   } isc_435;
   struct {
          char  isc_471 [32];	/* RDB$EXCEPTION_NAME */
          ISC_QUAD isc_472;	/* RDB$DESCRIPTION */
          short isc_473;	/* gds__null_flag */
          short isc_474;	/* gds__null_flag */
          char  isc_475 [79];	/* RDB$MESSAGE */
   } isc_470;
   struct {
          short isc_485;	/* isc_utility */
   } isc_484;
   struct {
          short isc_483;	/* RDB$INDEX_INACTIVE */
   } isc_482;
   struct {
          short isc_480;	/* isc_utility */
          short isc_481;	/* RDB$INDEX_INACTIVE */
   } isc_479;
   struct {
          char  isc_478 [32];	/* RDB$INDEX_NAME */
   } isc_477;
   struct {
          char  isc_488 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_489;	/* RDB$DESCRIPTION */
          char  isc_490 [32];	/* RDB$COLLATION_NAME */
          short isc_491;	/* gds__null_flag */
          short isc_492;	/* gds__null_flag */
          short isc_493;	/* gds__null_flag */
          short isc_494;	/* RDB$SYSTEM_FLAG */
          short isc_495;	/* gds__null_flag */
          short isc_496;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_497;	/* gds__null_flag */
          short isc_498;	/* RDB$CHARACTER_SET_ID */
          short isc_499;	/* gds__null_flag */
          short isc_500;	/* RDB$COLLATION_ID */
          short isc_501;	/* gds__null_flag */
   } isc_487;
   struct {
          char  isc_504 [32];	/* RDB$TRIGGER_NAME */
          char  isc_505 [32];	/* RDB$CONSTRAINT_NAME */
          short isc_506;	/* gds__null_flag */
          short isc_507;	/* gds__null_flag */
   } isc_503;
   struct {
          char  isc_510 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_511;	/* RDB$DESCRIPTION */
          char  isc_512 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_513 [32];	/* RDB$FORM_OF_USE */
          char  isc_514 [32];	/* RDB$CHARACTER_SET_NAME */
          SLONG isc_515;	/* RDB$NUMBER_OF_CHARACTERS */
          short isc_516;	/* gds__null_flag */
          short isc_517;	/* RDB$BYTES_PER_CHARACTER */
          short isc_518;	/* gds__null_flag */
          short isc_519;	/* gds__null_flag */
          short isc_520;	/* gds__null_flag */
          short isc_521;	/* RDB$SYSTEM_FLAG */
          short isc_522;	/* gds__null_flag */
          short isc_523;	/* RDB$CHARACTER_SET_ID */
          short isc_524;	/* gds__null_flag */
          short isc_525;	/* gds__null_flag */
          short isc_526;	/* gds__null_flag */
          short isc_527;	/* gds__null_flag */
   } isc_509;
   struct {
          short isc_530;	/* isc_utility */
   } isc_529;
   struct {
          short isc_533;	/* isc_utility */
   } isc_532;
   struct {
          SLONG isc_536;	/* RDB$FILE_START */
          char  isc_537 [254];	/* RDB$FILE_NAME */
   } isc_535;
#line 643 "restore.epp"

void add_files (const UCHAR* file_name)
{
/**************************************
 *
 *	a d d _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	This should be a multi-file database.
 *	Store files and starting
 *	addresses & commit this much.
 *
 **************************************/
	isc_req_handle  req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/* store the RDB$FILES records */

	SLONG start = 201; // Magic number, can be taken from some constant?
	SLONG count = 0;

	for (FIL file = tdgbl->gbl_sw_files; file; file = file->fil_next)
	{
		if (strcmp (file->fil_name, (char*) file_name))
		{
			count++;
			/*STORE (REQUEST_HANDLE req_handle1)
				X IN RDB$FILES*/
			{
			
                        if (!req_handle1)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_534), (char *) isc_534);
			if (req_handle1)
			   {
#line 674 "restore.epp"
				strcpy (/*X.RDB$FILE_NAME*/
					isc_535.isc_537, file->fil_name);
#line 675 "restore.epp"
				/*X.RDB$FILE_START*/
				isc_535.isc_536 = start;
#line 676 "restore.epp"
			/*END_STORE;*/
			   
                           isc_start_and_send (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 258, &isc_535, (short) 0);
			   };
#line 677 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 678 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 680 "restore.epp"
				MISC_release_request_silent(req_handle1);
			BURP_verbose (57, file->fil_name, (void*) start, NULL, NULL, NULL);
			// msg 57 adding file %s, starting at page %ld 
		}
		else if (((signed long )file->fil_length) >= start - 1)
			file->fil_length -= start - 1;
		else
		{
			BURP_print (96, (void*) file->fil_length, (void*) (start - 1), NULL,
						NULL, NULL);
			// msg 96  length given for initial file (%ld) is less than minimum (%ld)
			file->fil_length = 0;
		}

		start += file->fil_length;
	}

	if (count)
	{
		BURP_verbose (70, NULL, NULL, NULL, NULL, NULL);
		  // msg 70 committing secondary files
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 702 "restore.epp"
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 704 "restore.epp"
			BURP_print (174, NULL, NULL, NULL, NULL, NULL);
				// msg 174 cannot commit files
			BURP_print_status (tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 708 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 709 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 711 "restore.epp"
		/*END_ERROR;*/
		   }
		}
#line 712 "restore.epp"

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_6);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 714 "restore.epp"
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_7);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 716 "restore.epp"
	}
}

void bad_attribute (scan_attr_t		scan_next_attr,
					ATT_TYPE	bad_attr,
					USHORT	type)
{
/**************************************
 *
 *	b a d _ a t t r i b u t e
 *
 **************************************
 *
 * Functional description
 *	We ran into an unsupported attribute.
 *	but it isn't the end of the world.
 *	We will try to skip some bad data and
 *	look for next valid attribute to continue the process.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	SLONG skip_count = 0;

	if (!tdgbl->gbl_sw_skip_count)
	{
        TEXT t_name[128];
		gds__msg_format(NULL, 12, type, sizeof(t_name), t_name, NULL, NULL,
						NULL, NULL, NULL);
		BURP_print (80, t_name, (void*) bad_attr, NULL, NULL, NULL);
		// msg 80  don't recognize %s attribute %ld -- continuing 
		const SSHORT skip_l = get(tdgbl);
		if (skip_l)
			get_skip(tdgbl, skip_l);
	}
	else
	{
		if (scan_next_attr == NO_SKIP)
		{
			skip_count = tdgbl->gbl_sw_skip_count;
			get_skip(tdgbl, skip_count);
			BURP_print (203, (void*) skip_count, (void*) bad_attr, NULL, NULL, NULL);
			//msg 203: skipped %d bytes after reading a bad attribute %d 
		}
		else
		{
			++skip_count;
			BURP_print (205, (void*) skip_count, (void*) bad_attr, NULL, NULL, NULL);
			// msg 205: skipped %d bytes looking for next valid attribute, encountered attribute %d 
		}
		scan_next_attr = AFTER_SKIP;
	}
}

USHORT check_db_version()
{
/**************************************
 *
 *	c h e c k _ d b _ v e r s i o n
 *
 **************************************
 *
 * Functional description
 *	Find the version number of the database.
 *
 **************************************/
	isc_req_handle  req_handle1 = NULL, req_handle2 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	USHORT db_version = DB_VERSION_DDL4;
	/*FOR (REQUEST_HANDLE req_handle1)
		FIRST 1 X IN RDB$RELATIONS
		WITH X.RDB$RELATION_NAME = "RDB$TRIGGERS"*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_531), (char *) isc_531);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 2, &isc_532, (short) 0);
	   if (!isc_532.isc_533 || isc_status [1]) break;
#line 790 "restore.epp"
		db_version = DB_VERSION_DDL5;
	/*END_FOR;*/
	   }
	   };
#line 792 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 793 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 795 "restore.epp"
	MISC_release_request_silent(req_handle1);
	/*FOR (REQUEST_HANDLE req_handle2)
		FIRST 1 X IN RDB$RELATIONS
		WITH X.RDB$RELATION_NAME = "RDB$PROCEDURES"*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_528), (char *) isc_528);
	if (req_handle2)
           isc_start_request (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 0, (short) 2, &isc_529, (short) 0);
	   if (!isc_529.isc_530 || isc_status [1]) break;
#line 799 "restore.epp"
		db_version = DB_VERSION_DDL8;
	/*END_FOR;*/
	   }
	   };
#line 801 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 802 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 804 "restore.epp"
	MISC_release_request_silent(req_handle2);

	return db_version;
}

void create_database (const TEXT* file_name)
{
/**************************************
 *
 *	c r e a t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	create the new database, looking
 *	to see if there are any interesting
 *	things to do.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	/* Get (physical) database record */

	ULONG page_size = DEFAULT_PAGE_SIZE;
	// sweep_interval = -1;
	// sweep_interval = 0xFFFFFFFF;
	ULONG sweep_interval = MAX_ULONG;
	bool no_reserve = false;
	bool db_read_only = false, SQL_dialect_flag = false;
	USHORT forced_writes = 2; // default for the current platform 
	ULONG page_buffers = 0;
    USHORT SQL_dialect = 0;

	ATT_TYPE attribute;
	rec_type record;
	if (get_record(&record, tdgbl) == rec_physical_db)
	{
		while (get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_SQL_dialect:
				SQL_dialect_flag = true;
				SQL_dialect = (USHORT) get_numeric();
				break;

			case att_page_size:
				page_size = get_numeric();
				break;

			case att_sweep_interval:
				sweep_interval = get_numeric();
				break;

			case att_forced_writes:
				forced_writes = (USHORT) get_numeric();
				break;

			case att_no_reserve:
				no_reserve = (USHORT) get_numeric() != FALSE;
				break;

			case att_db_read_only:
				db_read_only = get_numeric() != FALSE;
				break;

			case att_page_buffers:
				page_buffers = get_numeric();
				break;

			default:
				{
					const SSHORT l = get(tdgbl);
					if (l) {
						get_skip(tdgbl, l);
					}
					break;
				}
			}
		}
		get_record(&record, tdgbl);
	}

	if (record != rec_database)
		BURP_error_redirect (NULL, 32, 0, 0);
		// msg 32 Expected database description record 

	if (tdgbl->gbl_sw_page_size &&
		(tdgbl->gbl_sw_page_size < page_size))
	{
		BURP_print (110, (void*) page_size,
					(void*) (ULONG) tdgbl->gbl_sw_page_size, NULL, NULL, NULL);
		// msg 110 Reducing the database page size from %ld bytes to %ld bytes 
	}

	if (tdgbl->gbl_sw_page_size)
		page_size = tdgbl->gbl_sw_page_size;

	tdgbl->hdr_forced_writes = forced_writes;

	if (tdgbl->gbl_sw_no_reserve)
		no_reserve = tdgbl->gbl_sw_no_reserve != FALSE;

	// Override attribute setting with user requirement 
	if (tdgbl->gbl_sw_mode)
		db_read_only = tdgbl->gbl_sw_mode_val;
	else
	{
		/* No access mode specified by user. Use attribute settings. Since the
		 * database is set to readOnly only after making it Online in
		 * RESTORE_restore(), pass on this information through Global structures */
		tdgbl->gbl_sw_mode = true;
		tdgbl->gbl_sw_mode_val = db_read_only;
	}

	if (tdgbl->gbl_sw_page_buffers)
		page_buffers = tdgbl->gbl_sw_page_buffers;

	UCHAR dpb[128];
	UCHAR* d = dpb;
	*d++ = (UCHAR) isc_dpb_version1;
	*d++ = (UCHAR) isc_dpb_page_size;
	*d++ = 2;
	*d++ = 0;
	*d++ = (UCHAR) (page_size >> 8);
	*d++ = (UCHAR) isc_dpb_gbak_attach;
	*d++ = (UCHAR) strlen(GDS_VERSION);
	for (const TEXT* gvp = GDS_VERSION; *gvp;)
		*d++ = *gvp++;

	if (sweep_interval != MAX_ULONG)
	{
		*d++ = (UCHAR) isc_dpb_sweep_interval;
		*d++ = 4;
		*d++ = (UCHAR) sweep_interval;
		*d++ = (UCHAR) (sweep_interval >> 8);
		*d++ = (UCHAR) (sweep_interval >> 16);
		*d++ = (UCHAR) (sweep_interval >> 24);
	}

	/* If the database is to be restored "read_only", fillup the data pages */
	if (no_reserve || db_read_only)
	{
		*d++ = (UCHAR) isc_dpb_no_reserve;
		*d++ = 1;
		*d++ = TRUE;
	}
	if (tdgbl->gbl_sw_user)
	{
		*d++ = (UCHAR) isc_dpb_user_name;
		*d++ = (UCHAR) strlen (tdgbl->gbl_sw_user);
		for (const UCHAR* q = (UCHAR*) tdgbl->gbl_sw_user; *q;)
			*d++ = *q++;
	}
	if (tdgbl->gbl_sw_password)
	{
		if (!tdgbl->gbl_sw_service_gbak)
			*d++ = (UCHAR) isc_dpb_password;
		else
			*d++ = (UCHAR) isc_dpb_password_enc;
		*d++ = (UCHAR) strlen (tdgbl->gbl_sw_password);
		for (const UCHAR* q = (UCHAR*) tdgbl->gbl_sw_password; *q;)
			*d++ = *q++;
	}
	if (page_buffers)
	{
		*d++ = (UCHAR) isc_dpb_set_page_buffers;
		*d++ = 4;
		*d++ = (UCHAR) page_buffers;
		*d++ = (UCHAR) (page_buffers >> 8);
		*d++ = (UCHAR) (page_buffers >> 16);
		*d++ = (UCHAR) (page_buffers >> 24);
	}

	// Turn off sync writes during restore 
	*d++ = (UCHAR) isc_dpb_force_write;
	*d++ = 1;
	*d++ = 0;

	/*
	**
	** which SQL dialect that this database speaks
	** When we restore backup files that came from prior
	** to V6, we force the SQL database dialect to 1
	**
	*/

	*d++ = (UCHAR) isc_dpb_sql_dialect;
	*d++ = 1;
	if (SQL_dialect_flag)
		*d++ = (UCHAR) SQL_dialect;
	else
		*d++ = (UCHAR) SQL_DIALECT_V5;

	// start database up shut down 
	*d++ = (UCHAR) isc_dpb_shutdown;
	*d++ = 1;
	*d++ = (UCHAR) isc_dpb_shut_attachment;
	*d++ = (UCHAR) isc_dpb_shutdown_delay;
	*d++ = 2;
	*d++ = 0;
	*d++ = 0;

	const SSHORT l = d - dpb;
	ISC_STATUS_ARRAY status_vector;

	if (isc_create_database (status_vector, 0, file_name,
							&DB, l, (const SCHAR*) dpb, 0))
	{
		BURP_error_redirect (status_vector, 33, file_name, 0);
	// msg 33 failed to create database %s 
	}

	if (tdgbl->gbl_sw_version)
	{
		BURP_print(139, file_name, NULL, NULL, NULL, NULL);
		/* msg 139 Version(s) for database "%s" */
		isc_version(&DB, BURP_output_version, (void*) "\t%s\n");
	}

	BURP_verbose (74, file_name, (void*) page_size, NULL, NULL, NULL);
	// msg 74 created database %s, page_size %ld bytes 
}

void decompress(UCHAR* buffer,
				USHORT	length)
{
/**************************************
 *
 *	d e c o m p r e s s
 *
 **************************************
 *
 * Functional description
 *	Get a number of compressed bytes.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	UCHAR* p = buffer;
	const UCHAR* const end = p + length;

	while (p < end)
	{
		// This change was made to restore National Semi-Conductor's corrupted 
		// gbak file and it is in the code base now.  -Andrew                  

        // so count really only to 255
		SSHORT count = (SCHAR) get(tdgbl);
		if (count > 0)
		{
			if (end - p < count)
			{
				BURP_print (202, (void*) (SLONG) count,
							(void*) (ULONG) (end - p), NULL, NULL, NULL);
				// msg 202: adjusting a decompression length error: invalid length  %d was adjusted to %d 
				count = end - p;
			}
			p = get_block(tdgbl, p, count);
		}
		else if (count < 0)
		{
			if (end + count < p)
			{
				BURP_print(202, (void*) (SLONG) count,
						   (void*) (ULONG) (p - end), NULL, NULL, NULL);
				// msg 202: adjusting a decompression length error: invalid length %d was adjusted to %d 
				count = p - end;
			}
			const UCHAR c = get(tdgbl);
			memset (p, c, -count);
			p += -count;
		}
	}

	if (p > end) {
		BURP_error_redirect (NULL, 34, 0, 0);
		// msg 34 RESTORE: decompression length error 
	}
}

void eat_blob()
{
/**************************************
 *
 *	e a t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Discard a blob from backup file
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	const SLONG length = get_numeric();

	get_skip(tdgbl, length);
}

BURP_REL find_relation (const TEXT* name)
{
/**************************************
 *
 *	f i n d _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Given a relation name, find the relation block.  If there isn't
 *	one, produce a fatal error.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	// Why isn't strcmp used here?
	for (burp_rel* relation = tdgbl->relations; relation;
		relation = relation->rel_next)
	{
		for (const TEXT* p = relation->rel_name, *q = name; *p == *q; p++, q++) {
			if (!*p)
				return relation;
		}
	}

	BURP_error_redirect (NULL, 35, name, 0);
	// msg 35 can't find relation %s 

	return NULL;
}

void general_on_error()
{
/**************************************
 *
 *	g e n e r a l _ o n _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	Handle any general ON_ERROR clause during restore.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	BURP_print_status (isc_status);
	BURP_abort ();
}

bool get_acl (const TEXT	*owner_nm,
			  ISC_QUAD 	*blob_id,
			  ISC_QUAD	*new_blob_id)
{
/**************************************
 *
 *	g e t _ a c l
 *
 **************************************
 *
 * Functional description
 *
 *	open the blob that contains the ACL list
 *	get the ACL list of a relation
 *	replace the owner of the relation in the ACL list with
 *	  the creator of the relation
 *	create a new blob
 *	store the new ACL list in the new blob
 *
 **************************************/

	static const SCHAR blr_items[] = {isc_info_blob_max_segment,
					 isc_info_blob_total_length,
					 isc_info_blob_num_segments};

	TGBL tdgbl = GET_THREAD_DATA;

	// If the blob is null, don't store it.  It will be restored as null. 

	if (!blob_id->gds_quad_high && !blob_id->gds_quad_low)
		return false;

	ISC_STATUS_ARRAY	status_vector;
	// Open the blob and get it's vital statistics 

	isc_handle blob = NULL;

	if (isc_open_blob (status_vector, &DB,  &gds_trans, &blob, blob_id))
	{
		// msg 24 isc_open_blob failed 
		BURP_error_redirect (status_vector, 24, NULL, NULL);
	}

	UCHAR blob_info[32];
	if (isc_blob_info (status_vector,  &blob, sizeof(blr_items),
				   blr_items, sizeof(blob_info), (SCHAR*) blob_info))
	{
		// msg 20 isc_blob_info failed 
		BURP_error_redirect (status_vector, 20, NULL, NULL);
	}

	SLONG length = 0;
	UCHAR item;
	USHORT max_segment, num_segments;
	const UCHAR* p = blob_info;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = (USHORT) gds__vax_integer (p, 2);
		p += 2;
		const SLONG n = gds__vax_integer (p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = (USHORT) n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		case isc_info_blob_num_segments:
			num_segments = (USHORT) n;
			/*
			** we assume that the ACL list was written out as
			** in one big segment
			**
			*/
			if (num_segments > 1) {
				// CVC: I can't see the effect of assert(true)
				fb_assert (num_segments > 1);
			}
			break;

		default:
			// msg 79 don't understand blob info item %ld  
			BURP_print (79, (void*) (ULONG) item, NULL, NULL, NULL, NULL);
			// CVC: do you return, without closing the blob, dear function???
			if (isc_close_blob (status_vector,  &blob))
				BURP_error_redirect (status_vector, 23, NULL, NULL);
				// msg 23 isc_close_blob failed
			return false;
		}
	}

	if (!length)
	{
		if (isc_close_blob (status_vector,  &blob))
			BURP_error_redirect (status_vector, 23, NULL, NULL);
			// msg 23 isc_close_blob failed 
		return false;
	}

	// Rdb sometimes gets the length messed up 

	if (length < max_segment)
		length = max_segment;

	/*
	** Allocate a buffer large enough for the largest segment and start
	** grinding.
	*/
	UCHAR static_buffer[1024];
	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc (max_segment);

	USHORT return_length = 0;
	isc_get_segment (status_vector, &blob, &return_length, max_segment,
			(SCHAR*) buffer);
	// CVC: we don't check the result of the function. We don't check the
	// return_length's value either.

	if (isc_close_blob (status_vector, &blob))
	{
		if (buffer != static_buffer)
			BURP_free (buffer);
		// msg 23 isc_close_blob failed 
		BURP_error_redirect (status_vector, 23, NULL, NULL);
	}

	const UCHAR* from = buffer + 3; // skip ACL_version, ACL_id_list, and id_person
	const SLONG id_person_len = (SLONG) *from;

	const UCHAR* c_1 = (UCHAR*) owner_nm;
	const UCHAR owner_nm_len = strlen(owner_nm);

	UCHAR* new_buffer = BURP_alloc (length - id_person_len + owner_nm_len);

	from = buffer;
	UCHAR* to = new_buffer;
	*to++ = *from++; // copy ACL_verion 
	*to++ = *from++; // copy ACL_id_list 
	*to++ = *from++; // copy id_person 
	*to++ = owner_nm_len;
	
	USHORT new_len = 4; //new_len + 4; Previously, new_len was set to zero at the top
	// from = buffer + id_person_len + 4; redundant, see 2nd loop below.
	for (SLONG cnt = 0; cnt < owner_nm_len; cnt++)
	{
		*to++ = *c_1++;
		new_len++;
	}

	const UCHAR* const end_buffer = buffer + length;
	for (from = buffer + id_person_len + 4; from < end_buffer; from++)
	{
		*to++ = *from;
		new_len++;
	}

	isc_blob_handle	blob_handle = NULL;
	if (isc_create_blob2 (status_vector, &DB, &gds_trans,
						  &blob_handle, new_blob_id, 0, NULL))
	{
		if (buffer != static_buffer)
			BURP_free (buffer);
		if (new_buffer != NULL)
			BURP_free (new_buffer);
		// msg 37 isc_create_blob failed 
		BURP_error_redirect (status_vector, 37, 0, 0);
	}

	if (isc_put_segment (status_vector, &blob_handle, new_len,
		reinterpret_cast<const SCHAR*>(new_buffer)))
	{
		if (buffer != static_buffer)
			BURP_free (buffer);
		if (new_buffer != NULL)
			BURP_free (new_buffer);
		// msg 38 isc_put_segment failed 
		BURP_error_redirect (status_vector, 38, 0, 0);
	}

	if (isc_close_blob (status_vector, &blob_handle))
	{
		if (buffer != static_buffer)
			BURP_free (buffer);
		if (new_buffer != NULL)
			BURP_free (new_buffer);
		// msg 23 isc_close_blob failed 
		BURP_error_redirect (status_vector, 23, 0, 0);
	}

	if (buffer != static_buffer)
		BURP_free (buffer);

	if (new_buffer != NULL)
		BURP_free (new_buffer);

	return true;
}

void get_array (BURP_REL	relation,
				UCHAR	*record_buffer)
{
/**************************************
 *
 *	g e t _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Read array data from input file to nice,
 *	shiney, new array.
 *
 **************************************/
	BURP_FLD		field;
	ISC_STATUS_ARRAY	status_vector;
	USHORT		count, field_number, field_length;
	UCHAR		*buffer, *p;
	UCHAR		blr_buffer[200]; // enough for a sdl with 16 dimensions
	LSTRING		xdr_slice;

	TGBL tdgbl = GET_THREAD_DATA;

	// don't free something you don't allocate 
	LSTRING xdr_buffer;
	xdr_buffer.lstr_allocated = 0;

	// Pick up attributes 
	SLONG		fld_ranges[2 * MAX_DIMENSION];
	SLONG       slice_length;
	SLONG       *range, *end_ranges;
	scan_attr_t scan_next_attr;
	skip_init(&scan_next_attr);
	ATT_TYPE	attribute;
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT)get_numeric();
			for (field = relation->rel_fields; field; field = field->fld_next) {
				if (field->fld_number == field_number)
					break;
			}
			if (!field) {
				BURP_error_redirect (NULL, 36, 0, 0);
				// msg 36 Can't find field for blob 
			}

			field_length = field->fld_length;
			if (field->fld_type == blr_varying)
				field_length += sizeof(USHORT);
			slice_length = field_length;
			//
			// Copy the ranges onto a buffer and let the program
			// mess with the copy rather than the original
			//
			memcpy(fld_ranges, field->fld_ranges, sizeof(fld_ranges));
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT)get_numeric();
			end_ranges = fld_ranges + 2 * field->fld_dimensions;
			for (range = fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array 
				else
					range[0] = get_numeric();
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array 
				else
					range[1] = get_numeric();
				slice_length *= (range[1] - range[0] + 1);
			}
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 58);
			// msg 58 array 
			break;
		}
	}

	SLONG return_length = get(tdgbl);
	return_length |= get(tdgbl) << 8;
	return_length |= get(tdgbl) << 16;
	return_length |= get(tdgbl) << 24;

	SLONG* blob_id = (SLONG*) ((UCHAR*) record_buffer + field->fld_offset);

	SLONG last_element_dim[MAX_DIMENSION];
	if (return_length != slice_length)
	{
		int upper, lower;
		//
		// Ugh!  The full array wasn't returned and versions of gbak prior to
		// V3.2I don't explicitly signal this.  We must recompute the top
		// element to restore.
		//
		// Double Ugh!  gbak (Versions prior to 5.0) while backing up calculates
		// the top dimensions incorrectly So whatever was written as top dimensions
		// is useless. 5.0 gbak has written correct dimensions, but what the heck
		// we'll calculate it again
		//

		int elements_remaining = return_length / field_length;
		//
		// Backup (versions prior to 5.0) has surely written wrong dimensions.
		// Ignore whatever is read in fld_ranges and calculate the dimensions
		// of the last element. field->fld_ranges has the max dimensions.
		// last_element_dim holds only the upper bounds of each dimension.
		//
		for (int i1 = 0, i3 = 0; i1 < field->fld_dimensions; i1++)
		{
			int divisor = 1;
			for (int i2 = (2 * (i1 + 1) + 1); i2 <= field->fld_dimensions * 2; i2 += 2)
				divisor *= (field->fld_ranges[i2] - field->fld_ranges[i2 - 1] + 1);
			last_element_dim[i1] =
					(elements_remaining - 1) / divisor + field->fld_ranges[i3];
			elements_remaining  -=
					(last_element_dim[i1] - field->fld_ranges[i3]) * divisor;
			i3 += 2;
		}
		
		int current_dim;
#ifdef DEBUG
		ib_fprintf(ib_stderr, "\nLast element upper bounds read from backup file:\n");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			ib_fprintf(ib_stderr,"%ld ",fld_ranges[current_dim]);
		ib_fprintf(ib_stderr, "\nCalculated Last element upper bounds :\n");
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
			ib_fprintf(ib_stderr,"%ld ",last_element_dim[current_dim]);
		ib_fprintf(ib_stderr,"return_length = %ld\n", return_length);
		ib_fprintf(ib_stderr,"elements_returned = %ld\n", return_length/field_length);
		ib_fprintf(ib_stderr,"Max dims[");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			ib_fprintf(ib_stderr,"%ld ",field->fld_ranges[current_dim]);
		ib_fprintf(ib_stderr,"]");
#endif
		int data_at = 0;
		//
		// We have an irregurlar shaped slice to write. The following for loop
		// chops the array into writable rectangular/square slice and sends it
		// to the engine. When the loop cycles through all dimensions, we would
		// have written the whole of the irregular slice.
		//
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
		{
			UCHAR* blr = blr_buffer;
			bool dont_write = false;

			// build the sdl 

			stuff(&blr, isc_sdl_version1);

			stuff(&blr, isc_sdl_struct);
			stuff(&blr, 1);

			if (field->fld_type == blr_text || field->fld_type == blr_varying)
			{
				if (field->fld_type == blr_text)
					stuff(&blr, blr_text2);
				else
					stuff(&blr, blr_varying2);
				stuff_word(&blr, field->fld_character_set_id);
				stuff_word(&blr, field->fld_length);
			}
			else if (field->fld_type == blr_short || field->fld_type == blr_long ||
					 field->fld_type == blr_quad || field->fld_type == blr_int64)
			{
				stuff(&blr, field->fld_type);
				stuff(&blr, field->fld_scale);
			}
			else
				stuff(&blr, field->fld_type);


			stuff(&blr, isc_sdl_relation);
			stuff_string(&blr, relation->rel_name);
			stuff(&blr, isc_sdl_field);
			stuff_string(&blr, field->fld_name);

			// each element spec starts here  

#ifdef DEBUG
			ib_fprintf(ib_stderr,"\nBounds written[");
#endif
			int elements_written = 1;
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			//
			// Here is the important work. Calculate the the bounds to be written
			// so that the resulting slice is a rectangular/square slice.
			// For a 2 dimensional array of size 1..N, 1..M, which is partially
			// filled, we have already calculated the dims of last element. Say
			// if this was x,y (x is row, y is column) then we do
			//    isc_put_slice(1..x-1, 1..M);
			//    isc_put_slice(x..x, 1..y);
			// similarly for a 3D array [N,M,K] whose last element dims are (x,y,z)
			//    isc_put_slice(1..x-1, 1..M, 1..K);
			//    isc_put_slice(x..x, 1..y-1, 1..K);
			//    isc_put_slice(x..x, y..y, 1..z);
			// This is applicable for any number of dimensions.
			// Special cases:
			// for example in case of a 2D array (10,10) and if the last element
			// dims were (1,2), we would just do a isc_put_slice(1..1, 1..2).
			// This is applied for any number of dimensions.
			//
			for (range = field->fld_ranges, count = 0; range < end_ranges;
				range += 2, count++)
			{
				stuff(&blr, isc_sdl_do2);
				stuff(&blr, count);
				//
				// Normally we loop through all dimensions chopping off slices
				// and writing them. This works fine but this also means that
				// we blindly put slices without actually figuring out if we
				// really need to do so. For eg: if we have a 2D array of
				// size [10,4] and the last element dims are [6,4] then all
				// we need to do is is to put one slice as
				//   isc_put_slice(1..6,1..4)
				// rather than looping through the dimensions and putting
				//   isc_put_slice(1..5,1..4)
				//   isc_put_slice(6..6,1..4)
				// we could extend this logic to any no of dims. The following
				// if condition figures out such cases. This combined with
				// the Special case should optimize the no of isc_put_slice
				// we perform.
				//
				if (current_dim + 1 == field->fld_dimensions - 1 &&
				  field->fld_dimensions - count == 2 &&
				   last_element_dim[count + 1]  == range[3])
				{
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, range[0]);
					lower = range[0];
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					range += 2;
					count++;
					stuff(&blr, isc_sdl_do2);
					stuff(&blr, count);
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, range[0]);
					lower = range[0];
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					++current_dim;
					break;
				}
				if (current_dim == count)
				{
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, range[0]);
					lower = range[0];
					stuff(&blr, isc_sdl_long_integer);
					upper = (current_dim == field->fld_dimensions - 1) ?
					 last_element_dim[count] : (last_element_dim[count] - 1);
					if (upper < range[0])
					{
						/**
						see Special Case above
						**/
						dont_write = true;
						break;
					}
					stuff_long(&blr, upper);
				}
				else if (current_dim < count)
				{
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, range[0]);
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, range[1]);
					upper = range[1];
					lower = range[0];
				}
				else if (current_dim > count)
				{
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, last_element_dim[count]);
					stuff(&blr, isc_sdl_long_integer);
					stuff_long(&blr, last_element_dim[count]);
					upper = lower = last_element_dim[count];
				}
				elements_written *= (upper - lower + 1);
#ifdef DEBUG
				ib_fprintf(ib_stderr,"%d..%d ", lower, upper);
#endif
			}
			if (dont_write)
				continue;
#ifdef DEBUG
			ib_fprintf(ib_stderr,"]");
			ib_fprintf(ib_stderr,"\n Elements Written=%d  ",elements_written);
#endif

			stuff(&blr, isc_sdl_element);
			stuff(&blr, 1);
			stuff(&blr, isc_sdl_scalar);
			stuff(&blr, 0);
			stuff(&blr, field->fld_dimensions);

			for (count = 0; count < field->fld_dimensions; count++)
			{
				stuff(&blr, isc_sdl_variable);
				stuff(&blr, count);
			}

			stuff(&blr, isc_sdl_eoc);

#ifdef DEBUG
			if (debug_on)
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

			const USHORT blr_length = blr - blr_buffer;

			if (data_at == 0)
			{
				buffer = BURP_alloc (return_length);
				SLONG lcount;
				if (tdgbl->gbl_sw_transportable)
				{
					if (get_attribute(&attribute, tdgbl) != att_xdr_array)
						// msg 55 Expected XDR record length 
						BURP_error_redirect (NULL, 55, 0, 0);
					else
					{
						lcount = get(tdgbl);
						lcount |= get(tdgbl) << 8;
						lcount |= get(tdgbl) << 16;
						lcount |= get(tdgbl) << 24;
						xdr_buffer.lstr_length = xdr_buffer.lstr_allocated = lcount;
						xdr_buffer.lstr_address = BURP_alloc(lcount);
						xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
						xdr_slice.lstr_address = buffer;
						p = xdr_buffer.lstr_address;
					}
				}
				else
				{
					p = buffer;
					lcount = return_length;
				}

				if (lcount)
					get_block(tdgbl, p, lcount);

				if (tdgbl->gbl_sw_transportable)
					CAN_slice (&xdr_buffer, &xdr_slice, FALSE, blr_length, blr_buffer);
			}

			if (isc_put_slice (status_vector, &DB, &gds_trans,
				(ISC_QUAD*) blob_id, blr_length, reinterpret_cast<const char*>(blr_buffer),
				0,	  // param length for subset of an array handling 
				NULL,  // param for subset of an array handling 
				elements_written * field->fld_length,
				buffer + data_at))
			{
				BURP_print (81, field->fld_name, NULL, NULL, NULL, NULL);
				// msg 81 error accessing blob field %s -- continuing 
				BURP_print_status (status_vector);
#ifdef DEBUG
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
				return;
			}
			data_at += elements_written * field->fld_length;
#ifdef DEBUG
			ib_fprintf(ib_stderr,"next data_at = %d\n", data_at);
#endif
		}
	}
	else
	{ /** This is the regular case we've got the entire array **/
		UCHAR* blr = blr_buffer;

		// build the sdl 

		stuff(&blr, isc_sdl_version1);

		stuff(&blr, isc_sdl_struct);
		stuff(&blr, 1);

		if (field->fld_type == blr_text || field->fld_type == blr_varying)
		{
			if (field->fld_type == blr_text)
				stuff(&blr, blr_text2);
			else
				stuff(&blr, blr_varying2);
			stuff_word(&blr, field->fld_character_set_id);
			stuff_word(&blr, field->fld_length);
		}
		else if (field->fld_type == blr_short || field->fld_type == blr_long ||
			field->fld_type == blr_quad || field->fld_type == blr_int64)
		{
			stuff(&blr, field->fld_type);
			stuff(&blr, field->fld_scale);
		}
		else
			stuff(&blr, field->fld_type);


		stuff(&blr, isc_sdl_relation);
		stuff_string(&blr, relation->rel_name);
		stuff(&blr, isc_sdl_field);
		stuff_string(&blr, field->fld_name);

		// each element spec starts here  

		for (range = fld_ranges, count = 0; range < end_ranges; range += 2, count++)
		{
			stuff(&blr, isc_sdl_do2);
			stuff(&blr, count);
			stuff(&blr, isc_sdl_long_integer);
			stuff_long(&blr, range[0]);
			stuff(&blr, isc_sdl_long_integer);
			stuff_long(&blr, range[1]);
		}

		stuff(&blr, isc_sdl_element);
		stuff(&blr, 1);
		stuff(&blr, isc_sdl_scalar);
		stuff(&blr, 0);
		stuff(&blr, field->fld_dimensions);

		for (count = 0; count < field->fld_dimensions; count++)
		{
			stuff(&blr, isc_sdl_variable);
			stuff(&blr, count);
		}

		stuff(&blr, isc_sdl_eoc);

#ifdef DEBUG
		if (debug_on)
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

		const USHORT blr_length = blr - blr_buffer;

		buffer = BURP_alloc (return_length);
		SLONG lcount;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get_attribute(&attribute, tdgbl) != att_xdr_array)
				BURP_error_redirect (NULL, 55, 0, 0);
				// msg 55 Expected XDR record length 
			else
			{
				xdr_buffer.lstr_allocated = get(tdgbl);
				xdr_buffer.lstr_allocated |= get(tdgbl) << 8;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 16;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 24;
				lcount = xdr_buffer.lstr_length = xdr_buffer.lstr_allocated;
				xdr_buffer.lstr_address = BURP_alloc (xdr_buffer.lstr_allocated);
				xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
				xdr_slice.lstr_address = buffer;
				p = xdr_buffer.lstr_address;
			}
		}
		else
		{
			p = buffer;
			lcount = return_length;
		}

		if (lcount)
			get_block(tdgbl, p, lcount);

		if (tdgbl->gbl_sw_transportable)
			CAN_slice (&xdr_buffer, &xdr_slice, FALSE, blr_length, blr_buffer);


		if (isc_put_slice (status_vector, &DB, &gds_trans,
						   (ISC_QUAD*) blob_id, blr_length,
						   reinterpret_cast<const char*>(blr_buffer),
						   0,	  // param length for subset of an array handling 
						   NULL,  // param for subset of an array handling 
						return_length, buffer))
		{
			BURP_print (81, field->fld_name, NULL, NULL, NULL, NULL);
			// msg 81 error accessing blob field %s -- continuing 
			BURP_print_status (status_vector);
#ifdef DEBUG
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
			return;
		}
	}

	BURP_free (buffer);
	if (tdgbl->gbl_sw_transportable && xdr_buffer.lstr_allocated)
		BURP_free (xdr_buffer.lstr_address);
}

void get_blob (const burp_fld* fields,
			   UCHAR* record_buffer)
{
/**************************************
 *
 *	g e t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiny, new blob.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	// Pick up attributes 

	ULONG segments = 0;
	USHORT field_number = MAX_USHORT;
	USHORT max_segment = 0;

	ATT_TYPE	attribute;
	scan_attr_t	scan_next_attr;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT)get_numeric();
			break;

		case att_blob_max_segment:
			max_segment = (USHORT)get_numeric();
			break;

		case att_blob_number_segments:
			segments = get_numeric();
			break;

		case att_blob_type:
			get_numeric();
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 64);
			// msg 64 blob 
			break;
		}
	}

	// Find the field associated with the blob 
	const burp_fld* field;
	for (field = fields; field; field = field->fld_next) {
		if (field->fld_number == field_number)
			break;
	}

	if (!field) {
		BURP_error_redirect (NULL, 36, 0, 0);
		// msg 36 Can't find field for blob 
	}

	// Create new blob 

	ISC_QUAD* blob_id = (ISC_QUAD*) ((UCHAR*) record_buffer + field->fld_offset);
	isc_handle blob = NULL;
	ISC_STATUS_ARRAY status_vector;

	if (isc_create_blob (status_vector, &DB, &gds_trans, &blob, blob_id))
	{
		BURP_error_redirect (status_vector, 37, 0, 0);
		// msg 37 isc_create_blob failed 
	}

	// Allocate blob buffer if static buffer is too short
	UCHAR static_buffer[1024];
	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc (max_segment);

	// Eat up blob segments 

	for (; segments > 0; --segments )
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
		{
			get_block(tdgbl, buffer, length);
		}
		if (isc_put_segment (status_vector, &blob, length,
			reinterpret_cast<const SCHAR*>(buffer)))
		{
			BURP_error_redirect (status_vector, 38, 0, 0);
		// msg 38 isc_put_segment failed 
		}
	}

	if (isc_close_blob (status_vector,  &blob))
		BURP_error_redirect (status_vector, 23, 0, 0);
		// msg 23 isc_close_blob failed 

	if (buffer != static_buffer)
		BURP_free (buffer);
}


void get_blr_blob (ISC_QUAD	*blob_id,
				   bool		glb_trans)
{
/**************************************
 *
 *	g e t _ b l r _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;
	UCHAR		*buffer, static_buffer[1024], *p;

	TGBL tdgbl = GET_THREAD_DATA;

	ULONG length = (ULONG)get_numeric();

	// Create new blob 

	isc_tr_handle local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	isc_handle blob = NULL;
	if (isc_create_blob (status_vector, &DB, &local_trans, &blob, blob_id))
	{
		BURP_error_redirect (status_vector, 37, 0, 0);
		// msg 37 isc_create_blob failed 
	}

	// Allocate blob buffer if static buffer is too short 

	/* 03 Jun 2003. Nickolay Samofatov. Workaround bug of GCC 3.2.X #11068.
	Original code was:
	if (!length || length + 1 <= (USHORT)(sizeof(static_buffer)) )
	*/
	if (length + 1 <= sizeof(static_buffer) )
		buffer = static_buffer;
	else
		buffer = BURP_alloc (length + 1);

	if (length)
	{
		p = get_block(tdgbl, buffer, length);
		// Make sure it has an eoc 
		if (p[-1] != blr_eoc) {
			p[0] = blr_eoc;
			length++;
		}
	}

	if (isc_put_segment (status_vector, &blob, length,
		reinterpret_cast<const SCHAR*>(buffer)))
	{
		BURP_error_redirect (status_vector, 38, 0, 0);
		// msg 38 isc_put_segment failed 
	}

	if (isc_close_blob (status_vector,  &blob))
		BURP_error_redirect (status_vector, 23, 0, 0);
		// msg 23 isc_close_blob failed 

	if (buffer != static_buffer)
		BURP_free (buffer);
}

bool get_character_set()
{
/**************************************
 *
 *	g e t _ c h a r a c t e r _ s e t s
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined character sets
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_character_sets_req_handle1)
		X IN RDB$CHARACTER_SETS*/
	{
	
        if (!tdgbl->handles_get_character_sets_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_character_sets_req_handle1, (short) sizeof (isc_508), (char *) isc_508);
	if (tdgbl->handles_get_character_sets_req_handle1)
	   {
	   isc_509.isc_511 = isc_blob_null;
#line 2064 "restore.epp"
		/*X.RDB$CHARACTER_SET_NAME.NULL*/
		isc_509.isc_527 = TRUE;
#line 2065 "restore.epp"
		/*X.RDB$FORM_OF_USE.NULL*/
		isc_509.isc_526 = TRUE;
#line 2066 "restore.epp"
		/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
		isc_509.isc_525 = TRUE;
#line 2067 "restore.epp"
		/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
		isc_509.isc_524 = TRUE;
#line 2068 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID.NULL*/
		isc_509.isc_522 = TRUE;
#line 2069 "restore.epp"
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_509.isc_520 = TRUE;
#line 2070 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_509.isc_519 = TRUE;
#line 2071 "restore.epp"
		/*X.RDB$FUNCTION_NAME.NULL*/
		isc_509.isc_518 = TRUE;
#line 2072 "restore.epp"
		/*X.RDB$BYTES_PER_CHARACTER.NULL*/
		isc_509.isc_516 = TRUE;
#line 2073 "restore.epp"

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{

			case att_charset_name:
				/*X.RDB$CHARACTER_SET_NAME.NULL*/
				isc_509.isc_527 = FALSE;
#line 2082 "restore.epp"
				GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
					 isc_509.isc_514);
#line 2083 "restore.epp"
				BURP_verbose (msgVerbose_restore_charset,
							  /*X.RDB$CHARACTER_SET_NAME*/
							  isc_509.isc_514, NULL, NULL, NULL, NULL);
#line 2085 "restore.epp"
				break;

			case att_charset_form:
				/*X.RDB$FORM_OF_USE.NULL*/
				isc_509.isc_526 = FALSE;
#line 2089 "restore.epp"
					GET_TEXT(/*X.RDB$FORM_OF_USE*/
						 isc_509.isc_513);
#line 2090 "restore.epp"
				break;

			case att_charset_numchar:
				/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
				isc_509.isc_525 = FALSE;
#line 2094 "restore.epp"
				/*X.RDB$NUMBER_OF_CHARACTERS*/
				isc_509.isc_515 = (USHORT) get_numeric();
#line 2095 "restore.epp"
				break;

			case att_charset_coll:
				/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
				isc_509.isc_524 = FALSE;
#line 2099 "restore.epp"
				GET_TEXT(/*X.RDB$DEFAULT_COLLATE_NAME*/
					 isc_509.isc_512);
#line 2100 "restore.epp"
				break;

			case att_charset_id:
				/*X.RDB$CHARACTER_SET_ID.NULL*/
				isc_509.isc_522 = FALSE;
#line 2104 "restore.epp"
				/*X.RDB$CHARACTER_SET_ID*/
				isc_509.isc_523 = (USHORT) get_numeric();
#line 2105 "restore.epp"
				break;

			case att_charset_sysflag:
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_509.isc_520 = FALSE;
#line 2109 "restore.epp"
				/*X.RDB$SYSTEM_FLAG*/
				isc_509.isc_521 = (USHORT) get_numeric();
#line 2110 "restore.epp"
				break;

			case att_charset_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_509.isc_519 = FALSE;
#line 2114 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_509.isc_511, false);
#line 2115 "restore.epp"
				break;

			case att_charset_funct:
				/*X.RDB$FUNCTION_NAME.NULL*/
				isc_509.isc_518 = FALSE;
#line 2119 "restore.epp"
				GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					 isc_509.isc_510);
#line 2120 "restore.epp"
				break;

			case att_charset_bytes_char:
				/*X.RDB$BYTES_PER_CHARACTER.NULL*/
				isc_509.isc_516 = FALSE;
#line 2124 "restore.epp"
				/*X.RDB$BYTES_PER_CHARACTER*/
				isc_509.isc_517 = (USHORT) get_numeric();
#line 2125 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, msgErr_restore_charset);
				/* RDB$CHARSETS */
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_character_sets_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 164, &isc_509, (short) 0);
	   };
#line 2134 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2135 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 2137 "restore.epp"

	return true;
}

bool get_chk_constraint()
{
/**************************************
 *
 *	g e t _ c h k _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for check constraints.
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_chk_constraint_req_handle1)
		X IN RDB$CHECK_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_chk_constraint_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_chk_constraint_req_handle1, (short) sizeof (isc_502), (char *) isc_502);
	if (tdgbl->handles_get_chk_constraint_req_handle1)
	   {
#line 2160 "restore.epp"
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_503.isc_507 = TRUE;
#line 2161 "restore.epp"
		/*X.RDB$TRIGGER_NAME.NULL*/
		isc_503.isc_506 = TRUE;
#line 2162 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_chk_constraint_name:
				/*X.RDB$CONSTRAINT_NAME.NULL*/
				isc_503.isc_507 = FALSE;
#line 2169 "restore.epp"
				GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
					 isc_503.isc_505);
#line 2170 "restore.epp"
				break;

			case att_chk_trigger_name:
				/*X.RDB$TRIGGER_NAME.NULL*/
				isc_503.isc_506 = FALSE;
#line 2174 "restore.epp"
				GET_TEXT(/*X.RDB$TRIGGER_NAME*/
					 isc_503.isc_504);
#line 2175 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 208);
				// msg 208 relation constraint 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_chk_constraint_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 68, &isc_503, (short) 0);
	   };
#line 2184 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2185 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 2187 "restore.epp"

	return true;
}

bool get_collation()
{
/**************************************
 *
 *	g e t _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined collations
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
		X IN RDB$COLLATIONS*/
	{
	
        if (!tdgbl->handles_get_collation_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof (isc_486), (char *) isc_486);
	if (tdgbl->handles_get_collation_req_handle1)
	   {
	   isc_487.isc_489 = isc_blob_null;
#line 2210 "restore.epp"
		/*X.RDB$COLLATION_NAME.NULL*/
		isc_487.isc_501 = TRUE;
#line 2211 "restore.epp"
		/*X.RDB$COLLATION_ID.NULL*/
		isc_487.isc_499 = TRUE;
#line 2212 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID.NULL*/
		isc_487.isc_497 = TRUE;
#line 2213 "restore.epp"
		/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
		isc_487.isc_495 = TRUE;
#line 2214 "restore.epp"
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_487.isc_493 = TRUE;
#line 2215 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_487.isc_492 = TRUE;
#line 2216 "restore.epp"
		/*X.RDB$FUNCTION_NAME.NULL*/
		isc_487.isc_491 = TRUE;
#line 2217 "restore.epp"

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{

			case att_coll_name:
				/*X.RDB$COLLATION_NAME.NULL*/
				isc_487.isc_501 = FALSE;
#line 2226 "restore.epp"
				GET_TEXT(/*X.RDB$COLLATION_NAME*/
					 isc_487.isc_490);
#line 2227 "restore.epp"
				BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
									   isc_487.isc_490,
#line 2228 "restore.epp"
							 NULL, NULL, NULL, NULL);
				break;

			case att_coll_id:
				/*X.RDB$COLLATION_ID.NULL*/
				isc_487.isc_499 = FALSE;
#line 2233 "restore.epp"
				/*X.RDB$COLLATION_ID*/
				isc_487.isc_500 = (USHORT) get_numeric();
#line 2234 "restore.epp"
				break;

			case att_coll_cs_id:
				/*X.RDB$CHARACTER_SET_ID.NULL*/
				isc_487.isc_497 = FALSE;
#line 2238 "restore.epp"
				/*X.RDB$CHARACTER_SET_ID*/
				isc_487.isc_498 = (USHORT) get_numeric();
#line 2239 "restore.epp"
				break;

			case att_coll_attr:
				/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
				isc_487.isc_495 = FALSE;
#line 2243 "restore.epp"
				/*X.RDB$COLLATION_ATTRIBUTES*/
				isc_487.isc_496 = (USHORT) get_numeric();
#line 2244 "restore.epp"
				break;

			case att_coll_subtype:	// No longer used: 93-11-15 DBS 
				// still present to handle V4 R&D gbak files
				get_numeric();
				break;

			case att_coll_sysflag:
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_487.isc_493 = FALSE;
#line 2253 "restore.epp"
				/*X.RDB$SYSTEM_FLAG*/
				isc_487.isc_494 = (USHORT) get_numeric();
#line 2254 "restore.epp"
				break;

			case att_coll_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_487.isc_492 = FALSE;
#line 2258 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_487.isc_489, false);
#line 2259 "restore.epp"
				break;

			case att_coll_funct:
				/*X.RDB$FUNCTION_NAME.NULL*/
				isc_487.isc_491 = FALSE;
#line 2263 "restore.epp"
				GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					 isc_487.isc_488);
#line 2264 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, msgErr_restore_collation);
				/* Bad RDB$COLLATION */
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_collation_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 94, &isc_487, (short) 0);
	   };
#line 2273 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2274 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 2276 "restore.epp"

	return true;
}

rec_type get_data (BURP_REL	relation)
{
/**************************************
 *
 *	g e t _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Write data records for a relation.
 *
 **************************************/
	isc_req_handle  req_handle = NULL;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];

#line 2294 "restore.epp"

	TGBL tdgbl = GET_THREAD_DATA;

	// If we're only doing meta-data, ignore data records 

	if (tdgbl->gbl_sw_meta)
		return ignore_data (relation);

	// Start by counting the interesting fields 

	RCRD_OFFSET offset = 0;
	ULONG length = 0;
	USHORT count = 0;

	burp_fld* field;
	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (!(field->fld_flags & FLD_computed))
		{
			count++;
			length += field->fld_name_length;
		}
	}

	if (tdgbl->RESTORE_format >= 2)
		count += count;

	// Time to generate blr to store data.  Whoppee. 

	UCHAR* const blr_buffer = (UCHAR*) BURP_alloc (200 + length + count * 18);
	UCHAR* blr = blr_buffer;

	stuff(&blr, blr_version4);
	stuff(&blr, blr_begin);
	stuff(&blr, blr_message);
	stuff(&blr, 0);				// Message number 
	stuff_word(&blr, count);	// Number of fields, counting eof 

	// Let's reset count.
	count = 0;

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		// arrays are of various fld_types but are really blobs 

		SSHORT dtype = field->fld_type;
		length = field->fld_length;
		SSHORT alignment = 4;

		if (field->fld_flags & FLD_array)
			dtype = blr_blob;

		if (dtype <= DTYPE_BLR_MAX)
		{
			USHORT l = gds_cvt_blr_dtype[dtype];
			alignment = type_alignments[l];
			if (l = type_lengths[l])
				length = l;
		}

		switch (dtype)
		{
		case blr_text:
		case blr_varying:
			if (dtype == blr_text)
				stuff(&blr, blr_text2);
			else
				stuff(&blr, blr_varying2);
			stuff_word(&blr, field->fld_character_set_id);
			stuff_word(&blr, field->fld_length);
			if (dtype == blr_varying)
				length += sizeof(USHORT);
			break;

		case blr_short:
		case blr_long:
		case blr_quad:
		case blr_int64:
			stuff(&blr, field->fld_type);
			stuff(&blr, field->fld_scale);
			break;

		case blr_float:
		case blr_double:
		case blr_timestamp:
		case blr_sql_time:
		case blr_sql_date:
			stuff(&blr, field->fld_type);
			break;

		case blr_blob:
			alignment = type_alignments[dtype_blob];
			length = type_lengths[dtype_blob];
			stuff(&blr, blr_quad);
			stuff(&blr, 0);
			break;

		default:
			BURP_error (26, true, isc_arg_number, (void*) (SLONG) field->fld_type,
					0, NULL, 0, NULL, 0, NULL, 0, NULL);
			// msg 26 datatype %ld not understood 
			break;
		}
		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_offset = offset;
		field->fld_parameter = count++;
		offset += length;
	}

	// If this is format version 2, build fields for null flags 

	if (tdgbl->RESTORE_format >= 2)
		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			stuff(&blr, blr_short);
			stuff(&blr, 0);
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			field->fld_missing_parameter = count++;
			offset += sizeof(SSHORT);
		}

	length = offset;

	// Build STORE statement 

	stuff(&blr, blr_receive);
	stuff(&blr, 0);
	stuff(&blr, blr_store);
	stuff(&blr, blr_relation);
	stuff_string(&blr, relation->rel_name);
	stuff(&blr, 0);			// context variable 
	stuff(&blr, blr_begin);

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		stuff(&blr, blr_assignment);
		if (tdgbl->RESTORE_format >= 2)
		{
			stuff(&blr, blr_parameter2);
			stuff(&blr, 0);
			stuff_word(&blr, field->fld_parameter);
			stuff_word(&blr, field->fld_missing_parameter);
		}
		else
		{
			stuff(&blr, blr_parameter);
			stuff(&blr, 0);
			stuff_word(&blr, field->fld_parameter);
		}
		stuff(&blr, blr_field);
		stuff(&blr, 0);
		stuff_string(&blr, field->fld_name);
	}

	stuff(&blr, blr_end);
	stuff(&blr, blr_end);
	stuff(&blr, blr_eoc);

	// Compile request 

#ifdef DEBUG
	isc_print_blr (reinterpret_cast<const char*>(blr_buffer), NULL, NULL, 0);
#endif

	isc_handle request = NULL;
	ISC_STATUS_ARRAY status_vector;
	USHORT blr_length = blr - blr_buffer;

	if (isc_compile_request (status_vector,  &DB, &request,
							 blr_length,  reinterpret_cast<const char*>(blr_buffer)))
	{
		isc_print_blr(reinterpret_cast<const char*>(blr_buffer), NULL, NULL, 0);
		if (!tdgbl->gbl_sw_incremental)
			BURP_error_redirect (status_vector, 27, 0, 0);
			// msg 27 isc_compile_request failed 
		else
		{
			BURP_print_status (status_vector);
			BURP_free (blr_buffer);
			return ignore_data (relation);
		}
	}

	BURP_free (blr_buffer);
	SSHORT* buffer = NULL;

	BURP_verbose (124, relation->rel_name, NULL, NULL, NULL, NULL);
	// msg 124  restoring data for relation %s 
	
	LSTRING data;
	data.lstr_allocated = 0;
	data.lstr_address = NULL;
	ULONG old_length = 0;

	ULONG records = 0;
	rec_type record;

	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39, 0, 0);
			// msg 39 expected record length 
		USHORT l = (USHORT) get_numeric();
		if (!tdgbl->gbl_sw_transportable && l != length)
		{
			if (!old_length)
				old_length = recompute_length (relation);
			if (l != old_length)
			{
				BURP_error(40, true, isc_arg_number, (void*)length,
							 isc_arg_number, (void*) (ULONG) l,
							 0, NULL, 0, NULL, 0, NULL);
				// msg 40 wrong length record, expected %ld encountered %ld 
			}
		}
		if (!buffer) {
			buffer = (SSHORT *) BURP_alloc (MAX (length, l));
		}

		UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55, 0, 0);
				// msg 55 Expected XDR record length 
			else
			{
				data.lstr_length = l = (USHORT) get_numeric();
				if (l > data.lstr_allocated)
				{
					data.lstr_allocated = l;
					if (data.lstr_address)
						BURP_free (data.lstr_address);
					data.lstr_address = (UCHAR *) BURP_alloc (data.lstr_allocated);
				}
				p = data.lstr_address;
			}
		}
		else
			p = reinterpret_cast<UCHAR*>(buffer);
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41, 0, 0);
			// msg 41 expected data attribute 

		if (tdgbl->gbl_sw_compress)
			decompress (p, l);
		else
		{
			get_block(tdgbl, p, l);
		}

		if (old_length)
			realign ((UCHAR *)buffer, relation);

		if (tdgbl->gbl_sw_transportable)
			CAN_encode_decode (relation, &data, (UCHAR *)buffer, FALSE);

		records++;

		if ((records % RESTORE_VERBOSE_INTERVAL) == 0)
			BURP_verbose(107, (void*) (SLONG) records, NULL, NULL, NULL, NULL);

		for (field = relation->rel_fields; field; field = field->fld_next)
			if ((field->fld_type == blr_blob) || (field->fld_flags & FLD_array))
			{
				SLONG* blob_id = (SLONG*) ((SCHAR*) buffer + field->fld_offset);
				blob_id[0] = blob_id[1] = 0;
			}

		get_record(&record, tdgbl);
		while (record == rec_blob || record == rec_array)
		{
			if (record == rec_blob)
				get_blob (relation->rel_fields, (UCHAR *) buffer);
			else if (record == rec_array)
				get_array (relation, (UCHAR *) buffer);
			get_record(&record, tdgbl);
		}


		if (isc_start_and_send (status_vector, &request, &gds_trans, 0,
								(USHORT) length, buffer, 0))
		{
			if (status_vector[1] == isc_not_valid)
			{
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (138, relation->rel_name, NULL, NULL, NULL, NULL);
					// msg 138 validation error on field in relation %s 
					BURP_print_status (status_vector);
				}
				else
					BURP_error_redirect (status_vector, 47, 0, 0);
					// msg 47 warning -- record could not be restored 
			}
			else {
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (114, relation->rel_name, NULL, NULL, NULL, NULL);
					// msg 114 restore failed for record in relation %s 
					BURP_print_status (status_vector);
				}
				else
					BURP_error_redirect (status_vector, 48, 0, 0);
					// msg 48 isc_send failed 
			}
		}
		if (record != rec_data)
			break;
	} // while (true)

	BURP_free (buffer);
	if (data.lstr_address)
		BURP_free (data.lstr_address);

	isc_release_request(status_vector, &request);
	if (tdgbl->gbl_sw_incremental)
	{
		BURP_verbose (72, relation->rel_name, NULL, NULL, NULL, NULL);
		// msg 72  committing data for relation %s 
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 2623 "restore.epp"
		// existing ON_ERROR continues past error, beck 
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 2625 "restore.epp"

			/* Fix for bug_no 8055:
			   don't throw away the database just because an index
			   could not be made */
			ISC_STATUS error_code;
			while (error_code = tdgbl->status_vector[1])
			{
				switch (error_code)
				{
					case isc_sort_mem_err:
					case isc_no_dup:
						strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
						BURP_print_status(tdgbl->status_vector);
						/*FOR (REQUEST_HANDLE req_handle)
						 IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
						{
                                                if (!req_handle)
                                                   isc_compile_request ( NULL, (isc_handle*) &DB, (isc_handle*) &req_handle, (short) sizeof (isc_476), (char *) isc_476);
						isc_vtov ((char*)index_name, (char*)isc_477.isc_478, 32);
                                                isc_start_and_send ( NULL, (isc_handle*) &req_handle, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_477, (short) 0);
						while (1)
						   {
                                                   isc_receive ( NULL, (isc_handle*) &req_handle, (short) 1, (short) 4, &isc_479, (short) 0);
						   if (!isc_479.isc_480) break;
#line 2640 "restore.epp"
							/*MODIFY IDX USING*/
							{ /*IDX.RDB$INDEX_INACTIVE*/
 isc_479.isc_481 = TRUE;
#line 2641 "restore.epp"
							BURP_print(240, index_name, NULL, NULL, NULL, NULL);
							/* msg 240 Index \"%s\" failed to activate because: */
							if ( error_code == isc_no_dup )
							{
								BURP_print(241, NULL, NULL, NULL, NULL, NULL);
								// msg 241 The unique index has duplicate values or NULLs 
								BURP_print(242, NULL, NULL, NULL, NULL, NULL);
								// msg 242 Delete or Update duplicate values or NULLs, and activate index with 
							}
							else
							{
								BURP_print(244, NULL, NULL, NULL, NULL, NULL);
								// msg 244 Not enough disk space to create the sort file for an index 
								BURP_print(245, NULL, NULL, NULL, NULL, NULL);
								// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with 
							}
							BURP_print(243, index_name, NULL, NULL, NULL, NULL);
							/* msg 243 ALTER INDEX \"%s\" ACTIVE; */
							/*END_MODIFY;*/
							isc_482.isc_483 = isc_479.isc_481;
                                                        isc_send ( NULL, (isc_handle*) &req_handle, (short) 2, (short) 2, &isc_482, (short) 0);
							}
#line 2660 "restore.epp"
						/*END_FOR;*/
                                                   isc_send ( NULL, (isc_handle*) &req_handle, (short) 3, (short) 2, &isc_484, (short) 0);
						   }
						}
#line 2661 "restore.epp"
						// don't bring the database on-line 
						flag_on_line = false;
						// commit one more time 
						/*COMMIT*/
						{
						isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 2665 "restore.epp"
						/*ON_ERROR*/
						if (isc_status [1])
						   {
#line 2666 "restore.epp"
							continue;
						/*END_ERROR*/
						   }
						}
#line 2668 "restore.epp"
						break;
					default:
						BURP_print (69, relation->rel_name, NULL, NULL, NULL, NULL);
						// msg 69 commit failed on relation %s 
						BURP_print_status (tdgbl->status_vector);
						/*ROLLBACK;*/
						{
						isc_rollback_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 2674 "restore.epp"
						/*ON_ERROR*/
						if (isc_status [1])
						   {
#line 2675 "restore.epp"
							general_on_error ();
						/*END_ERROR;*/
						   }
						}
#line 2677 "restore.epp"
						break;
				} // end of switch 
			} // end of while 
		/*END_ERROR;*/
		   }
		}
#line 2681 "restore.epp"

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_8);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 2683 "restore.epp"
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_9);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 2685 "restore.epp"
	}
	BURP_verbose (107, (void*) (SLONG) records, NULL, NULL, NULL, NULL);
	// msg 107 %ld records restored 

	return record;
}

bool get_exception(void)
{
/**************************************
 *
 *	g e t _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a exception.
 *
 **************************************/
	ATT_TYPE	attribute;
	TEXT		temp[GDS_NAME_LEN];
	ULONG		l;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_exception_req_handle1)
		X IN RDB$EXCEPTIONS*/
	{
	
        if (!tdgbl->handles_get_exception_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_exception_req_handle1, (short) sizeof (isc_469), (char *) isc_469);
	if (tdgbl->handles_get_exception_req_handle1)
	   {
	   isc_470.isc_472 = isc_blob_null;
#line 2713 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_470.isc_474 = TRUE;
#line 2714 "restore.epp"
		/*X.RDB$MESSAGE.NULL*/
		isc_470.isc_473 = TRUE;
#line 2715 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_exception_name:
				l = GET_TEXT(/*X.RDB$EXCEPTION_NAME*/
					     isc_470.isc_471);
#line 2722 "restore.epp"
				MISC_terminate (/*X.RDB$EXCEPTION_NAME*/
						isc_470.isc_471, temp, l, sizeof(temp));
#line 2723 "restore.epp"
				BURP_verbose (199, temp, NULL, NULL, NULL, NULL);
				// msg 199 restoring exception %s 
				break;

			case att_exception_description:
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_470.isc_472, 0, false);
#line 2729 "restore.epp"
				/*X.RDB$DESCRIPTION.NULL*/
				isc_470.isc_474 = FALSE;
#line 2730 "restore.epp"
				break;

			case att_exception_description2:
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_470.isc_472, false);
#line 2734 "restore.epp"
				/*X.RDB$DESCRIPTION.NULL*/
				isc_470.isc_474 = FALSE;
#line 2735 "restore.epp"
				break;

			case att_exception_msg:
				GET_TEXT(/*X.RDB$MESSAGE*/
					 isc_470.isc_475);
#line 2739 "restore.epp"
				/*X.RDB$MESSAGE.NULL*/
				isc_470.isc_473 = FALSE;
#line 2740 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 89);
				// msg 89 function 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_exception_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 123, &isc_470, (short) 0);
	   };
#line 2749 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2750 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 2752 "restore.epp"

	return true;
}


BURP_FLD get_field (BURP_REL	relation)
{
/**************************************
 *
 *	g e t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a local field.
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	// If it is a view and there is a global transaction then use it
	bool global_tr = false;
	isc_tr_handle local_trans;
	if ((relation->rel_flags & REL_view) && (tdgbl->global_trans))
	{
		local_trans = tdgbl->global_trans;
		global_tr = true;
	}
	else
		local_trans = gds_trans;

	BURP_FLD field = (BURP_FLD) BURP_alloc_zero (sizeof(burp_fld));

	/*STORE (TRANSACTION_HANDLE local_trans
		   REQUEST_HANDLE tdgbl->handles_get_field_req_handle1)
		X IN RDB$RELATION_FIELDS*/
	{
	
        if (!tdgbl->handles_get_field_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_field_req_handle1, (short) sizeof (isc_434), (char *) isc_434);
	if (tdgbl->handles_get_field_req_handle1)
	   {
	   isc_435.isc_438 = isc_blob_null;
	   isc_435.isc_439 = isc_blob_null;
	   isc_435.isc_441 = isc_blob_null;
	   isc_435.isc_442 = isc_blob_null;
#line 2790 "restore.epp"
		strcpy (/*X.RDB$RELATION_NAME*/
			isc_435.isc_446, relation->rel_name);
#line 2791 "restore.epp"
		/*X.RDB$FIELD_POSITION*/
		isc_435.isc_468 = 0;
#line 2792 "restore.epp"
		memset (/*X.RDB$QUERY_NAME*/
			isc_435.isc_445, ' ', sizeof(/*X.RDB$QUERY_NAME*/
	      isc_435.isc_445));
#line 2793 "restore.epp"
		/*X.RDB$VIEW_CONTEXT.NULL*/
		isc_435.isc_466 = TRUE;
#line 2794 "restore.epp"
		/*X.RDB$BASE_FIELD.NULL*/
		isc_435.isc_465 = TRUE;
#line 2795 "restore.epp"
		/*X.RDB$SECURITY_CLASS.NULL*/
		isc_435.isc_464 = TRUE;
#line 2796 "restore.epp"
		/*X.RDB$QUERY_NAME.NULL*/
		isc_435.isc_463 = TRUE;
#line 2797 "restore.epp"
		/*X.RDB$QUERY_HEADER.NULL*/
		isc_435.isc_462 = TRUE;
#line 2798 "restore.epp"
		/*X.RDB$EDIT_STRING.NULL*/
		isc_435.isc_460 = TRUE;
#line 2799 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_435.isc_459 = TRUE;
#line 2800 "restore.epp"
		/*X.RDB$FIELD_POSITION.NULL*/
		isc_435.isc_458 = TRUE;
#line 2801 "restore.epp"
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_435.isc_456 = TRUE;
#line 2802 "restore.epp"
		/*X.RDB$COMPLEX_NAME.NULL*/
		isc_435.isc_455 = TRUE;
#line 2803 "restore.epp"
		/*X.RDB$UPDATE_FLAG.NULL*/
		isc_435.isc_453 = TRUE;
#line 2804 "restore.epp"
		/*X.RDB$DEFAULT_SOURCE.NULL*/
		isc_435.isc_452 = TRUE;
#line 2805 "restore.epp"
		/*X.RDB$DEFAULT_VALUE.NULL*/
		isc_435.isc_451 = TRUE;
#line 2806 "restore.epp"
		/*X.RDB$NULL_FLAG.NULL*/
		isc_435.isc_449 = TRUE;
#line 2807 "restore.epp"
		/*X.RDB$COLLATION_ID.NULL*/
		isc_435.isc_447 = TRUE;
#line 2808 "restore.epp"
		skip_init(&scan_next_attr);
		while (get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (skip_scan(&scan_next_attr), attribute)
			{
			case att_field_name:
				field->fld_name_length = GET_TEXT(field->fld_name);
				BURP_verbose (115, field->fld_name, NULL, NULL, NULL, NULL);
				// msg 115 restoring field %s
				strcpy (/*X.RDB$FIELD_NAME*/
					isc_435.isc_437, field->fld_name);
#line 2818 "restore.epp"
				break;

			case att_field_source:
				GET_TEXT(/*X.RDB$FIELD_SOURCE*/
					 isc_435.isc_436);
#line 2822 "restore.epp"
				break;

			case att_field_security_class:
				GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					 isc_435.isc_443);
#line 2826 "restore.epp"
				/*X.RDB$SECURITY_CLASS.NULL*/
				isc_435.isc_464 = FALSE;
#line 2827 "restore.epp"
				break;

			case att_field_query_name:
				GET_TEXT(/*X.RDB$QUERY_NAME*/
					 isc_435.isc_445);
#line 2831 "restore.epp"
				/*X.RDB$QUERY_NAME.NULL*/
				isc_435.isc_463 = FALSE;
#line 2832 "restore.epp"
				break;

			case att_field_query_header:
				/*X.RDB$QUERY_HEADER.NULL*/
				isc_435.isc_462 = FALSE;
#line 2836 "restore.epp"
				get_source_blob (&/*X.RDB$QUERY_HEADER*/
						  isc_435.isc_442, global_tr);
#line 2837 "restore.epp"
				break;

			case att_field_edit_string:
				GET_TEXT(/*X.RDB$EDIT_STRING*/
					 isc_435.isc_461);
#line 2841 "restore.epp"
				/*X.RDB$EDIT_STRING.NULL*/
				isc_435.isc_460 = FALSE;
#line 2842 "restore.epp"
				break;

			case att_field_position:
				/*X.RDB$FIELD_POSITION.NULL*/
				isc_435.isc_458 = FALSE;
#line 2846 "restore.epp"
				/*X.RDB$FIELD_POSITION*/
				isc_435.isc_468 = (USHORT) get_numeric();
#line 2847 "restore.epp"
				break;

			case att_field_number:
				field->fld_number = (USHORT) get_numeric();
				break;

			case att_field_type:
				field->fld_type = (USHORT) get_numeric();
				break;

			case att_field_length:
				field->fld_length = (USHORT) get_numeric();
				break;

			case att_field_scale:
				field->fld_scale = (USHORT) get_numeric();
				break;

			case att_field_sub_type:
				field->fld_sub_type = (USHORT) get_numeric();
				break;

			case att_field_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_435.isc_457 = (USHORT) get_numeric();
#line 2871 "restore.epp"
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_435.isc_456 = FALSE;
#line 2872 "restore.epp"
				break;

			case att_view_context:
				/*X.RDB$VIEW_CONTEXT*/
				isc_435.isc_467 = (USHORT) get_numeric();
#line 2876 "restore.epp"
				/*X.RDB$VIEW_CONTEXT.NULL*/
				isc_435.isc_466 = FALSE;
#line 2877 "restore.epp"
				break;

			case att_field_computed_flag:
				if (get_numeric())
					field->fld_flags |= FLD_computed;
				break;

			case att_base_field:
				GET_TEXT(/*X.RDB$BASE_FIELD*/
					 isc_435.isc_444);
#line 2886 "restore.epp"
				/*X.RDB$BASE_FIELD.NULL*/
				isc_435.isc_465 = FALSE;
#line 2887 "restore.epp"
				break;

			case att_field_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_435.isc_459 = FALSE;
#line 2891 "restore.epp"
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_435.isc_441, 1, global_tr);
#line 2892 "restore.epp"
				break;

			case att_field_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_435.isc_459 = FALSE;
#line 2896 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_435.isc_441, global_tr);
#line 2897 "restore.epp"
				break;

			case att_field_complex_name:
				GET_TEXT(/*X.RDB$COMPLEX_NAME*/
					 isc_435.isc_440);
#line 2901 "restore.epp"
				/*X.RDB$COMPLEX_NAME.NULL*/
				isc_435.isc_455 = FALSE;
#line 2902 "restore.epp"
				break;

			case att_field_dimensions:
				{
					field->fld_dimensions = (USHORT) get_numeric();
					field->fld_flags |= FLD_array;
					USHORT n = field->fld_dimensions;
					for (SLONG *rp = field->fld_ranges; n; rp += 2, n--)
					{
						if (get_attribute(&attribute, tdgbl) != att_field_range_low)
							bad_attribute (scan_next_attr, attribute, 58);
						// msg 58 array
						else
							*rp = get_numeric();
						if (get_attribute(&attribute, tdgbl) != att_field_range_high)
							bad_attribute (scan_next_attr, attribute, 58);
							// msg 58 array
						else
							*(rp + 1) = get_numeric();
					}
				}
				break;

			case att_field_update_flag:
				/*X.RDB$UPDATE_FLAG.NULL*/
				isc_435.isc_453 = FALSE;
#line 2927 "restore.epp"
				/*X.RDB$UPDATE_FLAG*/
				isc_435.isc_454 = (USHORT) get_numeric();
#line 2928 "restore.epp"
				break;

			case att_field_character_length:
				field->fld_character_length = (USHORT) get_numeric();
				break;

			case att_field_default_source:
				/*X.RDB$DEFAULT_SOURCE.NULL*/
				isc_435.isc_452 = FALSE;
#line 2936 "restore.epp"
				get_source_blob (&/*X.RDB$DEFAULT_SOURCE*/
						  isc_435.isc_439, global_tr);
#line 2937 "restore.epp"
				break;

			case att_field_default_value:
				/*X.RDB$DEFAULT_VALUE.NULL*/
				isc_435.isc_451 = FALSE;
#line 2941 "restore.epp"
				get_blr_blob (&/*X.RDB$DEFAULT_VALUE*/
					       isc_435.isc_438, global_tr);
#line 2942 "restore.epp"
				break;

			case att_field_null_flag:
				/*X.RDB$NULL_FLAG.NULL*/
				isc_435.isc_449 = FALSE;
#line 2946 "restore.epp"
				/*X.RDB$NULL_FLAG*/
				isc_435.isc_450 = (USHORT) get_numeric();
#line 2947 "restore.epp"
				break;

			case att_field_character_set:
				field->fld_character_set_id = (USHORT) get_numeric();
				break;

			case att_field_collation_id:
				field->fld_collation_id = (USHORT) get_numeric();
				/*X.RDB$COLLATION_ID.NULL*/
				isc_435.isc_447 = FALSE;
#line 2956 "restore.epp"
				/*X.RDB$COLLATION_ID*/
				isc_435.isc_448 = field->fld_collation_id;
#line 2957 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 84);
				// msg 84 field
				break;
			}
		}

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_field_req_handle1, (isc_handle*) &local_trans, (short) 0, (short) 424, &isc_435, (short) 0);
	   };
#line 2967 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2968 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 2970 "restore.epp"

	return field;
}

bool get_field_dimensions()
{
/**************************************
 *
 *	g e t _ f i e l d _ d i m e n s i o n s
 *
 **************************************
 *
 * Functional description
 *	Get array field dimensions in rdb$field_dimensions.
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_field_dimensions_req_handle1)
		X IN RDB$FIELD_DIMENSIONS*/
	{
	
        if (!tdgbl->handles_get_field_dimensions_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_field_dimensions_req_handle1, (short) sizeof (isc_428), (char *) isc_428);
	if (tdgbl->handles_get_field_dimensions_req_handle1)
	   {
#line 2993 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_429.isc_430);
#line 3000 "restore.epp"
				break;

			case att_field_dimensions:
				/*X.RDB$DIMENSION*/
				isc_429.isc_433 = (USHORT) get_numeric();
#line 3004 "restore.epp"
				break;

			case att_field_range_low:
				/*X.RDB$LOWER_BOUND*/
				isc_429.isc_432 = get_numeric();
#line 3008 "restore.epp"
				break;

			case att_field_range_high:
				/*X.RDB$UPPER_BOUND*/
				isc_429.isc_431 = get_numeric();
#line 3012 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 58);
				// msg 58 array 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_field_dimensions_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 42, &isc_429, (short) 0);
	   };
#line 3021 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3022 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 3024 "restore.epp"

	return true;
}

bool get_files()
{
/**************************************
 *
 *	g e t _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	Get any files that were stored; let
 *	somebody else worry about what to do with them.
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_files_req_handle1)
		X IN RDB$FILES*/
	{
	
        if (!tdgbl->handles_get_files_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_files_req_handle1, (short) sizeof (isc_420), (char *) isc_420);
	if (tdgbl->handles_get_files_req_handle1)
	   {
#line 3048 "restore.epp"
		/*X.RDB$FILE_FLAGS*/
		isc_421.isc_427 = 0;
#line 3049 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_file_filename:
				GET_TEXT(/*X.RDB$FILE_NAME*/
					 isc_421.isc_426);
#line 3056 "restore.epp"
				BURP_verbose (116,
					/*X.RDB$FILE_NAME*/
					isc_421.isc_426, NULL, NULL, NULL, NULL);
#line 3058 "restore.epp"
				// msg 116 restoring file %s 
				break;

			case att_file_sequence:
				/*X.RDB$FILE_SEQUENCE*/
				isc_421.isc_425 = (USHORT) get_numeric();
#line 3063 "restore.epp"
				break;

			case att_file_start:
				/*X.RDB$FILE_START*/
				isc_421.isc_423 = get_numeric();
#line 3067 "restore.epp"
				break;

			case att_file_length:
				/*X.RDB$FILE_LENGTH*/
				isc_421.isc_422 = get_numeric();
#line 3071 "restore.epp"
				break;

			case att_file_flags:
				/*X.RDB$FILE_FLAGS*/
				isc_421.isc_427 |= get_numeric();
#line 3075 "restore.epp"
				break;

			case att_shadow_number:
				/*X.RDB$SHADOW_NUMBER*/
				isc_421.isc_424 = (USHORT) get_numeric();
#line 3079 "restore.epp"
				if (tdgbl->gbl_sw_kill && /*X.RDB$SHADOW_NUMBER*/
							  isc_421.isc_424)
#line 3080 "restore.epp"
					/*X.RDB$FILE_FLAGS*/
					isc_421.isc_427 |= FILE_inactive;
#line 3081 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 85);
				// msg 85 file 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_files_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 268, &isc_421, (short) 0);
	   };
#line 3090 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3091 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 3093 "restore.epp"

	return true;
}

bool get_filter()
{
/**************************************
 *
 *	g e t _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$filters.
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_filter_req_handle1)
		X IN RDB$FILTERS*/
	{
	
        if (!tdgbl->handles_get_filter_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_filter_req_handle1, (short) sizeof (isc_411), (char *) isc_411);
	if (tdgbl->handles_get_filter_req_handle1)
	   {
	   isc_412.isc_415 = isc_blob_null;
#line 3116 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_412.isc_419 = TRUE;
#line 3117 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_filter_name:
				GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					 isc_412.isc_414);
#line 3124 "restore.epp"
				BURP_verbose (117, /*X.RDB$FUNCTION_NAME*/
						   isc_412.isc_414, NULL, NULL, NULL, NULL);
#line 3125 "restore.epp"
				// msg 117 restoring filter %s 
				break;

			case att_filter_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_412.isc_419 = FALSE;
#line 3130 "restore.epp"
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_412.isc_415, 1, false);
#line 3131 "restore.epp"
				break;

			case att_filter_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_412.isc_419 = FALSE;
#line 3135 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_412.isc_415, false);
#line 3136 "restore.epp"
				break;

			case att_filter_module_name:
				GET_TEXT(/*X.RDB$MODULE_NAME*/
					 isc_412.isc_418);
#line 3140 "restore.epp"
				break;

			case att_filter_entrypoint:
				GET_TEXT(/*X.RDB$ENTRYPOINT*/
					 isc_412.isc_413);
#line 3144 "restore.epp"
				break;

			case att_filter_input_sub_type:
				/*X.RDB$INPUT_SUB_TYPE*/
				isc_412.isc_417 = (USHORT) get_numeric();
#line 3148 "restore.epp"
				break;

			case att_filter_output_sub_type:
				/*X.RDB$OUTPUT_SUB_TYPE*/
				isc_412.isc_416 = (USHORT) get_numeric();
#line 3152 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 87);
				// msg 87  filter 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_filter_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 332, &isc_412, (short) 0);
	   };
#line 3161 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3162 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 3164 "restore.epp"

	return true;
}

bool get_function()
{
/**************************************
 *
 *	g e t _ f u n c t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a function.
 *
 **************************************/
	ATT_TYPE	attribute;
	GDS_NAME	function_name;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t	scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_req_handle1)
		X IN RDB$FUNCTIONS*/
	{
	
        if (!tdgbl->handles_get_function_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_function_req_handle1, (short) sizeof (isc_402), (char *) isc_402);
	if (tdgbl->handles_get_function_req_handle1)
	   {
	   isc_403.isc_406 = isc_blob_null;
#line 3190 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_function_name:
				l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					     isc_403.isc_407);
#line 3197 "restore.epp"
				MISC_terminate (/*X.RDB$FUNCTION_NAME*/
						isc_403.isc_407, temp, l, sizeof(temp));
#line 3198 "restore.epp"
				BURP_verbose (118, temp, NULL, NULL, NULL, NULL);
				// msg 118 restoring function %s 
				break;

			case att_function_description:
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_403.isc_406, 0, false);
#line 3204 "restore.epp"
				break;

			case att_function_description2:
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_403.isc_406, false);
#line 3208 "restore.epp"
				break;

			case att_function_module_name:
				GET_TEXT(/*X.RDB$MODULE_NAME*/
					 isc_403.isc_410);
#line 3212 "restore.epp"
				break;

			case att_function_entrypoint:
				GET_TEXT(/*X.RDB$ENTRYPOINT*/
					 isc_403.isc_405);
#line 3216 "restore.epp"
				break;

			case att_function_return_arg:
				/*X.RDB$RETURN_ARGUMENT*/
				isc_403.isc_409 = (USHORT) get_numeric();
#line 3220 "restore.epp"
				break;

			case att_function_query_name:
				GET_TEXT(/*X.RDB$QUERY_NAME*/
					 isc_403.isc_404);
#line 3224 "restore.epp"
				break;

			case att_function_type:
				/*X.RDB$FUNCTION_TYPE*/
				isc_403.isc_408 = (USHORT) get_numeric();
#line 3228 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 89);
				// msg 89 function 
				break;
			}
		}
	strcpy (function_name, /*X.RDB$FUNCTION_NAME*/
			       isc_403.isc_407);
#line 3237 "restore.epp"
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_function_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 362, &isc_403, (short) 0);
	   };
#line 3238 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3239 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 3241 "restore.epp"

	// at the end of args for a function is the rec_function_end marker 
	while (get(tdgbl) == rec_function_arg)
		get_function_arg();

	return true;
}

void get_function_arg()
{
/**************************************
 *
 *	g e t _ f u n c t i o n _ a r g
 *
 **************************************
 *
 * Functional description
 *	Reconstruct function argument.
 *
 **************************************/
	ATT_TYPE	attribute;
	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	if (tdgbl->RESTORE_format >= 6)
	{
		/* with RDB$FIELD_PRECISION */
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
		X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof (isc_388), (char *) isc_388);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
#line 3273 "restore.epp"
		/*X.RDB$FIELD_SUB_TYPE.NULL*/
		isc_389.isc_400 = TRUE;
#line 3274 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID.NULL*/
		isc_389.isc_398 = TRUE;
#line 3275 "restore.epp"
		/*X.RDB$FIELD_PRECISION.NULL*/
		isc_389.isc_396  = TRUE;
#line 3276 "restore.epp"

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_389.isc_390);
#line 3284 "restore.epp"
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_389.isc_390, temp, l, sizeof(temp));
#line 3285 "restore.epp"
					BURP_verbose (119, temp, NULL, NULL, NULL, NULL);
					// msg 119 restoring argument for function %s 
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_389.isc_395 = (USHORT) get_numeric();
#line 3291 "restore.epp"
					break;

				case att_functionarg_mechanism:
					/*X.RDB$MECHANISM*/
					isc_389.isc_394 = (USHORT) get_numeric();
#line 3295 "restore.epp"
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_389.isc_393 = (USHORT) get_numeric();
#line 3299 "restore.epp"
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_389.isc_392 = (USHORT) get_numeric();
#line 3303 "restore.epp"
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_389.isc_391 = (USHORT) get_numeric();
#line 3307 "restore.epp"
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_389.isc_400 = FALSE;
#line 3311 "restore.epp"
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_389.isc_401 = (USHORT) get_numeric();
#line 3312 "restore.epp"
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_389.isc_398 = FALSE;
#line 3316 "restore.epp"
					/*X.RDB$CHARACTER_SET_ID*/
					isc_389.isc_399 = (USHORT) get_numeric();
#line 3317 "restore.epp"
					break;

				case att_functionarg_field_precision:
					/*X.RDB$FIELD_PRECISION.NULL*/
					isc_389.isc_396 = FALSE;
#line 3321 "restore.epp"
					/*X.RDB$FIELD_PRECISION*/
					isc_389.isc_397 = (USHORT) get_numeric();
#line 3322 "restore.epp"
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 90);
					// msg 90 function argument 
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_function_arg_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 54, &isc_389, (short) 0);
		   };
#line 3331 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3332 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 3334 "restore.epp"
	}
	else
	{
		/* without RDB$FIELD_PRECISION */
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
		X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof (isc_376), (char *) isc_376);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
#line 3340 "restore.epp"
		/*X.RDB$FIELD_SUB_TYPE.NULL*/
		isc_377.isc_386 = TRUE;
#line 3341 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID.NULL*/
		isc_377.isc_384 = TRUE;
#line 3342 "restore.epp"

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_377.isc_378);
#line 3350 "restore.epp"
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_377.isc_378, temp, l, sizeof(temp));
#line 3351 "restore.epp"
					BURP_verbose (119, temp, NULL, NULL, NULL, NULL);
					// msg 119 restoring argument for function %s 
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_377.isc_383 = (USHORT) get_numeric();
#line 3357 "restore.epp"
					break;

				case att_functionarg_mechanism:
					/*X.RDB$MECHANISM*/
					isc_377.isc_382 = (USHORT) get_numeric();
#line 3361 "restore.epp"
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_377.isc_381 = (USHORT) get_numeric();
#line 3365 "restore.epp"
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_377.isc_380 = (USHORT) get_numeric();
#line 3369 "restore.epp"
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_377.isc_379 = (USHORT) get_numeric();
#line 3373 "restore.epp"
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_377.isc_386 = FALSE;
#line 3377 "restore.epp"
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_377.isc_387 = (USHORT) get_numeric();
#line 3378 "restore.epp"
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_377.isc_384 = FALSE;
#line 3382 "restore.epp"
					/*X.RDB$CHARACTER_SET_ID*/
					isc_377.isc_385 = (USHORT) get_numeric();
#line 3383 "restore.epp"
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 90);
					// msg 90 function argument 
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_function_arg_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 50, &isc_377, (short) 0);
		   };
#line 3392 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3393 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 3395 "restore.epp"
	}
}

bool get_generator()
{
/**************************************
 *
 *	g e t _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Pick up a gen-id.  Like most things, there is ughly history.
 *	In the modern world, gen_id are free floating records.  In the
 *	bad old days they were attributes of relations.  Handle both
 *	nicely.
 *
 **************************************/
	SINT64		value = 0;
	/*BASED_ON RDB$GENERATORS.RDB$GENERATOR_NAME name;*/
	char
	   name[32];

#line 3415 "restore.epp"
	name[0] = 0; // just in case.
	ATT_TYPE	attribute;
	scan_attr_t		scan_next_attr;
	TGBL	    tdgbl = GET_THREAD_DATA;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_gen_generator:
			GET_TEXT(name);
			break;

		case att_gen_value:
			// IB v5 or earlier, gen_id value is an SLONG
			value = (SINT64) get_numeric();
			break;

		case att_gen_value_int64:
			// IB v6 or later, gen_id value is an SINT64
			value = get_int64();
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 93);
			// msg 93 index
			break;
		}
	}

	store_blr_gen_id (name, value);

	return true;
}

bool get_global_field()
{
/**************************************
 *
 *	g e t _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a global field.
 *
 **************************************/
	ATT_TYPE	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	GFLD gfield = NULL;

	if (tdgbl->RESTORE_format >= 6)
	{
		/* with rdb$field_precision */
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
		X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof (isc_321), (char *) isc_321);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_322.isc_324 = isc_blob_null;
		   isc_322.isc_325 = isc_blob_null;
		   isc_322.isc_326 = isc_blob_null;
		   isc_322.isc_327 = isc_blob_null;
		   isc_322.isc_328 = isc_blob_null;
		   isc_322.isc_329 = isc_blob_null;
		   isc_322.isc_330 = isc_blob_null;
		   isc_322.isc_331 = isc_blob_null;
		   isc_322.isc_333 = isc_blob_null;
		   isc_322.isc_334 = isc_blob_null;
#line 3477 "restore.epp"

		/*X.RDB$FIELD_SCALE*/
		isc_322.isc_375 = /*X.RDB$SEGMENT_LENGTH*/
   isc_322.isc_374 = 0;
#line 3479 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID*/
		isc_322.isc_373 = /*X.RDB$COLLATION_ID*/
   isc_322.isc_372 = 0;
#line 3480 "restore.epp"
		/*X.RDB$FIELD_SUB_TYPE*/
		isc_322.isc_371 = 0;
#line 3481 "restore.epp"
		/*X.RDB$COMPUTED_BLR.NULL*/
		isc_322.isc_370 = TRUE;
#line 3482 "restore.epp"
		/*X.RDB$COMPUTED_SOURCE.NULL*/
		isc_322.isc_369 = TRUE;
#line 3483 "restore.epp"
		/*X.RDB$QUERY_NAME.NULL*/
		isc_322.isc_368 = TRUE;
#line 3484 "restore.epp"
		/*X.RDB$EDIT_STRING.NULL*/
		isc_322.isc_366 = TRUE;
#line 3485 "restore.epp"
		/*X.RDB$QUERY_HEADER.NULL*/
		isc_322.isc_365 = TRUE;
#line 3486 "restore.epp"
		/*X.RDB$MISSING_VALUE.NULL*/
		isc_322.isc_364 = TRUE;
#line 3487 "restore.epp"
		/*X.RDB$DEFAULT_VALUE.NULL*/
		isc_322.isc_363 = TRUE;
#line 3488 "restore.epp"
		/*X.RDB$VALIDATION_BLR.NULL*/
		isc_322.isc_362 = TRUE;
#line 3489 "restore.epp"
		/*X.RDB$VALIDATION_SOURCE.NULL*/
		isc_322.isc_361 = TRUE;
#line 3490 "restore.epp"
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_322.isc_359 = TRUE;
#line 3491 "restore.epp"
		/*X.RDB$NULL_FLAG.NULL*/
		isc_322.isc_357 = TRUE;
#line 3492 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_322.isc_356 = TRUE;
#line 3493 "restore.epp"
		/*X.RDB$DIMENSIONS.NULL*/
		isc_322.isc_354 = TRUE;
#line 3494 "restore.epp"
		/*X.RDB$EXTERNAL_LENGTH.NULL*/
		isc_322.isc_352 = TRUE;
#line 3495 "restore.epp"
		/*X.RDB$EXTERNAL_TYPE.NULL*/
		isc_322.isc_350 = TRUE;
#line 3496 "restore.epp"
		/*X.RDB$EXTERNAL_SCALE.NULL*/
		isc_322.isc_348 = TRUE;
#line 3497 "restore.epp"
		/*X.RDB$SEGMENT_LENGTH.NULL*/
		isc_322.isc_347 = TRUE;
#line 3498 "restore.epp"
		/*X.RDB$CHARACTER_LENGTH.NULL*/
		isc_322.isc_345 = TRUE;
#line 3499 "restore.epp"
		/*X.RDB$MISSING_SOURCE.NULL*/
		isc_322.isc_344 = TRUE;
#line 3500 "restore.epp"
		/*X.RDB$DEFAULT_SOURCE.NULL*/
		isc_322.isc_343 = TRUE;
#line 3501 "restore.epp"
		/*X.RDB$FIELD_SUB_TYPE.NULL*/
		isc_322.isc_342 = TRUE;
#line 3502 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID.NULL*/
		isc_322.isc_341 = TRUE;
#line 3503 "restore.epp"
		/*X.RDB$COLLATION_ID.NULL*/
		isc_322.isc_340 = TRUE;
#line 3504 "restore.epp"
		/*X.RDB$FIELD_PRECISION.NULL*/
		isc_322.isc_338 = TRUE;
#line 3505 "restore.epp"

			memset (/*X.RDB$QUERY_NAME*/
				isc_322.isc_332, ' ', sizeof(/*X.RDB$QUERY_NAME*/
	      isc_322.isc_332));
#line 3507 "restore.epp"
			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_322.isc_323);
#line 3514 "restore.epp"
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_322.isc_323, temp, l, sizeof(temp));
#line 3515 "restore.epp"
					BURP_verbose (121, temp, NULL, NULL, NULL, NULL);
					// msg 121  restoring global field %s 
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_322.isc_332);
#line 3521 "restore.epp"
					/*X.RDB$QUERY_NAME.NULL*/
					isc_322.isc_368 = FALSE;
#line 3522 "restore.epp"
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_322.isc_367);
#line 3526 "restore.epp"
					/*X.RDB$EDIT_STRING.NULL*/
					isc_322.isc_366 = FALSE;
#line 3527 "restore.epp"
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_322.isc_365 = FALSE;
#line 3531 "restore.epp"
					get_source_blob (&/*X.RDB$QUERY_HEADER*/
							  isc_322.isc_331, false);
#line 3532 "restore.epp"
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_322.isc_337 = (USHORT) get_numeric();
#line 3536 "restore.epp"
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_322.isc_336 = (USHORT) get_numeric();
#line 3540 "restore.epp"
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_322.isc_375 = (USHORT) get_numeric();
#line 3544 "restore.epp"
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_322.isc_335 = FALSE;
#line 3545 "restore.epp"
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_322.isc_371 = (USHORT) get_numeric();
#line 3549 "restore.epp"
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_322.isc_342 = FALSE;
#line 3550 "restore.epp"
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_322.isc_374 = (USHORT) get_numeric();
#line 3554 "restore.epp"
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_322.isc_374)
#line 3555 "restore.epp"
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_322.isc_347 = FALSE;
#line 3556 "restore.epp"
					break;

				case att_field_computed_blr:
					/*X.RDB$COMPUTED_BLR.NULL*/
					isc_322.isc_370 = FALSE;
#line 3560 "restore.epp"
					get_blr_blob (&/*X.RDB$COMPUTED_BLR*/
						       isc_322.isc_334, false);
#line 3561 "restore.epp"
					break;

				case att_field_computed_source:
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_322.isc_369 = FALSE;
#line 3565 "restore.epp"
					get_misc_blob (&/*X.RDB$COMPUTED_SOURCE*/
							isc_322.isc_333, 1, false);
#line 3566 "restore.epp"
					break;

				case att_field_computed_source2:
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_322.isc_369 = FALSE;
#line 3570 "restore.epp"
					get_source_blob (&/*X.RDB$COMPUTED_SOURCE*/
							  isc_322.isc_333, false);
#line 3571 "restore.epp"
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob();
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (GFLD)BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (&gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_322.isc_362 = FALSE;
#line 3592 "restore.epp"
							get_blr_blob (&/*X.RDB$VALIDATION_BLR*/
								       isc_322.isc_328, false);
#line 3593 "restore.epp"
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob();
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (GFLD)BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (&gfield->gfld_vs, 0, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_322.isc_361 = FALSE;
#line 3616 "restore.epp"
							get_misc_blob (&/*X.RDB$VALIDATION_SOURCE*/
									isc_322.isc_327, 0, false);
#line 3617 "restore.epp"
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob();
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (GFLD)BURP_alloc_zero(sizeof(gfld));

							get_source_blob (&gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_322.isc_361 = FALSE;
#line 3640 "restore.epp"
							get_source_blob (&/*X.RDB$VALIDATION_SOURCE*/
									  isc_322.isc_327, false);
#line 3641 "restore.epp"
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_322.isc_364 = FALSE;
#line 3647 "restore.epp"
					get_blr_blob (&/*X.RDB$MISSING_VALUE*/
						       isc_322.isc_330, false);
#line 3648 "restore.epp"
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_322.isc_363 = FALSE;
#line 3652 "restore.epp"
					get_blr_blob (&/*X.RDB$DEFAULT_VALUE*/
						       isc_322.isc_329, false);
#line 3653 "restore.epp"
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_322.isc_360 = (USHORT) get_numeric();
#line 3657 "restore.epp"
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_322.isc_359 = FALSE;
#line 3658 "restore.epp"
					break;

				case att_field_null_flag:
					/*X.RDB$NULL_FLAG*/
					isc_322.isc_358 = (USHORT) get_numeric();
#line 3662 "restore.epp"
					/*X.RDB$NULL_FLAG.NULL*/
					isc_322.isc_357 = FALSE;
#line 3663 "restore.epp"
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_322.isc_356 = FALSE;
#line 3667 "restore.epp"
					get_misc_blob (&/*X.RDB$DESCRIPTION*/
							isc_322.isc_326, 1, false);
#line 3668 "restore.epp"
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_322.isc_356 = FALSE;
#line 3672 "restore.epp"
					get_source_blob (&/*X.RDB$DESCRIPTION*/
							  isc_322.isc_326, false);
#line 3673 "restore.epp"
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_322.isc_352 = FALSE;
#line 3677 "restore.epp"
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_322.isc_353 = (USHORT) get_numeric();
#line 3678 "restore.epp"
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_322.isc_348 = FALSE;
#line 3682 "restore.epp"
					/*X.RDB$EXTERNAL_SCALE*/
					isc_322.isc_349 = (USHORT) get_numeric();
#line 3683 "restore.epp"
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_322.isc_350 = FALSE;
#line 3687 "restore.epp"
					/*X.RDB$EXTERNAL_TYPE*/
					isc_322.isc_351 = (USHORT) get_numeric();
#line 3688 "restore.epp"
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_322.isc_354 = FALSE;
#line 3692 "restore.epp"
					/*X.RDB$DIMENSIONS*/
					isc_322.isc_355 = (USHORT) get_numeric();
#line 3693 "restore.epp"
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_322.isc_345 = FALSE;
#line 3697 "restore.epp"
					/*X.RDB$CHARACTER_LENGTH*/
					isc_322.isc_346 = (USHORT) get_numeric();
#line 3698 "restore.epp"
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_322.isc_343 = FALSE;
#line 3702 "restore.epp"
					get_source_blob (&/*X.RDB$DEFAULT_SOURCE*/
							  isc_322.isc_324, false);
#line 3703 "restore.epp"
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_322.isc_344 = FALSE;
#line 3707 "restore.epp"
					get_source_blob (&/*X.RDB$MISSING_SOURCE*/
							  isc_322.isc_325, false);
#line 3708 "restore.epp"
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_322.isc_341 = FALSE;
#line 3712 "restore.epp"
					/*X.RDB$CHARACTER_SET_ID*/
					isc_322.isc_373 = (USHORT) get_numeric();
#line 3713 "restore.epp"
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_322.isc_340 = FALSE;
#line 3717 "restore.epp"
					/*X.RDB$COLLATION_ID*/
					isc_322.isc_372 = (USHORT) get_numeric();
#line 3718 "restore.epp"
					break;

				case att_field_precision:
					/*X.RDB$FIELD_PRECISION.NULL*/
					isc_322.isc_338 = FALSE;
#line 3722 "restore.epp"
					/*X.RDB$FIELD_PRECISION*/
					isc_322.isc_339 = (USHORT) get_numeric();
#line 3723 "restore.epp"
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 92);
					// msg 92  global field 
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_322.isc_337 <= DTYPE_BLR_MAX)
#line 3733 "restore.epp"
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_322.isc_337];
#line 3735 "restore.epp"
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_322.isc_336 = l;
#line 3737 "restore.epp"
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_322.isc_323);
#line 3741 "restore.epp"

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_global_field_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 350, &isc_322, (short) 0);
		   };
#line 3743 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3744 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 3746 "restore.epp"

	}
	else /* RESTORE_format < 6 */
	{
		/* without rdb$field_precision */

		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
		X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof (isc_268), (char *) isc_268);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_269.isc_271 = isc_blob_null;
		   isc_269.isc_272 = isc_blob_null;
		   isc_269.isc_273 = isc_blob_null;
		   isc_269.isc_274 = isc_blob_null;
		   isc_269.isc_275 = isc_blob_null;
		   isc_269.isc_276 = isc_blob_null;
		   isc_269.isc_277 = isc_blob_null;
		   isc_269.isc_278 = isc_blob_null;
		   isc_269.isc_280 = isc_blob_null;
		   isc_269.isc_281 = isc_blob_null;
#line 3754 "restore.epp"

		/*X.RDB$FIELD_SCALE*/
		isc_269.isc_320 = /*X.RDB$SEGMENT_LENGTH*/
   isc_269.isc_319 = 0;
#line 3756 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID*/
		isc_269.isc_318 = /*X.RDB$COLLATION_ID*/
   isc_269.isc_317 = 0;
#line 3757 "restore.epp"
		/*X.RDB$FIELD_SUB_TYPE*/
		isc_269.isc_316 = 0;
#line 3758 "restore.epp"
		/*X.RDB$COMPUTED_BLR.NULL*/
		isc_269.isc_315 = TRUE;
#line 3759 "restore.epp"
		/*X.RDB$COMPUTED_SOURCE.NULL*/
		isc_269.isc_314 = TRUE;
#line 3760 "restore.epp"
		/*X.RDB$QUERY_NAME.NULL*/
		isc_269.isc_313 = TRUE;
#line 3761 "restore.epp"
		/*X.RDB$EDIT_STRING.NULL*/
		isc_269.isc_311 = TRUE;
#line 3762 "restore.epp"
		/*X.RDB$QUERY_HEADER.NULL*/
		isc_269.isc_310 = TRUE;
#line 3763 "restore.epp"
		/*X.RDB$MISSING_VALUE.NULL*/
		isc_269.isc_309 = TRUE;
#line 3764 "restore.epp"
		/*X.RDB$DEFAULT_VALUE.NULL*/
		isc_269.isc_308 = TRUE;
#line 3765 "restore.epp"
		/*X.RDB$VALIDATION_BLR.NULL*/
		isc_269.isc_307 = TRUE;
#line 3766 "restore.epp"
		/*X.RDB$VALIDATION_SOURCE.NULL*/
		isc_269.isc_306 = TRUE;
#line 3767 "restore.epp"
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_269.isc_304 = TRUE;
#line 3768 "restore.epp"
		/*X.RDB$NULL_FLAG.NULL*/
		isc_269.isc_302 = TRUE;
#line 3769 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_269.isc_301 = TRUE;
#line 3770 "restore.epp"
		/*X.RDB$DIMENSIONS.NULL*/
		isc_269.isc_299 = TRUE;
#line 3771 "restore.epp"
		/*X.RDB$EXTERNAL_LENGTH.NULL*/
		isc_269.isc_297 = TRUE;
#line 3772 "restore.epp"
		/*X.RDB$EXTERNAL_TYPE.NULL*/
		isc_269.isc_295 = TRUE;
#line 3773 "restore.epp"
		/*X.RDB$EXTERNAL_SCALE.NULL*/
		isc_269.isc_293 = TRUE;
#line 3774 "restore.epp"
		/*X.RDB$SEGMENT_LENGTH.NULL*/
		isc_269.isc_292 = TRUE;
#line 3775 "restore.epp"
		/*X.RDB$CHARACTER_LENGTH.NULL*/
		isc_269.isc_290 = TRUE;
#line 3776 "restore.epp"
		/*X.RDB$MISSING_SOURCE.NULL*/
		isc_269.isc_289 = TRUE;
#line 3777 "restore.epp"
		/*X.RDB$DEFAULT_SOURCE.NULL*/
		isc_269.isc_288 = TRUE;
#line 3778 "restore.epp"
		/*X.RDB$FIELD_SUB_TYPE.NULL*/
		isc_269.isc_287 = TRUE;
#line 3779 "restore.epp"
		/*X.RDB$CHARACTER_SET_ID.NULL*/
		isc_269.isc_286 = TRUE;
#line 3780 "restore.epp"
		/*X.RDB$COLLATION_ID.NULL*/
		isc_269.isc_285 = TRUE;
#line 3781 "restore.epp"

			memset (/*X.RDB$QUERY_NAME*/
				isc_269.isc_279, ' ', sizeof(/*X.RDB$QUERY_NAME*/
	      isc_269.isc_279));
#line 3783 "restore.epp"
			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_269.isc_270);
#line 3790 "restore.epp"
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_269.isc_270, temp, l, sizeof(temp));
#line 3791 "restore.epp"
					BURP_verbose (121, temp, NULL, NULL, NULL, NULL);
					// msg 121  restoring global field %s 
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_269.isc_279);
#line 3797 "restore.epp"
					/*X.RDB$QUERY_NAME.NULL*/
					isc_269.isc_313 = FALSE;
#line 3798 "restore.epp"
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_269.isc_312);
#line 3802 "restore.epp"
					/*X.RDB$EDIT_STRING.NULL*/
					isc_269.isc_311 = FALSE;
#line 3803 "restore.epp"
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_269.isc_310 = FALSE;
#line 3807 "restore.epp"
					get_source_blob (&/*X.RDB$QUERY_HEADER*/
							  isc_269.isc_278, false);
#line 3808 "restore.epp"
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_269.isc_284 = (USHORT) get_numeric();
#line 3812 "restore.epp"
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_269.isc_283 = (USHORT) get_numeric();
#line 3816 "restore.epp"
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_269.isc_320 = (USHORT) get_numeric();
#line 3820 "restore.epp"
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_269.isc_282 = FALSE;
#line 3821 "restore.epp"
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_269.isc_316 = (USHORT) get_numeric();
#line 3825 "restore.epp"
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_269.isc_287 = FALSE;
#line 3826 "restore.epp"
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_269.isc_319 = (USHORT) get_numeric();
#line 3830 "restore.epp"
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_269.isc_319)
#line 3831 "restore.epp"
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_269.isc_292 = FALSE;
#line 3832 "restore.epp"
					break;

				case att_field_computed_blr:
					/*X.RDB$COMPUTED_BLR.NULL*/
					isc_269.isc_315 = FALSE;
#line 3836 "restore.epp"
					get_blr_blob (&/*X.RDB$COMPUTED_BLR*/
						       isc_269.isc_281, false);
#line 3837 "restore.epp"
					break;

				case att_field_computed_source:
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_269.isc_314 = FALSE;
#line 3841 "restore.epp"
					get_misc_blob (&/*X.RDB$COMPUTED_SOURCE*/
							isc_269.isc_280, 1, false);
#line 3842 "restore.epp"
					break;

				case att_field_computed_source2:
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_269.isc_314 = FALSE;
#line 3846 "restore.epp"
					get_source_blob (&/*X.RDB$COMPUTED_SOURCE*/
							  isc_269.isc_280, false);
#line 3847 "restore.epp"
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob();
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (GFLD)BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (&gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_269.isc_307 = FALSE;
#line 3868 "restore.epp"
							get_blr_blob (&/*X.RDB$VALIDATION_BLR*/
								       isc_269.isc_275, false);
#line 3869 "restore.epp"
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob();
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (GFLD)BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (&gfield->gfld_vs, 0, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_269.isc_306 = FALSE;
#line 3892 "restore.epp"
							get_misc_blob (&/*X.RDB$VALIDATION_SOURCE*/
									isc_269.isc_274, 0, false);
#line 3893 "restore.epp"
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob();
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (GFLD)BURP_alloc_zero(sizeof(gfld));

							get_source_blob (&gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_269.isc_306 = FALSE;
#line 3916 "restore.epp"
							get_source_blob (&/*X.RDB$VALIDATION_SOURCE*/
									  isc_269.isc_274, false);
#line 3917 "restore.epp"
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_269.isc_309 = FALSE;
#line 3923 "restore.epp"
					get_blr_blob (&/*X.RDB$MISSING_VALUE*/
						       isc_269.isc_277, false);
#line 3924 "restore.epp"
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_269.isc_308 = FALSE;
#line 3928 "restore.epp"
					get_blr_blob (&/*X.RDB$DEFAULT_VALUE*/
						       isc_269.isc_276, false);
#line 3929 "restore.epp"
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_269.isc_305 = (USHORT) get_numeric();
#line 3933 "restore.epp"
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_269.isc_304 = FALSE;
#line 3934 "restore.epp"
					break;

				case att_field_null_flag:
					/*X.RDB$NULL_FLAG*/
					isc_269.isc_303 = (USHORT) get_numeric();
#line 3938 "restore.epp"
					/*X.RDB$NULL_FLAG.NULL*/
					isc_269.isc_302 = FALSE;
#line 3939 "restore.epp"
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_269.isc_301 = FALSE;
#line 3943 "restore.epp"
					get_misc_blob (&/*X.RDB$DESCRIPTION*/
							isc_269.isc_273, 1, false);
#line 3944 "restore.epp"
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_269.isc_301 = FALSE;
#line 3948 "restore.epp"
					get_source_blob (&/*X.RDB$DESCRIPTION*/
							  isc_269.isc_273, false);
#line 3949 "restore.epp"
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_269.isc_297 = FALSE;
#line 3953 "restore.epp"
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_269.isc_298 = (USHORT) get_numeric();
#line 3954 "restore.epp"
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_269.isc_293 = FALSE;
#line 3958 "restore.epp"
					/*X.RDB$EXTERNAL_SCALE*/
					isc_269.isc_294 = (USHORT) get_numeric();
#line 3959 "restore.epp"
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_269.isc_295 = FALSE;
#line 3963 "restore.epp"
					/*X.RDB$EXTERNAL_TYPE*/
					isc_269.isc_296 = (USHORT) get_numeric();
#line 3964 "restore.epp"
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_269.isc_299 = FALSE;
#line 3968 "restore.epp"
					/*X.RDB$DIMENSIONS*/
					isc_269.isc_300 = (USHORT) get_numeric();
#line 3969 "restore.epp"
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_269.isc_290 = FALSE;
#line 3973 "restore.epp"
					/*X.RDB$CHARACTER_LENGTH*/
					isc_269.isc_291 = (USHORT) get_numeric();
#line 3974 "restore.epp"
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_269.isc_288 = FALSE;
#line 3978 "restore.epp"
					get_source_blob (&/*X.RDB$DEFAULT_SOURCE*/
							  isc_269.isc_271, false);
#line 3979 "restore.epp"
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_269.isc_289 = FALSE;
#line 3983 "restore.epp"
					get_source_blob (&/*X.RDB$MISSING_SOURCE*/
							  isc_269.isc_272, false);
#line 3984 "restore.epp"
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_269.isc_286 = FALSE;
#line 3988 "restore.epp"
					/*X.RDB$CHARACTER_SET_ID*/
					isc_269.isc_318 = (USHORT) get_numeric();
#line 3989 "restore.epp"
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_269.isc_285 = FALSE;
#line 3993 "restore.epp"
					/*X.RDB$COLLATION_ID*/
					isc_269.isc_317 = (USHORT) get_numeric();
#line 3994 "restore.epp"
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 92);
					// msg 92  global field 
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_269.isc_284 <= DTYPE_BLR_MAX)
#line 4004 "restore.epp"
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_269.isc_284];
#line 4006 "restore.epp"
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_269.isc_283 = l;
#line 4008 "restore.epp"
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_269.isc_270);
#line 4012 "restore.epp"

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_global_field_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 346, &isc_269, (short) 0);
		   };
#line 4014 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 4015 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 4017 "restore.epp"

	}

	if (gfield)
	{
		gfield->gfld_next = tdgbl->gbl_global_fields;
		tdgbl->gbl_global_fields = gfield;
	}

	return true;
}

bool get_index (const burp_rel* relation)
{
/**************************************
 *
 *	g e t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Build an index.  At the end stop
 *	and check that all fields are defined.
 *	If any fields are missing, delete the
 *	index.
 *
 **************************************/
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];

#line 4045 "restore.epp"
	ATT_TYPE	attribute;
	bool		foreign_index = false;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	SSHORT count = 0, segments = 0;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle1)
		X IN RDB$INDICES*/
	{
	
        if (!tdgbl->handles_get_index_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_index_req_handle1, (short) sizeof (isc_251), (char *) isc_251);
	if (tdgbl->handles_get_index_req_handle1)
	   {
	   isc_252.isc_254 = isc_blob_null;
	   isc_252.isc_255 = isc_blob_null;
	   isc_252.isc_257 = isc_blob_null;
#line 4055 "restore.epp"
		strcpy (/*X.RDB$RELATION_NAME*/
			isc_252.isc_258, relation->rel_name);
#line 4056 "restore.epp"
		/*X.RDB$UNIQUE_FLAG*/
		isc_252.isc_267 = 0;
#line 4057 "restore.epp"
		if (!tdgbl->gbl_sw_deactivate_indexes)
			/*X.RDB$INDEX_INACTIVE*/
			isc_252.isc_266 = FALSE;
#line 4059 "restore.epp"
		else
			/*X.RDB$INDEX_INACTIVE*/
			isc_252.isc_266 = TRUE;
#line 4061 "restore.epp"
		/*X.RDB$INDEX_TYPE.NULL*/
		isc_252.isc_264 = TRUE;
#line 4062 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_252.isc_263 = TRUE;
#line 4063 "restore.epp"
		/*X.RDB$FOREIGN_KEY.NULL*/
		isc_252.isc_262 = TRUE;
#line 4064 "restore.epp"
		/*X.RDB$EXPRESSION_SOURCE.NULL*/
		isc_252.isc_261 = TRUE;
#line 4065 "restore.epp"
		/*X.RDB$EXPRESSION_BLR.NULL*/
		isc_252.isc_260 = TRUE;
#line 4066 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_index_name:
				GET_TEXT(/*X.RDB$INDEX_NAME*/
					 isc_252.isc_253);
#line 4073 "restore.epp"
				strcpy (index_name, /*X.RDB$INDEX_NAME*/
						    isc_252.isc_253);
#line 4074 "restore.epp"
				BURP_verbose (122, /*X.RDB$INDEX_NAME*/
						   isc_252.isc_253, NULL, NULL, NULL, NULL);
#line 4075 "restore.epp"
				break;

			case att_segment_count:
				/*X.RDB$SEGMENT_COUNT*/
				isc_252.isc_259 = segments = (USHORT) get_numeric();
#line 4079 "restore.epp"
				break;

			case att_index_unique_flag:
				/*X.RDB$UNIQUE_FLAG*/
				isc_252.isc_267 = (USHORT) get_numeric();
#line 4083 "restore.epp"
				break;

			case att_index_inactive:
				/*X.RDB$INDEX_INACTIVE*/
				isc_252.isc_266 = (USHORT) get_numeric();
#line 4087 "restore.epp"
				// Defer foreign key index activation 
				// Modified by Toni Martir, all index deferred when verbose 
				if (tdgbl->gbl_sw_verbose)
				{
					if (/*X.RDB$INDEX_INACTIVE*/
					    isc_252.isc_266 == FALSE)
#line 4092 "restore.epp"
						/*X.RDB$INDEX_INACTIVE*/
						isc_252.isc_266 = DEFERRED_ACTIVE;
#line 4093 "restore.epp"
				}
				else
				{
					if (/*X.RDB$INDEX_INACTIVE*/
					    isc_252.isc_266 == FALSE && foreign_index)
#line 4097 "restore.epp"
						/*X.RDB$INDEX_INACTIVE*/
						isc_252.isc_266 = DEFERRED_ACTIVE;
#line 4098 "restore.epp"
				}
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_252.isc_266 = TRUE;
#line 4101 "restore.epp"
				break;

			case att_index_type:
				/*X.RDB$INDEX_TYPE.NULL*/
				isc_252.isc_264 = FALSE;
#line 4105 "restore.epp"
				/*X.RDB$INDEX_TYPE*/
				isc_252.isc_265 = (USHORT) get_numeric();
#line 4106 "restore.epp"
				break;

			case att_index_field_name:
				/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle2)
					Y IN RDB$INDEX_SEGMENTS*/
				{
				
                                if (!tdgbl->handles_get_index_req_handle2)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_index_req_handle2, (short) sizeof (isc_246), (char *) isc_246);
				if (tdgbl->handles_get_index_req_handle2)
				   {
#line 4111 "restore.epp"
					GET_TEXT(/*Y.RDB$FIELD_NAME*/
						 isc_247.isc_249);
#line 4112 "restore.epp"
					strcpy (/*Y.RDB$INDEX_NAME*/
						isc_247.isc_248, /*X.RDB$INDEX_NAME*/
  isc_252.isc_253);
#line 4113 "restore.epp"
					/*Y.RDB$FIELD_POSITION*/
					isc_247.isc_250 = count++;
#line 4114 "restore.epp"
				/*END_STORE;*/
				   
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 66, &isc_247, (short) 0);
				   };
#line 4115 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 4116 "restore.epp"
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 4118 "restore.epp"
				break;

			case att_index_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_252.isc_263 = FALSE;
#line 4122 "restore.epp"
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_252.isc_257, 0, false);
#line 4123 "restore.epp"
				break;

			case att_index_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_252.isc_263 = FALSE;
#line 4127 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_252.isc_257, false);
#line 4128 "restore.epp"
				break;

			case att_index_expression_source:
				/*X.RDB$EXPRESSION_SOURCE.NULL*/
				isc_252.isc_261 = FALSE;
#line 4132 "restore.epp"
				get_source_blob (&/*X.RDB$EXPRESSION_SOURCE*/
						  isc_252.isc_255, false);
#line 4133 "restore.epp"
				break;

			case att_index_expression_blr:
				/*X.RDB$EXPRESSION_BLR.NULL*/
				isc_252.isc_260 = FALSE;
#line 4137 "restore.epp"
				get_blr_blob (&/*X.RDB$EXPRESSION_BLR*/
					       isc_252.isc_254, false);
#line 4138 "restore.epp"
				break;

			case att_index_foreign_key:
				foreign_index = true;
				// Defer foreign key index activation 
				if (/*X.RDB$INDEX_INACTIVE*/
				    isc_252.isc_266 == FALSE)
#line 4144 "restore.epp"
					/*X.RDB$INDEX_INACTIVE*/
					isc_252.isc_266 = DEFERRED_ACTIVE;
#line 4145 "restore.epp"
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_252.isc_266 = TRUE;
#line 4147 "restore.epp"
				/*X.RDB$FOREIGN_KEY.NULL*/
				isc_252.isc_262 = FALSE;
#line 4148 "restore.epp"
				GET_TEXT(/*X.RDB$FOREIGN_KEY*/
					 isc_252.isc_256);
#line 4149 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 93);
				// msg 93 index 
				break;
			}
		}

		count = 0;
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle3)
			RFR IN RDB$RELATION_FIELDS CROSS I_S IN RDB$INDEX_SEGMENTS
			OVER RDB$FIELD_NAME WITH I_S.RDB$INDEX_NAME = index_name AND
			RFR.RDB$RELATION_NAME = relation->rel_name*/
		{
                if (!tdgbl->handles_get_index_req_handle3)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_index_req_handle3, (short) sizeof (isc_240), (char *) isc_240);
		isc_vtov ((char*)relation->rel_name, (char*)isc_241.isc_242, 32);
		isc_vtov ((char*)index_name, (char*)isc_241.isc_243, 32);
		if (tdgbl->handles_get_index_req_handle3)
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle3, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_241, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle3, (short) 1, (short) 2, &isc_244, (short) 0);
		   if (!isc_244.isc_245 || isc_status [1]) break;
#line 4163 "restore.epp"
			count++;
		/*END_FOR;*/
		   }
		   };
#line 4165 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 4166 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 4168 "restore.epp"

		if (count != segments)
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle4)
				I_S IN RDB$INDEX_SEGMENTS WITH I_S.RDB$INDEX_NAME = index_name*/
			{
                        if (!tdgbl->handles_get_index_req_handle4)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_index_req_handle4, (short) sizeof (isc_231), (char *) isc_231);
			isc_vtov ((char*)index_name, (char*)isc_232.isc_233, 32);
			if (tdgbl->handles_get_index_req_handle4)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle4, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_232, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle4, (short) 1, (short) 2, &isc_234, (short) 0);
			   if (!isc_234.isc_235 || isc_status [1]) break;
#line 4173 "restore.epp"
				/*ERASE I_S;*/
				{
                                isc_send (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle4, (short) 2, (short) 2, &isc_236, (short) 0);
#line 4174 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 4175 "restore.epp"
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 4177 "restore.epp"
			/*END_FOR;*/
                           isc_send (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle4, (short) 3, (short) 2, &isc_238, (short) 0);
			   }
			   };
#line 4178 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 4179 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 4181 "restore.epp"
			return false;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_index_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 138, &isc_252, (short) 0);
	   };
#line 4184 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 4185 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 4187 "restore.epp"

	return true;
}

void get_misc_blob (ISC_QUAD	*blob_id,
					USHORT	sub_type,
					bool	glb_trans)
{
/**************************************
 *
 *	g e t _ m i s c _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	TGBL tdgbl = GET_THREAD_DATA;

	const USHORT length = (USHORT)get_numeric();

	// Create new blob

	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	isc_handle blob = NULL;
	USHORT bpb_length = 0;
	UCHAR* bpb = NULL;
	if (isc_create_blob2 (status_vector, &DB, &local_trans, &blob,
						  blob_id, bpb_length,
						  reinterpret_cast<const SCHAR*>(bpb)))
	{
		BURP_error_redirect (status_vector, 37, 0, 0);
		// msg 37 isc_create_blob failed 
	}

	// Allocate blob buffer if static buffer is too short 
	UCHAR static_buffer[1024];
	UCHAR* buffer;
	if (!length || length <= (USHORT)(sizeof(static_buffer)) )
		buffer = static_buffer;
	else
		buffer = BURP_alloc (length);

	if (length)
	{
		get_block(tdgbl, buffer, length);
	}

	if (isc_put_segment (status_vector, &blob, length,
		reinterpret_cast<const SCHAR*>(buffer)))
	{
		BURP_error_redirect (status_vector, 38, 0, 0);
		// msg 38 isc_put_segment failed 
	}

	if (isc_close_blob (status_vector, &blob))
		BURP_error_redirect (status_vector, 23, 0, 0);
		// msg 23 isc_close_blob failed 

	if (buffer != static_buffer)
		BURP_free (buffer);
}

SLONG get_numeric()
{
/**************************************
 *
 *	g e t _ n u m e r i c
 *
 **************************************
 *
 * Functional description
 *	Get a numeric value from the input stream.
 *
 **************************************/
	SLONG	value[2];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert(sizeof(value) > sizeof(SLONG));

	const SSHORT length = get_text((TEXT*) value, sizeof(value));

	return isc_vax_integer ((SCHAR *) value, length);
}

SINT64 get_int64()
{
/**************************************
 *
 *	g e t _ i n t 6 4
 *
 **************************************
 *
 * Functional description
 *	Get a possibly-64-bit numeric value from the input stream.
 *
 **************************************/
	SLONG	value[4];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert (sizeof(value) > sizeof(SINT64));

	const SSHORT length = get_text ((TEXT *) value, sizeof(value));

	return isc_portable_integer ((UCHAR *) value, length);
}

bool get_procedure()
{
/**************************************
 *
 *	g e t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a stored procedure.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	ATT_TYPE	attribute;
	GDS_NAME	procedure_name;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	isc_tr_handle local_trans =
		tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	BURP_PRC procedure = (BURP_PRC) BURP_alloc_zero (sizeof(burp_prc));
	procedure->prc_next = tdgbl->procedures;
	tdgbl->procedures = procedure;

	/*STORE (TRANSACTION_HANDLE local_trans
		   REQUEST_HANDLE tdgbl->handles_get_procedure_req_handle1)
		X IN RDB$PROCEDURES*/
	{
	
        if (!tdgbl->handles_get_procedure_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_procedure_req_handle1, (short) sizeof (isc_216), (char *) isc_216);
	if (tdgbl->handles_get_procedure_req_handle1)
	   {
	   isc_217.isc_218 = isc_blob_null;
	   isc_217.isc_222 = isc_blob_null;
	   isc_217.isc_223 = isc_blob_null;
#line 4338 "restore.epp"
		/*X.RDB$PROCEDURE_SOURCE.NULL*/
		isc_217.isc_230 = TRUE;
#line 4339 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_217.isc_229 = TRUE;
#line 4340 "restore.epp"
		/*X.RDB$SECURITY_CLASS.NULL*/
		isc_217.isc_228 = TRUE;
#line 4341 "restore.epp"
		/*X.RDB$OWNER_NAME.NULL*/
		isc_217.isc_227 = TRUE;
#line 4342 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_procedure_name:
				l = GET_TEXT(/*X.RDB$PROCEDURE_NAME*/
					     isc_217.isc_219);
#line 4349 "restore.epp"
						procedure->prc_name_length = l;
						strcpy (procedure->prc_name, /*X.RDB$PROCEDURE_NAME*/
									     isc_217.isc_219);
#line 4351 "restore.epp"
				MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
						isc_217.isc_219, temp, l, sizeof(temp));
#line 4352 "restore.epp"
				BURP_verbose (195, temp, NULL, NULL, NULL, NULL);
				// msg 195 restoring stored procedure %s 
				break;

			case att_procedure_description:
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_217.isc_222, 0, true);
#line 4358 "restore.epp"
				/*X.RDB$DESCRIPTION.NULL*/
				isc_217.isc_229 = FALSE;
#line 4359 "restore.epp"
				break;

			case att_procedure_description2:
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_217.isc_222, true);
#line 4363 "restore.epp"
				/*X.RDB$DESCRIPTION.NULL*/
				isc_217.isc_229 = FALSE;
#line 4364 "restore.epp"
				break;

			case att_procedure_source:
				get_misc_blob (&/*X.RDB$PROCEDURE_SOURCE*/
						isc_217.isc_223, 0, true);
#line 4368 "restore.epp"
				/*X.RDB$PROCEDURE_SOURCE.NULL*/
				isc_217.isc_230 = FALSE;
#line 4369 "restore.epp"
				break;

			case att_procedure_source2:
				get_source_blob (&/*X.RDB$PROCEDURE_SOURCE*/
						  isc_217.isc_223, true);
#line 4373 "restore.epp"
				/*X.RDB$PROCEDURE_SOURCE.NULL*/
				isc_217.isc_230 = FALSE;
#line 4374 "restore.epp"
				break;

			case att_procedure_blr:
				get_blr_blob (&/*X.RDB$PROCEDURE_BLR*/
					       isc_217.isc_218, true);
#line 4378 "restore.epp"
				break;

			case att_procedure_security_class:
				GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					 isc_217.isc_221);
#line 4382 "restore.epp"
				/*X.RDB$SECURITY_CLASS.NULL*/
				isc_217.isc_228 = FALSE;
#line 4383 "restore.epp"
				break;

			case att_procedure_owner_name:
				GET_TEXT(procedure->prc_owner);
				break;

			case att_procedure_inputs:
				/*X.RDB$PROCEDURE_INPUTS*/
				isc_217.isc_226 = (USHORT) get_numeric();
#line 4391 "restore.epp"
						if (/*X.RDB$PROCEDURE_INPUTS*/
						    isc_217.isc_226 == 0)
#line 4392 "restore.epp"
							/*X.RDB$PROCEDURE_INPUTS.NULL*/
							isc_217.isc_225 = TRUE;
#line 4393 "restore.epp"
						else
							/*X.RDB$PROCEDURE_INPUTS.NULL*/
							isc_217.isc_225 = FALSE;
#line 4395 "restore.epp"
				break;

			case att_procedure_outputs:
				/*X.RDB$PROCEDURE_OUTPUTS*/
				isc_217.isc_224 = (USHORT) get_numeric();
#line 4399 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 89);
				// msg 89 function 
				break;
			}
		}
		strcpy (procedure_name, /*X.RDB$PROCEDURE_NAME*/
					isc_217.isc_219);
#line 4408 "restore.epp"
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_procedure_req_handle1, (isc_handle*) &local_trans, (short) 0, (short) 134, &isc_217, (short) 0);
	   };
#line 4409 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 4410 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 4412 "restore.epp"

	// at the end of prms for a procedure is the rec_procedure_end marker 

	while (get(tdgbl) == rec_procedure_prm)
		get_procedure_prm (procedure_name);

	return true;
}

bool get_procedure_prm (GDS_NAME	procptr)
{
/**************************************
 *
 *	g e t _ p r o c e d u r e _ p r m
 *
 **************************************
 *
 * Functional description
 *	Reconstruct stored procedure parameter.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	ATT_TYPE	attribute;
	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	isc_tr_handle local_trans =
		tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
		REQUEST_HANDLE tdgbl->handles_get_procedure_prm_req_handle1)
		X IN RDB$PROCEDURE_PARAMETERS*/
	{
	
        if (!tdgbl->handles_get_procedure_prm_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_procedure_prm_req_handle1, (short) sizeof (isc_207), (char *) isc_207);
	if (tdgbl->handles_get_procedure_prm_req_handle1)
	   {
	   isc_208.isc_212 = isc_blob_null;
#line 4449 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_208.isc_215 = TRUE;
#line 4450 "restore.epp"
		strcpy (/*X.RDB$PROCEDURE_NAME*/
			isc_208.isc_211, procptr);
#line 4451 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_procedureprm_name:
				l = GET_TEXT(/*X.RDB$PARAMETER_NAME*/
					     isc_208.isc_210);
#line 4458 "restore.epp"
				MISC_terminate (/*X.RDB$PARAMETER_NAME*/
						isc_208.isc_210, temp, l, sizeof(temp));
#line 4459 "restore.epp"
				BURP_verbose (196, temp, NULL, NULL, NULL, NULL);
				// msg 196 restoring parameter %s for stored procedure 
				break;

			case att_procedureprm_type:
				/*X.RDB$PARAMETER_TYPE*/
				isc_208.isc_214= (USHORT) get_numeric();
#line 4465 "restore.epp"
				break;

			case att_procedureprm_number:
				/*X.RDB$PARAMETER_NUMBER*/
				isc_208.isc_213= (USHORT) get_numeric();
#line 4469 "restore.epp"
				break;

			case att_procedureprm_field_source:
				GET_TEXT(/*X.RDB$FIELD_SOURCE*/
					 isc_208.isc_209);
#line 4473 "restore.epp"
				break;

			case att_procedureprm_description:
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_208.isc_212, 0, true);
#line 4477 "restore.epp"
				/*X.RDB$DESCRIPTION.NULL*/
				isc_208.isc_215 = FALSE;
#line 4478 "restore.epp"
				break;

			case att_procedureprm_description2:
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_208.isc_212, true);
#line 4482 "restore.epp"
				/*X.RDB$DESCRIPTION.NULL*/
				isc_208.isc_215 = FALSE;
#line 4483 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 90);
				// msg 90 function argument 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_procedure_prm_req_handle1, (isc_handle*) &local_trans, (short) 0, (short) 110, &isc_208, (short) 0);
	   };
#line 4492 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 4493 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 4495 "restore.epp"

	return true;
}

bool get_ref_constraint()
{
/**************************************
 *
 *	g e t _ r e f _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for referential constraints.
 *
 **************************************/
	ATT_TYPE        attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_ref_constraint_req_handle1)
		X IN RDB$REF_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_ref_constraint_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_ref_constraint_req_handle1, (short) sizeof (isc_195), (char *) isc_195);
	if (tdgbl->handles_get_ref_constraint_req_handle1)
	   {
#line 4518 "restore.epp"
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_196.isc_206 = TRUE;
#line 4519 "restore.epp"
		/*X.RDB$CONST_NAME_UQ.NULL*/
		isc_196.isc_205 = TRUE;
#line 4520 "restore.epp"
		/*X.RDB$MATCH_OPTION.NULL*/
		isc_196.isc_204 = TRUE;
#line 4521 "restore.epp"
		/*X.RDB$UPDATE_RULE.NULL*/
		isc_196.isc_203 = TRUE;
#line 4522 "restore.epp"
		/*X.RDB$DELETE_RULE.NULL*/
		isc_196.isc_202 = TRUE;
#line 4523 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_ref_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_196.isc_206 = FALSE;
#line 4530 "restore.epp"
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_196.isc_199);
#line 4531 "restore.epp"
					break;

				case att_ref_unique_const_name:
					/*X.RDB$CONST_NAME_UQ.NULL*/
					isc_196.isc_205 = FALSE;
#line 4535 "restore.epp"
					GET_TEXT(/*X.RDB$CONST_NAME_UQ*/
						 isc_196.isc_198);
#line 4536 "restore.epp"
					break;

				case att_ref_match_option:
					/*X.RDB$MATCH_OPTION.NULL*/
					isc_196.isc_204 = FALSE;
#line 4540 "restore.epp"
					GET_TEXT(/*X.RDB$MATCH_OPTION*/
						 isc_196.isc_197);
#line 4541 "restore.epp"
					break;

				case att_ref_update_rule:
					/*X.RDB$UPDATE_RULE.NULL*/
					isc_196.isc_203 = FALSE;
#line 4545 "restore.epp"
					GET_TEXT(/*X.RDB$UPDATE_RULE*/
						 isc_196.isc_201);
#line 4546 "restore.epp"
					break;

				case att_ref_delete_rule:
					/*X.RDB$DELETE_RULE.NULL*/
					isc_196.isc_202 = FALSE;
#line 4550 "restore.epp"
					GET_TEXT(/*X.RDB$DELETE_RULE*/
						 isc_196.isc_200);
#line 4551 "restore.epp"
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 208);
					// msg 208 relation constraint 
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_ref_constraint_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 106, &isc_196, (short) 0);
	   };
#line 4560 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 4561 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 4563 "restore.epp"

	return true;
}

bool get_relation()
{
/**************************************
 *
 *	g e t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *	Use the default transaction for RELATIONS,
 *	and use the global_trans for VIEWS.  This
 *	enables us to have views of SP and views
 *	with plans.  Assume it is a view if it has
 *	RDB$VIEW_BLR, also assume RDB$VIEW_BLR is
 *	the first blob in the backup file.
 *
 *
 **************************************/
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	ATT_TYPE	attribute;
	rec_type	record;
	scan_attr_t		scan_next_attr;

	SLONG		rel_flags = 0, sys_flag = 0;
	bool		rel_flags_null = true, sys_flag_null = true;
	ISC_QUAD	view_blr = isc_blob_null, view_src = isc_blob_null,
				rel_desc = isc_blob_null, ext_desc = isc_blob_null;
	bool		view_blr_null = true, view_src_null = true, rel_desc_null = true,
				ext_desc_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$SECURITY_CLASS sec_class;*/
	char
	   sec_class[32];

#line 4600 "restore.epp"
	sec_class[0] = '\0';
	bool		sec_class_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$EXTERNAL_FILE ext_file_name;*/
	char
	   ext_file_name[254];

#line 4604 "restore.epp"
	ext_file_name[0] = '\0';
	bool		ext_file_name_null = true;

	TGBL tdgbl = GET_THREAD_DATA;

	// Pick up relation attributes 

	BURP_REL relation = (BURP_REL) BURP_alloc_zero (sizeof(burp_rel));
	relation->rel_next = tdgbl->relations;
	tdgbl->relations = relation;

	/*
	STORE (REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
		X IN RDB$RELATIONS
		X.RDB$SYSTEM_FLAG.NULL = TRUE;
		X.RDB$FLAGS.NULL = TRUE;
		X.RDB$SECURITY_CLASS.NULL = TRUE;
		X.RDB$VIEW_BLR.NULL = TRUE;
		X.RDB$VIEW_SOURCE.NULL = TRUE;
		X.RDB$DESCRIPTION.NULL = TRUE;
		X.RDB$RUNTIME.NULL = TRUE;
		X.RDB$EXTERNAL_DESCRIPTION.NULL = TRUE;
	*/

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			l = GET_TEXT(relation->rel_name);
			relation->rel_name_length = l;
			MISC_terminate (relation->rel_name, temp, l, sizeof(temp));
			BURP_verbose (167, temp, NULL, NULL, NULL, NULL);
			// msg 167 restoring relation %s 
			break;

		case att_relation_security_class:
			sec_class_null = false;
			GET_TEXT(sec_class);
			break;

		case att_relation_view_blr:
			view_blr_null = false;
			get_blr_blob(&view_blr, true);
			relation->rel_flags |= REL_view;
			break;

		case att_relation_view_source:
			view_src_null = false;
			get_misc_blob (&view_src, 1, !view_blr_null);
			break;

		case att_relation_view_source2:
			view_src_null = false;
			get_source_blob(&view_src, !view_blr_null);
			break;

		case att_relation_description:
			rel_desc_null = false;
			get_misc_blob(&rel_desc, 1, !view_blr_null);
			break;

		case att_relation_description2:
			rel_desc_null = false;
			get_source_blob(&rel_desc, !view_blr_null);
			break;

		case att_relation_flags:
			rel_flags_null = false;
			rel_flags = get_numeric();
			break;

		case att_relation_system_flag:
			sys_flag_null = false;
			sys_flag = get_numeric();
			break;

		case att_relation_ext_description:
			ext_desc_null = false;
			get_misc_blob(&ext_desc, 1, !view_blr_null);
			break;

		case att_relation_ext_description2:
			ext_desc_null = false;
			get_source_blob(&ext_desc, !view_blr_null);
			break;

		case att_relation_owner_name:
			GET_TEXT(relation->rel_owner);
			break;

		case att_relation_ext_file_name:
			ext_file_name_null = false;
			GET_TEXT(ext_file_name);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 relation 
			break;
		}
	}

	// If this is a view and there is a global transaction then use it 
	isc_tr_handle local_trans;
	if (view_blr_null || !tdgbl->global_trans)
		local_trans = gds_trans;
	else
		local_trans = tdgbl->global_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
		   REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
		X IN RDB$RELATIONS*/
	{
	
        if (!tdgbl->handles_get_relation_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_relation_req_handle1, (short) sizeof (isc_174), (char *) isc_174);
	if (tdgbl->handles_get_relation_req_handle1)
	   {
	   isc_175.isc_177 = isc_blob_null;
	   isc_175.isc_178 = isc_blob_null;
	   isc_175.isc_179 = isc_blob_null;
	   isc_175.isc_180 = isc_blob_null;
	   isc_175.isc_181 = isc_blob_null;
#line 4718 "restore.epp"

		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_175.isc_193 = sys_flag_null;
#line 4720 "restore.epp"
		/*X.RDB$FLAGS.NULL*/
		isc_175.isc_191 = rel_flags_null;
#line 4721 "restore.epp"
		/*X.RDB$SECURITY_CLASS.NULL*/
		isc_175.isc_190 = sec_class_null;
#line 4722 "restore.epp"
		/*X.RDB$VIEW_BLR.NULL*/
		isc_175.isc_189 = view_blr_null;
#line 4723 "restore.epp"
		/*X.RDB$VIEW_SOURCE.NULL*/
		isc_175.isc_188 = view_src_null;
#line 4724 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_175.isc_187 = rel_desc_null;
#line 4725 "restore.epp"
		/*X.RDB$RUNTIME.NULL*/
		isc_175.isc_186 = TRUE;
#line 4726 "restore.epp"
		/*X.RDB$EXTERNAL_DESCRIPTION.NULL*/
		isc_175.isc_185 = ext_desc_null;
#line 4727 "restore.epp"
		/*X.RDB$EXTERNAL_FILE.NULL*/
		isc_175.isc_183 = ext_file_name_null;
#line 4728 "restore.epp"

		/*X.RDB$SYSTEM_FLAG*/
		isc_175.isc_194 = (USHORT) sys_flag;
#line 4730 "restore.epp"
		/*X.RDB$FLAGS*/
		isc_175.isc_192 = (USHORT) rel_flags;
#line 4731 "restore.epp"
		/*X.RDB$VIEW_BLR*/
		isc_175.isc_181 = view_blr;
#line 4732 "restore.epp"
		/*X.RDB$VIEW_SOURCE*/
		isc_175.isc_180 = view_src;
#line 4733 "restore.epp"
		/*X.RDB$DESCRIPTION*/
		isc_175.isc_179 = rel_desc;
#line 4734 "restore.epp"
		/*X.RDB$EXTERNAL_DESCRIPTION*/
		isc_175.isc_177 = ext_desc;
#line 4735 "restore.epp"

		strcpy(/*X.RDB$SECURITY_CLASS*/
		       isc_175.isc_182, sec_class);
#line 4737 "restore.epp"
		strcpy(/*X.RDB$RELATION_NAME*/
		       isc_175.isc_176, relation->rel_name);
#line 4738 "restore.epp"
		strcpy(/*X.RDB$EXTERNAL_FILE*/
		       isc_175.isc_184, ext_file_name);
#line 4739 "restore.epp"

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_relation_req_handle1, (isc_handle*) &local_trans, (short) 0, (short) 380, &isc_175, (short) 0);
	   };
#line 4741 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 4742 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 4744 "restore.epp"

	// Eat up misc. records 
	BURP_FLD field = NULL;
	BURP_FLD* ptr = &relation->rel_fields;

	while (get_record(&record, tdgbl) != rec_data)
	{
		switch (record)
		{
		case rec_relation_end:
			if (tdgbl->gbl_sw_incremental)
			{
				BURP_verbose (170, relation->rel_name, NULL, NULL, NULL, NULL);
				// msg 170: committing metadata for relation %s 
				/*COMMIT*/
				{
				isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 4759 "restore.epp"
				// existing ON_ERROR continues past error, beck 
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 4761 "restore.epp"
					BURP_print (171, relation->rel_name, NULL, NULL, NULL, NULL);
					// msg 171: error committing metadata for relation %s 
					BURP_print_status (tdgbl->status_vector);
					/*ROLLBACK;*/
					{
					isc_rollback_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 4765 "restore.epp"
					/*ON_ERROR*/
					if (isc_status [1])
					   {
#line 4766 "restore.epp"
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
#line 4768 "restore.epp"
				/*END_ERROR;*/
				   }
				}
#line 4769 "restore.epp"
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_10);
				SQLCODE = isc_sqlcode (isc_status);
				}
#line 4770 "restore.epp"
				if (gds_status[1])
					/*EXEC SQL SET TRANSACTION;*/
					{
					isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_11);
					SQLCODE = isc_sqlcode (isc_status);
					}
#line 4772 "restore.epp"
			}
			return true;

		case rec_field:
			*ptr = field = get_field (relation);
			if (!field)
			return false;
			ptr = &field->fld_next;
			break;

		case rec_view:
			get_view (relation);
			break;

		default:
			BURP_error(43, true, isc_arg_number, (void*) record,
							0, NULL, 0, NULL, 0, NULL, 0, NULL);
			// msg 43 don't recognize record type %ld 
			break;
		}
	}

	// If we fall thru, there are data records to be gotten 
	/* we can get here only when restoring ancient gbak'ed files where rec_data
	   was once embedded into rec_relation ... otherwise, meta commit happens
	   when we see the first rec_relation_data */

	BURP_verbose (68, NULL, NULL, NULL, NULL, NULL);
	// msg 68 committing meta data 

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 4803 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 4804 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 4806 "restore.epp"

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_12);
	SQLCODE = isc_sqlcode (isc_status);
	}
#line 4808 "restore.epp"
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_13);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 4810 "restore.epp"

	get_data (relation);

	return true;
}

bool get_rel_constraint()
{
/**************************************
 *
 *	g e t _ r e l _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for relation constraints.
 *
 **************************************/
	ATT_TYPE		attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_rel_constraint_req_handle1)
		X IN RDB$RELATION_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_rel_constraint_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_rel_constraint_req_handle1, (short) sizeof (isc_160), (char *) isc_160);
	if (tdgbl->handles_get_rel_constraint_req_handle1)
	   {
#line 4835 "restore.epp"
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_161.isc_173 = TRUE;
#line 4836 "restore.epp"
		/*X.RDB$CONSTRAINT_TYPE.NULL*/
		isc_161.isc_172 = TRUE;
#line 4837 "restore.epp"
		/*X.RDB$RELATION_NAME.NULL*/
		isc_161.isc_171 = TRUE;
#line 4838 "restore.epp"
		/*X.RDB$DEFERRABLE.NULL*/
		isc_161.isc_170 = TRUE;
#line 4839 "restore.epp"
		/*X.RDB$INITIALLY_DEFERRED.NULL*/
		isc_161.isc_169 = TRUE;
#line 4840 "restore.epp"
		/*X.RDB$INDEX_NAME.NULL*/
		isc_161.isc_168 = TRUE;
#line 4841 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_rel_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_161.isc_173 = FALSE;
#line 4848 "restore.epp"
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_161.isc_164);
#line 4849 "restore.epp"
					break;

				case att_rel_constraint_type:
					/*X.RDB$CONSTRAINT_TYPE.NULL*/
					isc_161.isc_172 = FALSE;
#line 4853 "restore.epp"
					GET_TEXT(/*X.RDB$CONSTRAINT_TYPE*/
						 isc_161.isc_167);
#line 4854 "restore.epp"
					break;

				case att_rel_constraint_rel_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_161.isc_171 = FALSE;
#line 4858 "restore.epp"
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_161.isc_163);
#line 4859 "restore.epp"
					break;

				case att_rel_constraint_defer:
					/*X.RDB$DEFERRABLE.NULL*/
					isc_161.isc_170 = FALSE;
#line 4863 "restore.epp"
					GET_TEXT(/*X.RDB$DEFERRABLE*/
						 isc_161.isc_166);
#line 4864 "restore.epp"
					break;

				case att_rel_constraint_init:
					/*X.RDB$INITIALLY_DEFERRED.NULL*/
					isc_161.isc_169 = FALSE;
#line 4868 "restore.epp"
					GET_TEXT(/*X.RDB$INITIALLY_DEFERRED*/
						 isc_161.isc_165);
#line 4869 "restore.epp"
					break;

				case att_rel_constraint_index:
					/*X.RDB$INDEX_NAME.NULL*/
					isc_161.isc_168 = FALSE;
#line 4873 "restore.epp"
					GET_TEXT(/*X.RDB$INDEX_NAME*/
						 isc_161.isc_162);
#line 4874 "restore.epp"
					break;

				default:
					bad_attribute (scan_next_attr, attribute, 208);
					// msg 208 relation constraint 
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_rel_constraint_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 128, &isc_161, (short) 0);
	   };
#line 4883 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 4884 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 4886 "restore.epp"

	return true;
}

bool get_relation_data()
{
/**************************************
 *
 *	g e t _ r e l a t i o n _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Restore data for a relation.  This is called when the data is
 *	standing free from the relation definition.  We first need to
 *	find the relation named.  If we can't find it, give up.
 *
 **************************************/
	/*BASED_ON RDB$RELATIONS.RDB$RELATION_NAME name;*/
	char
	   name[32];

#line 4905 "restore.epp"
	ATT_TYPE	attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	burp_rel* relation = NULL;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			GET_TEXT(name);
			relation = find_relation (name);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 relation 
			break;
		}
	}

	if (!relation)
		BURP_error_redirect (NULL, 49, 0, 0);
	// msg 49 no relation name for data 

	// Eat up misc. records 
	rec_type record;
	get_record(&record, tdgbl);

	SLONG gen_id;
	
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), true)
	{
		switch (record)
		{
		case rec_relation_end:
			return true;

		case rec_data:
			record = get_data (relation);
			// get_data does a GET_RECORD 
			break;

		case rec_gen_id:
			gen_id = get_numeric();
			store_blr_gen_id (name, gen_id);
			get_record(&record, tdgbl);
			break;

		case rec_index:
			get_index (relation);
			get_record(&record, tdgbl);
			break;

		case rec_trigger:  // old style trigger 
			get_trigger_old (relation);
			get_record(&record, tdgbl);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 111);
			// msg 111 relation 
			get_record(&record, tdgbl);
			break;
		}
	}
        return true;
}

bool get_sql_roles()
{
/**************************************
 *
 *	g e t _ s q l _ r o l e s
 *
 **************************************
 *
 * Functional description
 *	Restore data for SQL roles
 *
 **************************************/
	ATT_TYPE        attribute;
	scan_attr_t		scan_next_attr;
	TEXT            temp[GDS_NAME_LEN];
	SSHORT          l;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_sql_roles_req_handle1)
		X IN RDB$ROLES*/
	{
	
        if (!tdgbl->handles_get_sql_roles_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_sql_roles_req_handle1, (short) sizeof (isc_154), (char *) isc_154);
	if (tdgbl->handles_get_sql_roles_req_handle1)
	   {
#line 4998 "restore.epp"

		/*X.RDB$ROLE_NAME.NULL*/
		isc_155.isc_159 = TRUE;
#line 5000 "restore.epp"
		/*X.RDB$OWNER_NAME.NULL*/
		isc_155.isc_158 = TRUE;
#line 5001 "restore.epp"
		skip_init(&scan_next_attr);

		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_role_name:
				/*X.RDB$ROLE_NAME.NULL*/
				isc_155.isc_159 = FALSE;
#line 5009 "restore.epp"
				l = GET_TEXT(/*X.RDB$ROLE_NAME*/
					     isc_155.isc_157);
#line 5010 "restore.epp"
				MISC_terminate (/*X.RDB$ROLE_NAME*/
						isc_155.isc_157, temp, l, sizeof(temp));
#line 5011 "restore.epp"
				/************************************************
				**
				** msg 251, restoring SQL role: %s
				**
				*************************************************/
				BURP_verbose (251, temp, NULL, NULL, NULL, NULL);
				break;

			case att_role_owner_name:
				/*X.RDB$OWNER_NAME.NULL*/
				isc_155.isc_158 = FALSE;
#line 5021 "restore.epp"
				GET_TEXT(/*X.RDB$OWNER_NAME*/
					 isc_155.isc_156);
#line 5022 "restore.epp"
				break;

			default:
				/*************************************************
				**
				** msg 250, Bad attribute for restoring SQL role
				**
				**************************************************/
				bad_attribute (scan_next_attr, attribute, 250);
				break;
			}
		}
	/*END_STORE*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_sql_roles_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 68, &isc_155, (short) 0);
	   };
#line 5035 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 5036 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 5038 "restore.epp"

	return true;
}

bool is_ascii_name (const TEXT *name, const SSHORT len)
{
/**************************************
 *
 *	i s _ a s c i i _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Check if the input text is valid ASCII name
 *
 **************************************/
	SSHORT i = 0;

	while (i < len &&
		   ( (name[i] >= 'A' && name[i] <= 'Z') ||
		     (name[i] >= '0' && name[i] <= '9') ||
			  name[i] == '_' || name[i] == '$' ) )
	{
		++i;
	}
	return (i == len);
}

bool get_security_class()
{
/**************************************
 *
 *	g e t _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	Restore a security class record including access control list.
 *
 **************************************/
	ATT_TYPE	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l = 0;
	scan_attr_t		scan_next_attr;
	bool		is_valid_sec_class = false;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_security_class_req_handle1)
		X IN RDB$SECURITY_CLASSES*/
	{
	
        if (!tdgbl->handles_get_security_class_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_security_class_req_handle1, (short) sizeof (isc_148), (char *) isc_148);
	if (tdgbl->handles_get_security_class_req_handle1)
	   {
	   isc_149.isc_150 = isc_blob_null;
	   isc_149.isc_152 = isc_blob_null;
#line 5088 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			/*X.RDB$DESCRIPTION.NULL*/
			isc_149.isc_153 = TRUE;
#line 5092 "restore.epp"
			switch (attribute)
			{
			case att_class_security_class:
				l = GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					     isc_149.isc_151);
#line 5096 "restore.epp"

				/* Bug fix for bug_no 7299: There was a V3 bug that inserted
				   garbage security class entry when doing GBAK. In order to
				   restore the V3 gbak file with this bad security entry to
				   V4 database. We should check if the security class is a
				   valid ASCII name. If not, skip this entry by setting
				   'is_valid_sec_class' to false.
				 */
				is_valid_sec_class = is_ascii_name(/*X.RDB$SECURITY_CLASS*/
								   isc_149.isc_151, l);
#line 5105 "restore.epp"
				if (!is_valid_sec_class)
				{
					MISC_terminate (/*X.RDB$SECURITY_CLASS*/
							isc_149.isc_151, temp, l, sizeof(temp));
#line 5108 "restore.epp"
					BURP_print (234, temp, NULL, NULL, NULL, NULL);
					// msg 234   Skipped bad security class entry: %s 
					break;
				}

				MISC_terminate (/*X.RDB$SECURITY_CLASS*/
						isc_149.isc_151, temp, l, sizeof(temp));
#line 5114 "restore.epp"
				BURP_verbose (125, temp, NULL, NULL, NULL, NULL);
					// msg 125   restoring security class %s 
				break;

			case att_class_acl:
				get_misc_blob (&/*X.RDB$ACL*/
						isc_149.isc_150, 0, false);
#line 5120 "restore.epp"
				break;

			case att_class_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_149.isc_153 = FALSE;
#line 5124 "restore.epp"
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_149.isc_152, 0, false);
#line 5125 "restore.epp"
				break;

			case att_class_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_149.isc_153 = FALSE;
#line 5129 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_149.isc_152, false);
#line 5130 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 131);
				// msg 131 security class 
				break;
			}
		}
		// If the security class is not valid ASCII name, don't store it to the 
		// database. Simply return from here and the entry is discarded.
		if (!is_valid_sec_class)
		{
			return true;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_security_class_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 50, &isc_149, (short) 0);
	   };
#line 5145 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 5146 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 5148 "restore.epp"

	return true;
}

void get_source_blob (
    ISC_QUAD	*blob_id,
    bool	glb_trans)
{
/**************************************
 *
 *	g e t _ s o u r c e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read source blob and query header attributes and copy data from
 *	input file to nice, shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	TGBL tdgbl = GET_THREAD_DATA;

	SLONG length = get_numeric();

	// Create new blob

	isc_handle blob = NULL;
	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	if (isc_create_blob (status_vector, &DB, &local_trans, &blob, blob_id))
	{
		BURP_error_redirect (status_vector, 37, 0, 0);
		// msg 37 isc_create_blob failed 
	}

	// Allocate blob buffer if static buffer is too short 
	UCHAR static_buffer[1024];
	UCHAR* buffer;
	if (!length || length <= (USHORT)(sizeof(static_buffer)) )
		buffer = static_buffer;
	else
		buffer = BURP_alloc (length);

	while (length)
	{
		UCHAR* p = buffer;
		while (*p++ = get(tdgbl))
			length--;
		--p;
		--length; // -- or ++ ??? p is decremented, will have to test.
		const USHORT seg_len = p - buffer;

		if (isc_put_segment (status_vector, &blob, seg_len,
			reinterpret_cast<const SCHAR*>(buffer)))
		{
			BURP_error_redirect (status_vector, 38, 0, 0);
			// msg 38 isc_put_segment failed 
		}
	}

	if (isc_close_blob (status_vector,  &blob))
		BURP_error_redirect (status_vector, 23, 0, 0);
		// msg 23 isc_close_blob failed 

	if (buffer != static_buffer)
		BURP_free (buffer);
}

USHORT get_text (
    TEXT	*text,
    ULONG	length)
{
/**************************************
 *
 *	g e t _ t e x t
 *
 **************************************
 *
 * Functional description
 *	Move a text attribute to a string and fill.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	const ULONG l = get(tdgbl);

	if (length <= l)
		BURP_error_redirect (NULL, 46, 0, 0);
		// msg 46 string truncated 

	if (l)
		text = (TEXT*) get_block(tdgbl, (UCHAR*) text, l);

	*text = 0;

	return (USHORT) l;
}

bool get_trigger_old (
    BURP_REL		relation)
{
/**************************************
 *
 *	g e t _ t r i g g e r _ o l d
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition for a relation.
 *
 **************************************/
	enum trig_t	type;
	ATT_TYPE	attribute;
	TEXT		name[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_trigger_old_req_handle1)
		X IN RDB$TRIGGERS*/
	{
	
        if (!tdgbl->handles_get_trigger_old_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_trigger_old_req_handle1, (short) sizeof (isc_135), (char *) isc_135);
	if (tdgbl->handles_get_trigger_old_req_handle1)
	   {
	   isc_136.isc_139 = isc_blob_null;
	   isc_136.isc_140 = isc_blob_null;
	   isc_136.isc_141 = isc_blob_null;
#line 5273 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_136.isc_147 = TRUE;
#line 5274 "restore.epp"
		/*X.RDB$TRIGGER_BLR.NULL*/
		isc_136.isc_146 = TRUE;
#line 5275 "restore.epp"
		/*X.RDB$TRIGGER_SOURCE.NULL*/
		isc_136.isc_145 = TRUE;
#line 5276 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_trig_type:
				type = (enum trig_t) get_numeric();
				break;

			case att_trig_blr:
				/*X.RDB$TRIGGER_BLR.NULL*/
				isc_136.isc_146 = FALSE;
#line 5287 "restore.epp"
				get_blr_blob (&/*X.RDB$TRIGGER_BLR*/
					       isc_136.isc_140, false);
#line 5288 "restore.epp"
				break;

			case att_trig_source:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_136.isc_145 = FALSE;
#line 5292 "restore.epp"
				get_misc_blob (&/*X.RDB$TRIGGER_SOURCE*/
						isc_136.isc_139, 1, false);
#line 5293 "restore.epp"
				break;

			case att_trig_source2:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_136.isc_145 = FALSE;
#line 5297 "restore.epp"
				get_source_blob (&/*X.RDB$TRIGGER_SOURCE*/
						  isc_136.isc_139, false);
#line 5298 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 134);
				// msg 134 trigger 
				break;
			}
		}

		// fill in rest of attributes unique to new trigger format 

		TEXT* p = /*X.RDB$TRIGGER_NAME*/
			  isc_136.isc_138;
#line 5310 "restore.epp"
		const TEXT* const end = p + 31;
		const TEXT* q = relation->rel_name;
		while (*q)
			*p++ = *q++;

		if (type == trig_pre_store)
		{
			/*X.RDB$TRIGGER_TYPE*/
			isc_136.isc_144 = TRIG_TYPE_PRE_STORE;
#line 5318 "restore.epp"
			q = "$STORE";
		}
		else if (type == trig_pre_modify)
		{
			/*X.RDB$TRIGGER_TYPE*/
			isc_136.isc_144 = TRIG_TYPE_PRE_MODIFY;
#line 5323 "restore.epp"
			q = "$MODIFY";
		}
		else if (type == trig_post_erase)
		{
			/*X.RDB$TRIGGER_TYPE*/
			isc_136.isc_144 = TRIG_TYPE_POST_ERASE;
#line 5328 "restore.epp"
			q = "$ERASE";
		}
		else
		{
			bad_attribute (scan_next_attr, attribute, 136);
			// msg 136 trigger type 
			return 0;
		}

		while (*q && p < end) {
			*p++ = *q++;
		}
		*p = 0;
		BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
				   isc_136.isc_138, NULL, NULL, NULL, NULL);
#line 5342 "restore.epp"
		// msg 126 restoring trigger %s 
		strncpy (/*X.RDB$RELATION_NAME*/
			 isc_136.isc_137, relation->rel_name, GDS_NAME_LEN);
#line 5344 "restore.epp"
		strcpy (name, /*X.RDB$TRIGGER_NAME*/
			      isc_136.isc_138);
#line 5345 "restore.epp"
		/*X.RDB$TRIGGER_SEQUENCE*/
		isc_136.isc_143 = TRIGGER_SEQUENCE_DEFAULT;
#line 5346 "restore.epp"
		/*X.RDB$SYSTEM_FLAG*/
		isc_136.isc_142 = 0;   // restore as vanilla user type 
#line 5347 "restore.epp"

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_trigger_old_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 100, &isc_136, (short) 0);
	   };
#line 5349 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 5350 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 5352 "restore.epp"

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 5356 "restore.epp"
		// existing ON_ERROR continues past error, beck 
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 5358 "restore.epp"
			BURP_print (94, name, NULL, NULL, NULL, NULL);
			// msg 94 trigger %s is invalid 
			BURP_print_status (tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 5362 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 5363 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 5365 "restore.epp"
		/*END_ERROR;*/
		   }
		}
#line 5366 "restore.epp"
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_14);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 5367 "restore.epp"
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_15);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 5369 "restore.epp"
	}

	return true;
}

bool get_trigger()
{
/**************************************
 *
 *	g e t _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition in rdb$triggers.
 *
 **************************************/
	ATT_TYPE	attribute;
	/*BASED_ON RDB$TRIGGERS.RDB$TRIGGER_NAME name;*/
	char
	   name[32];

#line 5388 "restore.epp"
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	isc_tr_handle local_trans =
		tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
		   REQUEST_HANDLE tdgbl->handles_get_trigger_req_handle1)
		X IN RDB$TRIGGERS*/
	{
	
        if (!tdgbl->handles_get_trigger_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_trigger_req_handle1, (short) sizeof (isc_118), (char *) isc_118);
	if (tdgbl->handles_get_trigger_req_handle1)
	   {
	   isc_119.isc_122 = isc_blob_null;
	   isc_119.isc_123 = isc_blob_null;
	   isc_119.isc_124 = isc_blob_null;
#line 5398 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_119.isc_134 = TRUE;
#line 5399 "restore.epp"
		/*X.RDB$TRIGGER_BLR.NULL*/
		isc_119.isc_133 = TRUE;
#line 5400 "restore.epp"
		/*X.RDB$TRIGGER_SOURCE.NULL*/
		isc_119.isc_132 = TRUE;
#line 5401 "restore.epp"
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_119.isc_130 = TRUE;
#line 5402 "restore.epp"
		/*X.RDB$FLAGS.NULL*/
		isc_119.isc_128 = TRUE;
#line 5403 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_trig_type:
				/*X.RDB$TRIGGER_TYPE*/
				isc_119.isc_127 = (USHORT) get_numeric();
#line 5410 "restore.epp"
				break;

			case att_trig_flags:
				/*X.RDB$FLAGS*/
				isc_119.isc_129 = (USHORT) get_numeric();
#line 5414 "restore.epp"
				/*X.RDB$FLAGS.NULL*/
				isc_119.isc_128 = FALSE;
#line 5415 "restore.epp"
				break;

			case att_trig_blr:
				/*X.RDB$TRIGGER_BLR.NULL*/
				isc_119.isc_133 = FALSE;
#line 5419 "restore.epp"
				get_blr_blob (&/*X.RDB$TRIGGER_BLR*/
					       isc_119.isc_123, true);
#line 5420 "restore.epp"
				break;

			case att_trig_source:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_119.isc_132 = FALSE;
#line 5424 "restore.epp"
				get_misc_blob (&/*X.RDB$TRIGGER_SOURCE*/
						isc_119.isc_122, 1, true);
#line 5425 "restore.epp"
				break;

			case att_trig_source2:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_119.isc_132 = FALSE;
#line 5429 "restore.epp"
				get_source_blob (&/*X.RDB$TRIGGER_SOURCE*/
						  isc_119.isc_122, true);
#line 5430 "restore.epp"
				break;

			case att_trig_name:
				GET_TEXT(/*X.RDB$TRIGGER_NAME*/
					 isc_119.isc_121);
#line 5434 "restore.epp"
				strcpy (name, /*X.RDB$TRIGGER_NAME*/
					      isc_119.isc_121);
#line 5435 "restore.epp"
				BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
						   isc_119.isc_121, NULL, NULL, NULL, NULL);
#line 5436 "restore.epp"
				// msg 126 restoring trigger %s 
				break;

			case att_trig_relation_name:
				GET_TEXT(/*X.RDB$RELATION_NAME*/
					 isc_119.isc_120);
#line 5441 "restore.epp"
				break;

			case att_trig_sequence:
				/*X.RDB$TRIGGER_SEQUENCE*/
				isc_119.isc_126 = (USHORT) get_numeric();
#line 5445 "restore.epp"
				break;

			case att_trig_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_119.isc_134 = FALSE;
#line 5449 "restore.epp"
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_119.isc_124, 1, true);
#line 5450 "restore.epp"
				break;

			case att_trig_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_119.isc_134 = FALSE;
#line 5454 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_119.isc_124, true);
#line 5455 "restore.epp"
				break;

			case att_trig_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_119.isc_131 = (USHORT) get_numeric();
#line 5459 "restore.epp"
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_119.isc_130 = FALSE;
#line 5460 "restore.epp"
				break;

			case att_trig_inactive:
				/*X.RDB$TRIGGER_INACTIVE*/
				isc_119.isc_125 = (USHORT) get_numeric();
#line 5464 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 134);
				// msg 134 trigger 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_trigger_req_handle1, (isc_handle*) &local_trans, (short) 0, (short) 108, &isc_119, (short) 0);
	   };
#line 5473 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 5474 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 5476 "restore.epp"

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 5480 "restore.epp"
		// existing ON_ERROR continues past error, beck 
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 5482 "restore.epp"
			BURP_print (94, name, NULL, NULL, NULL, NULL);
			// msg 94 trigger %s is invalid 
			BURP_print_status (tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 5486 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 5487 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 5489 "restore.epp"
		/*END_ERROR;*/
		   }
		}
#line 5490 "restore.epp"
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_16);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 5491 "restore.epp"
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_17);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 5493 "restore.epp"
	}

	return true;
}

bool get_trigger_message()
{
/**************************************
 *
 *	g e t _ t r i g g e r _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Get a trigger message text.
 *
 **************************************/
	ATT_TYPE	attribute;
	scan_attr_t		scan_next_attr;

	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$TRIGGER_NAME		name;*/
	char
	   name[32];

#line 5514 "restore.epp"
	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE_NUMBER	number;*/
	short
	   number;

#line 5515 "restore.epp"
	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE		message;*/
	char
	   message[79];

#line 5516 "restore.epp"

	TGBL tdgbl = GET_THREAD_DATA;

	bool flag = false;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_trigmsg_name:
			GET_TEXT(name);
			flag = false;
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle1)
				FIRST 1 X IN RDB$TRIGGERS WITH
				X.RDB$SYSTEM_FLAG EQ 1 AND X.RDB$TRIGGER_NAME EQ name*/
			{
                        if (!tdgbl->handles_get_trigger_message_req_handle1)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_trigger_message_req_handle1, (short) sizeof (isc_113), (char *) isc_113);
			isc_vtov ((char*)name, (char*)isc_114.isc_115, 32);
			if (tdgbl->handles_get_trigger_message_req_handle1)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_trigger_message_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_114, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_trigger_message_req_handle1, (short) 1, (short) 2, &isc_116, (short) 0);
			   if (!isc_116.isc_117 || isc_status [1]) break;
#line 5531 "restore.epp"
				flag = true;
			/*END_FOR;*/
			   }
			   };
#line 5533 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 5534 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 5536 "restore.epp"
			BURP_verbose (127, name, NULL, NULL, NULL, NULL);
			// msg 127 restoring trigger message for %s 
			break;

		case att_trigmsg_number:
			number = (USHORT) get_numeric();
			break;

		case att_trigmsg_text:
			GET_TEXT(message);
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 135);
			// msg 135  trigger message 
			break;
		}
	}

	if (flag)
		return true;

	isc_tr_handle local_trans =
		tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
		   REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle2)
		X IN RDB$TRIGGER_MESSAGES*/
	{
	
        if (!tdgbl->handles_get_trigger_message_req_handle2)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_trigger_message_req_handle2, (short) sizeof (isc_108), (char *) isc_108);
	if (tdgbl->handles_get_trigger_message_req_handle2)
	   {
#line 5564 "restore.epp"
		strcpy (/*X.RDB$TRIGGER_NAME*/
			isc_109.isc_110, name);
#line 5565 "restore.epp"
		/*X.RDB$MESSAGE_NUMBER*/
		isc_109.isc_111 = number;
#line 5566 "restore.epp"
		strcpy (/*X.RDB$MESSAGE*/
			isc_109.isc_112, message);
#line 5567 "restore.epp"
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_trigger_message_req_handle2, (isc_handle*) &local_trans, (short) 0, (short) 113, &isc_109, (short) 0);
	   };
#line 5568 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 5569 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 5571 "restore.epp"

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 5575 "restore.epp"
		// existing ON_ERROR continues past error, beck 
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 5577 "restore.epp"
			BURP_print (94, name, NULL, NULL, NULL, NULL);
			// msg 94 trigger %s is invalid 
			BURP_print_status (tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 5581 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 5582 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 5584 "restore.epp"
		/*END_ERROR;*/
		   }
		}
#line 5585 "restore.epp"
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_18);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 5586 "restore.epp"
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_19);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 5588 "restore.epp"
	}

	return true;
}

bool get_type()
{
/**************************************
 *
 *	g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$types.
 *
 **************************************/
	ATT_TYPE	attribute;
	ULONG		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_type_req_handle1)
		X IN RDB$TYPES*/
	{
	
        if (!tdgbl->handles_get_type_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_type_req_handle1, (short) sizeof (isc_99), (char *) isc_99);
	if (tdgbl->handles_get_type_req_handle1)
	   {
	   isc_100.isc_103 = isc_blob_null;
#line 5614 "restore.epp"
		/*X.RDB$DESCRIPTION.NULL*/
		isc_100.isc_107 = TRUE;
#line 5615 "restore.epp"
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_100.isc_105 = TRUE;
#line 5616 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_type_name:
				l = GET_TEXT(/*X.RDB$TYPE_NAME*/
					     isc_100.isc_102);
#line 5623 "restore.epp"
				break;

			case att_type_type:
				/*X.RDB$TYPE*/
				isc_100.isc_104 = (USHORT) get_numeric();
#line 5627 "restore.epp"
				break;

			case att_type_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_100.isc_101);
#line 5631 "restore.epp"
				break;

			case att_type_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_100.isc_107 = FALSE;
#line 5635 "restore.epp"
				get_misc_blob (&/*X.RDB$DESCRIPTION*/
						isc_100.isc_103, 1, false);
#line 5636 "restore.epp"
				break;

			case att_type_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_100.isc_107 = FALSE;
#line 5640 "restore.epp"
				get_source_blob (&/*X.RDB$DESCRIPTION*/
						  isc_100.isc_103, false);
#line 5641 "restore.epp"
				break;

			case att_type_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_100.isc_106 = (USHORT) get_numeric();
#line 5645 "restore.epp"
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_100.isc_105 = FALSE;
#line 5646 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 136);
				// msg 136 trigger type 
				break;
			}
		}

		MISC_terminate (/*X.RDB$TYPE_NAME*/
				isc_100.isc_102, temp, l, sizeof(temp));
#line 5656 "restore.epp"
		BURP_verbose (128, temp, /*X.RDB$FIELD_NAME*/
					 isc_100.isc_101, NULL, NULL, NULL);
#line 5657 "restore.epp"
		// msg 128  restoring type %s for field %s 

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_type_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 80, &isc_100, (short) 0);
	   };
#line 5660 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 5661 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 5663 "restore.epp"

	return true;
}

bool get_user_privilege()
{
/**************************************
 *
 *	g e t _ u s e r _ p r i v i l e g e
 *
 **************************************
 *
 * Functional description
 *	Get a user privilege.
 *	Get next interesting user privilege.
 *
 **************************************/
	ATT_TYPE	attribute;
	scan_attr_t		scan_next_attr;
	USHORT		flags = 0;

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER		user;*/
	char
	   user[32];

#line 5685 "restore.epp"
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANTOR	grantor;*/
	char
	   grantor[32];

#line 5686 "restore.epp"
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$PRIVILEGE	privilege;*/
	char
	   privilege[7];

#line 5687 "restore.epp"
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANT_OPTION	grant_option;*/
	short
	   grant_option;

#line 5688 "restore.epp"
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$RELATION_NAME	relation_name;*/
	char
	   relation_name[32];

#line 5689 "restore.epp"
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$FIELD_NAME	field_name;*/
	char
	   field_name[32];

#line 5690 "restore.epp"
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER_TYPE	user_type;*/
	short
	   user_type;

#line 5691 "restore.epp"
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$OBJECT_TYPE	object_type;*/
	short
	   object_type;

#line 5692 "restore.epp"

	TGBL tdgbl = GET_THREAD_DATA;
	user_type = obj_user;
	object_type = obj_relation;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_priv_user:
			// default USER_TYPE to USER 
			flags |= USER_PRIV_USER;
			GET_TEXT(user);
			BURP_verbose (123, user, NULL, NULL, NULL, NULL);
			// msg 123 restoring privilege for user %s 
			break;

		case att_priv_grantor:
			flags |= USER_PRIV_GRANTOR;
			GET_TEXT(grantor);
			break;

		case att_priv_privilege:
			flags |= USER_PRIV_PRIVILEGE;
			GET_TEXT(privilege);
			break;

		case att_priv_grant_option:
			flags |= USER_PRIV_GRANT_OPTION;
			grant_option = (USHORT) get_numeric();
			break;

		case att_priv_object_name:
			flags |= USER_PRIV_OBJECT_NAME;
			// default OBJECT_TYPE to RELATION 
			GET_TEXT(relation_name);
			break;

		case att_priv_field_name:
			flags |= USER_PRIV_FIELD_NAME;
			GET_TEXT(field_name);
			break;

		case att_priv_user_type:
			flags |= USER_PRIV_USER_TYPE;
			user_type = (USHORT) get_numeric();
			break;

		case att_priv_obj_type:
			flags |= USER_PRIV_OBJECT_TYPE;
			object_type = (USHORT) get_numeric();
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 105);
			// msg 105 privilege 
			break;
		}
	}

	// Check if object exists 
	isc_tr_handle	local_trans = NULL;
	bool exists = false;
	switch (object_type)
	{
	case obj_procedure:
		{
		for (BURP_PRC proc = tdgbl->procedures; proc; proc = proc->prc_next)
			if (!strcmp(proc->prc_name, relation_name))
			{
				exists = true;
				local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
				break;
			}
		}
		break;

	case obj_relation:
		{
		for (BURP_REL rel = tdgbl->relations; rel; rel = rel->rel_next)
			if (!strcmp(rel->rel_name, relation_name))
			{
				exists = true;
				if (rel->rel_flags & REL_view)
					local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
			break;
			}
		}
		break;

		default:
			exists = true;
			break;
	}

	if (exists)
	{
		if (!local_trans)
			local_trans = gds_trans;

		/*STORE (TRANSACTION_HANDLE local_trans
		   REQUEST_HANDLE tdgbl->handles_get_user_privilege_req_handle1) X
		IN RDB$USER_PRIVILEGES*/
		{
		
                if (!tdgbl->handles_get_user_privilege_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_user_privilege_req_handle1, (short) sizeof (isc_85), (char *) isc_85);
		if (tdgbl->handles_get_user_privilege_req_handle1)
		   {
#line 5796 "restore.epp"

			/*X.RDB$FIELD_NAME.NULL*/
			isc_86.isc_97 = TRUE;
#line 5798 "restore.epp"
			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_86.isc_95 = TRUE;
#line 5799 "restore.epp"

			if (flags & USER_PRIV_USER)
				strcpy (/*X.RDB$USER*/
					isc_86.isc_89, user);
#line 5802 "restore.epp"

			if (flags & USER_PRIV_GRANTOR)
				strcpy (/*X.RDB$GRANTOR*/
					isc_86.isc_88, grantor);
#line 5805 "restore.epp"

			if (flags & USER_PRIV_PRIVILEGE)
				strcpy (/*X.RDB$PRIVILEGE*/
					isc_86.isc_98, privilege);
#line 5808 "restore.epp"

			if (flags & USER_PRIV_GRANT_OPTION)
			{
				/*X.RDB$GRANT_OPTION*/
				isc_86.isc_94 = grant_option;
#line 5812 "restore.epp"
					if (grant_option == 0)
						/*X.RDB$GRANT_OPTION.NULL*/
						isc_86.isc_93 = TRUE;
#line 5814 "restore.epp"
					else
						/*X.RDB$GRANT_OPTION.NULL*/
						isc_86.isc_93 = FALSE;
#line 5816 "restore.epp"
			}

			if (flags & USER_PRIV_OBJECT_NAME)
				strcpy (/*X.RDB$RELATION_NAME*/
					isc_86.isc_87, relation_name);
#line 5820 "restore.epp"

			if (flags & USER_PRIV_FIELD_NAME)
			{
				/*X.RDB$FIELD_NAME.NULL*/
				isc_86.isc_97 = FALSE;
#line 5824 "restore.epp"
				strcpy (/*X.RDB$FIELD_NAME*/
					isc_86.isc_90, field_name);
#line 5825 "restore.epp"
			}

			   /*
				* USER_TYPE & OBJECT_TYPE are fields that did not exist before
				* V4.0. So, we have to reconstruct them and initialize them to
				* reasonable values. If they existed before then user_type and
				* object_type contain the proper values. If they didn't exist
				* then user_type and object_type contain the reasonable default
				* values.
				*/

			/*X.RDB$USER_TYPE.NULL*/
			isc_86.isc_91 = FALSE;
#line 5837 "restore.epp"
			/*X.RDB$USER_TYPE*/
			isc_86.isc_92 = user_type;
#line 5838 "restore.epp"

			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_86.isc_95 = FALSE;
#line 5840 "restore.epp"
			/*X.RDB$OBJECT_TYPE*/
			isc_86.isc_96 = object_type;
#line 5841 "restore.epp"


	   /*
		* If OBJECT_TYPE didn't exist before and we have a field level
		* user privileges, then use obj_field instead.
		*
		* NOTE: Scanning the V4.0 code base, obj_field has never been
		*       used at all. The following code should be uncommented
		*       in case we ever introduce obj_field to the picture.
		*/
/***********************************************************
			if ( !(flags & USER_PRIV_OBJECT_TYPE) )
			{
				if ( flags & USER_PRIV_FIELD_NAME )
				{
					X.RDB$OBJECT_TYPE = obj_field;
				}
			}
***********************************************************/

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_user_privilege_req_handle1, (isc_handle*) &local_trans, (short) 0, (short) 149, &isc_86, (short) 0);
		   };
#line 5862 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 5863 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 5865 "restore.epp"
	}

	return true;
}

bool get_view (BURP_REL		relation)
{
/**************************************
 *
 *	g e t _ v i e w
 *
 **************************************
 *
 * Functional description
 *	Store a record in RDB$VIEW_RELATIONS.
 *
 **************************************/
	ATT_TYPE	attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	// If there is a global transaction then use it 

	isc_tr_handle local_trans =
		tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
		   REQUEST_HANDLE tdgbl->handles_get_view_req_handle1)
		X IN RDB$VIEW_RELATIONS*/
	{
	
        if (!tdgbl->handles_get_view_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_view_req_handle1, (short) sizeof (isc_79), (char *) isc_79);
	if (tdgbl->handles_get_view_req_handle1)
	   {
#line 5895 "restore.epp"
		strcpy (/*X.RDB$VIEW_NAME*/
			isc_80.isc_83, relation->rel_name);
#line 5896 "restore.epp"
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_view_relation_name:
				GET_TEXT(/*X.RDB$RELATION_NAME*/
					 isc_80.isc_82);
#line 5903 "restore.epp"
				break;

			case att_view_context_name:
				GET_TEXT(/*X.RDB$CONTEXT_NAME*/
					 isc_80.isc_81);
#line 5907 "restore.epp"
				break;

			case att_view_context_id:
				/*X.RDB$VIEW_CONTEXT*/
				isc_80.isc_84 = (USHORT) get_numeric();
#line 5911 "restore.epp"
				break;

			default:
				bad_attribute (scan_next_attr, attribute, 140);
				// msg 140 view 
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_view_req_handle1, (isc_handle*) &local_trans, (short) 0, (short) 98, &isc_80, (short) 0);
	   };
#line 5920 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 5921 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 5923 "restore.epp"

	return true;
}

void ignore_array (BURP_REL		relation)
{
/**************************************
 *
 *	i g n o r e _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Ignore data from input file, like a
 *	dummy get_array().
 *
 **************************************/
	BURP_FLD		field;
	ATT_TYPE	attribute;
	SLONG		*range, *end_ranges;
	USHORT		field_number;
	//LSTRING		xdr_buffer;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	// don't free something you don't allocate 
	//xdr_buffer.lstr_allocated = 0;

	// Pick up attributes 

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_numeric();
			for (field = relation->rel_fields; field; field = field->fld_next) {
				if (field->fld_number == field_number)
					break;
			}
			if (!field)
				BURP_error_redirect (NULL, 36, 0, 0);
				// msg 36 Can't find field for blob 
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT)get_numeric();
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			for (range = field->fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array 
				else
					range[0] = get_numeric();
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array 
				else
					range[1] = get_numeric();
			}
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 58);
			// msg 58 array 
			break;
		}
	}

	SLONG length = get(tdgbl);
	length |= get(tdgbl) << 8;
	length |= get(tdgbl) << 16;
	length |= get(tdgbl) << 24;

	SLONG lcount;
	if (tdgbl->gbl_sw_transportable)
	{
		if (get_attribute(&attribute, tdgbl) != att_xdr_array)
			BURP_error_redirect (NULL, 55, 0, 0);
			// msg 55 Expected XDR record length 
		else
		{
			lcount = get(tdgbl);
			lcount |= get(tdgbl) << 8;
			lcount |= get(tdgbl) << 16;
			lcount |= get(tdgbl) << 24;
			//xdr_buffer.lstr_length = xdr_buffer.lstr_allocated = lcount;
		}
	}
	else
	{
		lcount = length;
	}

	if (lcount)
		get_skip(tdgbl, lcount);
}

void ignore_blob()
{
/**************************************
 *
 *	i g n o r e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Skip over blob data records.
 *
 **************************************/
	ATT_TYPE	attribute;
	scan_attr_t		scan_next_attr;

	TGBL tdgbl = GET_THREAD_DATA;

	// Pick up attributes 

	SLONG segments = 0;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			get_numeric();
			break;

		case att_blob_max_segment:
			get_numeric();
			break;

		case att_blob_number_segments:
			segments = get_numeric();
			break;

		case att_blob_type:
			get_numeric();
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 64);
			// msg 64 blob 
			break;
		}
	}

	// Eat up blob segments 

	while (--segments >= 0)
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
			get_skip(tdgbl, length);
	}
}

rec_type ignore_data (BURP_REL		relation)
{
/**************************************
 *
 *	i g n o r e _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Ignore data records for a relation.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	ULONG records = 0;
	rec_type record;
		
	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39, 0, 0);
			// msg 39 expected record length 
		USHORT l = (USHORT) get_numeric();
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55, 0, 0);
				// msg 55 Expected XDR record length 
			else
				l = (USHORT) get_numeric();
		}
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41, 0, 0);
			// msg 41 expected data attribute 
		if (l) {
			if (tdgbl->gbl_sw_compress)
			{
				UCHAR* buffer = (UCHAR*) BURP_alloc (l);
				decompress (buffer, l);
				BURP_free (buffer);
			}
			else
				get_skip(tdgbl, l);
		}
		++records;
		
		while (get_record(&record, tdgbl))
		{
			if (record == rec_blob)
				ignore_blob();
			else if (record == rec_array)
				ignore_array (relation);
			else
				break;
		}
		if (record != rec_data)
			break;
	}

	BURP_verbose (106, (void*) records, NULL, NULL, NULL, NULL);
	// msg 106 %ld records ignored 

	return record;
}

void realign(UCHAR* buffer,
			 const burp_rel* relation)
{
/**************************************
 *
 *	r e a l i g n
 *
 **************************************
 *
 * Functional description
 *	Miserable input record is misaligned.
 *	Shuffle fields around.  N.B. this one
 *	only works if the old buffer is longer
 *	than the new.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;
	UCHAR* p;
	const UCHAR* q;

	for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		p = buffer + field->fld_offset;
		q = buffer + field->fld_old_offset;
		USHORT l = field->fld_length;

		// CVC: This code assumes fld_offset < fld_old_offset,
		// why not use memmove() instead?

		// Beware of overlaps here - don't use memcpy 
		while (l--) {
			*p++ = *q++;
		}

		if (field->fld_type == blr_varying)
		{
			*p++ = *q++;
			*p++ = *q++;
		}
	}

	// If this is format version 2, build fields for null flags 

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			p = buffer + FB_ALIGN(p - buffer, sizeof(SSHORT));
			q = buffer + FB_ALIGN(q - buffer, sizeof(SSHORT));
			*p++ = *q++;
			*p++ = *q++;
		}
	}
}

USHORT recompute_length (burp_rel* relation)
{
/**************************************
 *
 *	r e c o m p u t e _ l e n g t h
 *
 **************************************
 *
 * Functional description
 *	Recompute length of a record using an old
 *	alignment if there is one.  At the moment,
 *	only SPARC has one.
 *
 **************************************/

#ifdef sparc
	ULONG	offset = 0; // there was garbage, possibly nobody uses sparc define?
	const SSHORT* alignments = old_sparcs;

	TGBL tdgbl = GET_THREAD_DATA;

	for (burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		ULONG length = field->fld_length;
		// ULONG alignment = 4; useless, see assignment below

		// arrays are of various fld_types but are really blobs 

		ULONG dtype = field->fld_type;

		if (field->fld_flags & FLD_array)
		{
			dtype = blr_blob;
			length = 8;
		}

		const ULONG alignment = alignments[gds_cvt_blr_dtype[field->fld_type]];
		if (dtype == blr_varying)
			length += sizeof(USHORT);

		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_old_offset = offset;
		offset += length;
	}

	// If this is format version 2, build fields for null flags 

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			offset += sizeof(SSHORT);
		}
	}

	return offset;
#else
	return 0;
#endif
}

bool restore (const TEXT* file_name,
			  const TEXT* database_name)
{
/**************************************
 *
 *	r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Perform the body of restore.
 *
 **************************************/
	rec_type	record;
	ATT_TYPE	attribute;
	isc_req_handle  req_handle1 = NULL, req_handle2 = NULL, req_handle3 = NULL,
					req_handle5 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	// Read burp record first 

	MVOL_init_read ((UCHAR*) tdgbl->gbl_database_file_name, (UCHAR*) file_name,
		&tdgbl->RESTORE_format, &tdgbl->io_cnt, &tdgbl->io_ptr);

	if (tdgbl->gbl_sw_transportable)
		BURP_verbose (133, NULL, NULL, NULL, NULL, NULL);
		// msg 133 transportable backup -- data in XDR format 
	if (tdgbl->gbl_sw_compress)
		BURP_verbose (61, NULL, NULL, NULL, NULL, NULL);
		// msg 61 backup file is compressed 


	// restore only from those backup files created by current or previous GBAK

	if (tdgbl->RESTORE_format < 1 || tdgbl->RESTORE_format > ATT_BACKUP_FORMAT)
	{
		BURP_error(44, true, isc_arg_number, (void*)(ULONG)tdgbl->RESTORE_format,
					0, NULL, 0, NULL, 0, NULL, 0, NULL);
		// msg 44 Expected backup version 1, 2, or 3.  Found %ld 
	}

	create_database (database_name);

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_20);
	SQLCODE = isc_sqlcode (isc_status);
	}
#line 6319 "restore.epp"
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_21);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 6321 "restore.epp"

	/* For V4.0, start a read commited transaction.  This will be used
	 * to create blobs for global fields and update the record in the
	 * RDB$FIELDS table.
	 */

	/*EXEC SQL SET TRANSACTION NAME tdgbl->global_trans ISOLATION LEVEL READ COMMITTED;*/
	{
	isc_start_transaction (isc_status, (isc_handle*) &tdgbl->global_trans, (short) 1, &DB, (short) 5, isc_tpb_22);
	SQLCODE = isc_sqlcode (isc_status);
	}
#line 6328 "restore.epp"

	USHORT db_version = check_db_version();
	if (db_version < DB_VERSION_CURRENT)
	{
		BURP_error(51, true, isc_arg_number, (void*) (ULONG) db_version,
					0, NULL, 0, NULL, 0, NULL, 0, NULL);
		// msg 51 database format %ld is too old to restore to 
	}

	BURP_verbose (129, NULL, NULL, NULL, NULL, NULL);
	// msg 129 started transaction 

	while (get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_database_security_class:
			/* Instead of updating the security class in RDB$DATABASE,
			   just store the value in tdgbl. It will be updated at
			   the very end to prevent security class validation
			   failures during change table ownership operation   */
			GET_TEXT(tdgbl->database_security_class);
			break;

		case att_database_description:
		case att_database_description2:
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_71), (char *) isc_71);
			if (req_handle2)
                           isc_start_request (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 0, (short) 10, &isc_72, (short) 0);
			   if (!isc_72.isc_74 || isc_status [1]) break;
#line 6356 "restore.epp"
				/*MODIFY X USING*/
				{
#line 6357 "restore.epp"
					if (attribute == att_database_description2)
						get_source_blob (&/*X.RDB$DESCRIPTION*/
								  isc_72.isc_73, false);
#line 6359 "restore.epp"
					else
						get_misc_blob (&/*X.RDB$DESCRIPTION*/
								isc_72.isc_73, 1, false);
#line 6361 "restore.epp"
				/*END_MODIFY;*/
				isc_75.isc_76 = isc_72.isc_73;
                                isc_send (isc_status, (isc_handle*) &req_handle2, (short) 1, (short) 8, &isc_75, (short) 0);;
#line 6362 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 6363 "restore.epp"
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 6365 "restore.epp"
			/*END_FOR;*/
                           isc_send (isc_status, (isc_handle*) &req_handle2, (short) 2, (short) 2, &isc_77, (short) 0);
			   }
			   };
#line 6366 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 6367 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 6369 "restore.epp"
			break;

		case att_database_dfl_charset:
			/*FOR (REQUEST_HANDLE req_handle3)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle3)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle3, (short) sizeof (isc_63), (char *) isc_63);
			if (req_handle3)
                           isc_start_request (isc_status, (isc_handle*) &req_handle3, (isc_handle*) &gds_trans, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle3, (short) 0, (short) 34, &isc_64, (short) 0);
			   if (!isc_64.isc_66 || isc_status [1]) break;
#line 6374 "restore.epp"
				/*MODIFY X USING*/
				{
#line 6375 "restore.epp"
				GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
					 isc_64.isc_65);
#line 6376 "restore.epp"
				/*END_MODIFY;*/
				isc_ftof (isc_64.isc_65, 32, isc_67.isc_68, 32);
                                isc_send (isc_status, (isc_handle*) &req_handle3, (short) 1, (short) 32, &isc_67, (short) 0);;
#line 6377 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 6378 "restore.epp"
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 6380 "restore.epp"
			/*END_FOR;*/
                           isc_send (isc_status, (isc_handle*) &req_handle3, (short) 2, (short) 2, &isc_69, (short) 0);
			   }
			   };
#line 6381 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 6382 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 6384 "restore.epp"
			break;

		default:
			{
			SSHORT l = get(tdgbl);
			if (l)
				get_skip(tdgbl, l);
			break;
			}
		}
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);

	// If this should be a multi-file database, add the files

	if (tdgbl->gbl_sw_files && tdgbl->gbl_sw_files->fil_next)
		add_files ((UCHAR*) database_name);

	// Get global fields and relations

	bool flag_norel = true;	// To fix bug 10098
	bool flag = false;

	while (get_record(&record, tdgbl) != rec_end)
	{
		switch (record)
		{
		case rec_charset:
			if (!get_character_set())
				return false;
			flag = true;
			break;

		case rec_collation:
			if (!get_collation())
				return false;
			flag = true;
			break;

		case rec_chk_constraint:
			if (!get_chk_constraint())
				return false;
			flag = true;
			break;

		case rec_global_field:
			if (!get_global_field())
				return false;
			flag = true;
			break;

		case rec_field_dimensions:
			if (!get_field_dimensions())
				return false;
			flag = true;
			break;

		case rec_relation:
			if (!get_relation())
				return false;
			flag = true;
			flag_norel = false;
			break;

		case rec_ref_constraint:
			if (!get_ref_constraint())
				return false;
			flag = true;
			break;

		case rec_rel_constraint:
			if (!get_rel_constraint())
				return false;
			flag = true;
			break;

		case rec_function:
			if (!get_function())
				return false;
			flag = true;
			break;

		case rec_procedure:
			if (!get_procedure())
				return false;
			flag = true;
			break;

		case rec_exception:
			if (!get_exception())
				return false;
			flag = true;
			break;

		case rec_system_type:  /* rdb$types */
			if (!get_type())
				return false;
			flag = true;
			break;

		case rec_filter:  /* rdb$filters */
			if (!get_filter())
				return false;
			flag = true;
			break;

		case rec_generator:
			if (!get_generator())
				return false;
			flag = true;
			break;

		case rec_relation_data:
			if (flag)
			{
				BURP_verbose (68, NULL, NULL, NULL, NULL, NULL);
				// msg 68 committing meta data 
				/*COMMIT;*/
				{
				isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 6505 "restore.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 6506 "restore.epp"
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
#line 6508 "restore.epp"
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_23);
				SQLCODE = isc_sqlcode (isc_status);
				}
#line 6509 "restore.epp"
					if (gds_status[1])
						/*EXEC SQL SET TRANSACTION;*/
						{
						isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_24);
						SQLCODE = isc_sqlcode (isc_status);
						}
#line 6511 "restore.epp"
				flag = false;
			}
			if (!get_relation_data())
				return false;
			break;

		case rec_trigger:  // new trigger type 
			if (!get_trigger())
				return false;
			flag = true;
			break;

		case rec_trigger_message:
			if (!get_trigger_message())
				return false;
			flag = true;
			break;

		case rec_user_privilege:
			if (!get_user_privilege())
				return false;
			flag = true;
			break;

		case rec_security_class:
			if (!get_security_class())
				return false;
			flag = true;
			break;

		case rec_files:
			if (!get_files())
				return false;
			flag = true;
			break;

		case rec_sql_roles:
			if (!get_sql_roles())
				return false;
			flag = true;
			break;

		default:
			BURP_error(43, true, isc_arg_number, (void*) record,
						0, NULL, 0, NULL, 0, NULL, 0, NULL);
			// msg 43 don't recognize record type %ld 
			break;
		}
	}

	/* This piece of code is to fix bug 10098: restore of database with
	only domains and no relations aborts with the message ERROR: deadlock
	This is because insertion of domains into RDB$FIELDS is happening in
	the default transaction, whereas updation of RDB$FIELDS to add
	constraints to the domains is done in tdgbl->global_trans. In case of
	no relations, no COMMIT of default transaction occurs till this point
	because of which rows in RDB$FIELDS for domains are still locked by
	default transaction. The below code COMMITs the default transaction
	in that particular situation */

	if (flag_norel)
	{
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 6574 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 6575 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 6577 "restore.epp"
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_25);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 6578 "restore.epp"
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_26);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 6580 "restore.epp"
	}

	// put validation clauses for global fields 

	update_global_field ();

	// Purge shadow metadata if necessary 

	if (tdgbl->gbl_sw_kill)

		/*FOR (REQUEST_HANDLE req_handle5)
			FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER NOT MISSING
			AND FIL.RDB$SHADOW_NUMBER NE 0*/
		{
                if (!req_handle5)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle5, (short) sizeof (isc_56), (char *) isc_56);
		if (req_handle5)
                   isc_start_request (isc_status, (isc_handle*) &req_handle5, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle5, (short) 0, (short) 2, &isc_57, (short) 0);
		   if (!isc_57.isc_58 || isc_status [1]) break;
#line 6593 "restore.epp"
		/*ERASE FIL;*/
		{
                isc_send (isc_status, (isc_handle*) &req_handle5, (short) 1, (short) 2, &isc_59, (short) 0);
#line 6594 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 6595 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 6597 "restore.epp"
		/*END_FOR;*/
                   isc_send (isc_status, (isc_handle*) &req_handle5, (short) 2, (short) 2, &isc_61, (short) 0);
		   }
		   };
#line 6598 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 6599 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 6601 "restore.epp"

	MISC_release_request_silent(req_handle5);

	return true;
}

void restore_security_class (const TEXT	*owner_nm,
							 const TEXT	*sec_class_nm)
{
/**************************************
 *
 *	r e s t o r e _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	restore the ownership of the relation in the ACL list
 *
 **************************************/
	isc_req_handle  req_handle2 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;
	isc_tr_handle local_trans = gds_trans;

	/*FOR (REQUEST_HANDLE req_handle2)
		X IN RDB$SECURITY_CLASSES WITH X.RDB$SECURITY_CLASS EQ sec_class_nm*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_46), (char *) isc_46);
	isc_vtov ((char*)sec_class_nm, (char*)isc_47.isc_48, 32);
	if (req_handle2)
           isc_start_and_send (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_47, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 1, (short) 10, &isc_49, (short) 0);
	   if (!isc_49.isc_51 || isc_status [1]) break;
#line 6627 "restore.epp"

		ISC_QUAD new_blob_id;
		new_blob_id.gds_quad_high = 0;
		new_blob_id.gds_quad_low  = 0;
		get_acl (owner_nm, &/*X.RDB$ACL*/
				    isc_49.isc_50, &new_blob_id);
#line 6632 "restore.epp"

		/*MODIFY X*/
		{;
#line 6634 "restore.epp"
			MOVE_FAST (&new_blob_id, &/*X.RDB$ACL*/
						  isc_49.isc_50, sizeof(ISC_QUAD));
#line 6635 "restore.epp"
		/*END_MODIFY;*/
		isc_52.isc_53 = isc_49.isc_50;
                isc_send (isc_status, (isc_handle*) &req_handle2, (short) 2, (short) 8, &isc_52, (short) 0);;
#line 6636 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 6637 "restore.epp"
			MISC_release_request_silent(req_handle2);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 6640 "restore.epp"

	/*END_FOR;*/
           isc_send (isc_status, (isc_handle*) &req_handle2, (short) 3, (short) 2, &isc_54, (short) 0);
	   }
	   };
#line 6642 "restore.epp"

	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 6644 "restore.epp"
		MISC_release_request_silent(req_handle2);
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 6647 "restore.epp"

	MISC_release_request_silent(req_handle2);
}


void store_blr_gen_id (const TEXT*	gen_name,	// TEXT GDS_NAME[GDS_NAME_LEN]
					   SINT64	value)
{
/**************************************
 *
 *	s t o r e _ b l r _ g e n _ i d
 *
 **************************************
 *
 * Functional description
 *	Store the blr_gen_id for the relation.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
		X IN RDB$GENERATORS*/
	{
	
        if (!tdgbl->handles_store_blr_gen_id_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof (isc_43), (char *) isc_43);
	if (tdgbl->handles_store_blr_gen_id_req_handle1)
	   {
#line 6669 "restore.epp"
		strcpy (/*X.RDB$GENERATOR_NAME*/
			isc_44.isc_45, gen_name);
#line 6670 "restore.epp"
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_store_blr_gen_id_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_44, (short) 0);
	   };
#line 6671 "restore.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 6672 "restore.epp"
		general_on_error ();
	/*END_ERROR;*/
	   }
	}
#line 6674 "restore.epp"

	if (!value)
	{
#pragma FB_COMPILER_MESSAGE("BRS: casting SINT64 to SLONG")
		BURP_verbose (185, gen_name, (void*) (SLONG) value, NULL, NULL, NULL);
		// msg 185 restoring generator %s value: %ld 
		return;
	}


	isc_handle gen_id_reqh = NULL;
	UCHAR blr_buffer[100];  // enough to fit blr
	UCHAR* blr = blr_buffer;

	// build the blr with the right relation name

	if (tdgbl->RESTORE_format >= 6)
	{
		stuff(&blr, blr_version5);
	}
	else
	{
		stuff(&blr, blr_version4);
	}
	stuff(&blr, blr_begin);
	if (tdgbl->RESTORE_format >= 6)
	{
		stuff(&blr, blr_dcl_variable);
		stuff_word(&blr, 0);
		stuff(&blr, blr_int64);
		stuff(&blr, 0);
	}
	else
	{
		stuff(&blr, blr_dcl_variable);
		stuff_word(&blr, 0);
		stuff(&blr, blr_long);
		stuff(&blr, 0);
	}
	stuff(&blr, blr_begin);
	stuff(&blr, blr_assignment);
	stuff(&blr, blr_gen_id);
	stuff_string(&blr, gen_name);
	if (tdgbl->RESTORE_format >= 6)
	{
		stuff(&blr, blr_literal);
		stuff(&blr, blr_int64);
		stuff(&blr, 0);
		stuff_int64(&blr, value);
	}
	else
	{
		stuff(&blr, blr_literal);
		stuff(&blr, blr_long);
		stuff(&blr, 0);
		stuff_long(&blr, (SLONG)value);
	}
	stuff(&blr, blr_variable);
	stuff_word(&blr, 0);
	stuff(&blr, blr_end);
	stuff(&blr, blr_end);
	stuff(&blr, blr_eoc);

	const SSHORT blr_length = blr - blr_buffer;
	
	ISC_STATUS_ARRAY	status_vector;
	if (isc_compile_request (status_vector, &DB, &gen_id_reqh,
							 blr_length, (const SCHAR*) blr_buffer))
	{
		isc_print_blr ((const SCHAR*) blr_buffer, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42, 0, 0);
		// msg 42 Failed in store_blr_gen_id 
	}

	if (isc_start_request (status_vector, &gen_id_reqh,
						   &gds_trans, // use the same one generated by gpre 
						   0))
	{
		isc_print_blr ((const SCHAR*) blr_buffer, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42, 0, 0);
		// msg 42 Failed in store_blr_gen_id 
	}

#pragma FB_COMPILER_MESSAGE("BRS: casting SINT64 to SLONG")
	BURP_verbose (185, gen_name, (void*) (SLONG) value, NULL, NULL, NULL);
	// msg 185 restoring generator %s value: %ld 

	isc_release_request (status_vector, &gen_id_reqh);
}

void stuff_string(UCHAR	**ptr,
				  const TEXT* string)
{
/**************************************
 *
 *	s t u f f _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Stuff a name input a BLR string -- byte count first.
 *
 **************************************/
	stuff(ptr, strlen (string));

	while (*string)
		stuff(ptr, *string++);

}

void update_global_field()
{
/**************************************
 *
 *	u p d a t e _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Update the global field definition to add constraints.
 *	The blobs have been created already.
 *
 **************************************/
	USHORT		length;
	isc_req_handle  req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	for (gfld* gfield = tdgbl->gbl_global_fields; gfield; )
	{
		/*FOR (TRANSACTION_HANDLE tdgbl->global_trans REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH X.RDB$FIELD_NAME EQ gfield->gfld_name*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_27), (char *) isc_27);
		isc_vtov ((char*)gfield->gfld_name, (char*)isc_28.isc_29, 32);
		if (req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &tdgbl->global_trans, (short) 0, (short) 32, &isc_28, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 1, (short) 22, &isc_30, (short) 0);
		   if (!isc_30.isc_33 || isc_status [1]) break;
#line 6806 "restore.epp"
			/*MODIFY X*/
			{
#line 6807 "restore.epp"

			if (gfield->gfld_flags & GFLD_validation_blr)
			{
				/*X.RDB$VALIDATION_BLR.NULL*/
				isc_30.isc_35 = FALSE;
#line 6811 "restore.epp"

				if (length = sizeof(ISC_QUAD))
				{
					UCHAR* p = (UCHAR *)&/*X.RDB$VALIDATION_BLR*/
							     isc_30.isc_32;
#line 6815 "restore.epp"
					const UCHAR* q = (UCHAR *)&gfield->gfld_vb;

					do { *p++ = *q++; } while (--length);
				}
			}

			if (gfield->gfld_flags & GFLD_validation_source)
			{
				/*X.RDB$VALIDATION_SOURCE.NULL*/
				isc_30.isc_34 = FALSE;
#line 6824 "restore.epp"

				if (length = sizeof(ISC_QUAD))
				{
					UCHAR* p = (UCHAR *)&/*X.RDB$VALIDATION_SOURCE*/
							     isc_30.isc_31;
#line 6828 "restore.epp"
					const UCHAR* q = (UCHAR *)&gfield->gfld_vs;

					do { *p++ = *q++; } while (--length);
				}
			}

			if (gfield->gfld_flags & GFLD_validation_source2)
			{
				/*X.RDB$VALIDATION_SOURCE.NULL*/
				isc_30.isc_34 = FALSE;
#line 6837 "restore.epp"

				if (length = sizeof(ISC_QUAD))
				{
					UCHAR* p = (UCHAR *)&/*X.RDB$VALIDATION_SOURCE*/
							     isc_30.isc_31;
#line 6841 "restore.epp"
					const UCHAR* q = (UCHAR *)&gfield->gfld_vs2;

					do { *p++ = *q++; } while (--length);
				}
			}

			/*END_MODIFY;*/
			isc_36.isc_37 = isc_30.isc_32;
			isc_36.isc_38 = isc_30.isc_31;
			isc_36.isc_39 = isc_30.isc_35;
			isc_36.isc_40 = isc_30.isc_34;
                        isc_send (isc_status, (isc_handle*) &req_handle1, (short) 2, (short) 20, &isc_36, (short) 0);;
#line 6848 "restore.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 6849 "restore.epp"
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
#line 6851 "restore.epp"

		/*END_FOR;*/
                   isc_send (isc_status, (isc_handle*) &req_handle1, (short) 3, (short) 2, &isc_41, (short) 0);
		   }
		   };
#line 6853 "restore.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 6854 "restore.epp"
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
#line 6856 "restore.epp"
		gfld* n_gfield = gfield->gfld_next;
		BURP_free (gfield);
		gfield = n_gfield;
	}
	MISC_release_request_silent(req_handle1);

	tdgbl->gbl_global_fields = NULL;
}

} // namespace


