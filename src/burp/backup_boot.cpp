/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version SO-V2.0.0.4027 Vulcan 1.0 Development **********************/
#line 1 "backup.epp"
/*
 *	PROGRAM:	JRD Backup and Restore Program
 *	MODULE:		backup.epp
 *	DESCRIPTION:	Backup routine
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * Toni Martir: Added verbose backup records as BACKUP_VERBOSE_INTERVAL
 * 2001.07.06 Sean Leyne - Code Cleanup, removed "#ifdef READONLY_DATABASE"
 *                         conditionals, as the engine now fully supports
 *                         readonly databases.
 * 2001.11.20 Claudio Valderrama: fix problem with embedded blanks in
 * generators and use symbol_length effective length calculation from put_text.
 * This minimizes code redundancy and fixes SF Bug #483276. 
 * 2001.12.15 Claudio Valderrama: copy should run through symbol_length instead
 * of using just another length calculation algorithm. Callers of put_text, copy
 * and symbol_length (if used directly) should use sizeof. Changed all callers
 * and sizeof() works because the strings are local to the functions. This
 * eliminates the problem with harcoded limits in each call.
 * 2002.10.29 Mike Nordell: UINT64 backup message.
 * 2003.08.17 Claudio Valderrama: Fix SF Bug #750659.
 */

/*
$Id$
*/

#include "fbdev.h"
#include "../jrd/ib_stdio.h"
#include <memory.h>
#include <string.h>
#include "../burp/burp.h"
#include "../jrd/ods.h"
#include "../jrd/align.h"
#include "../jrd/gdsassert.h"
#include "../jrd/thd_proto.h"
#include "../burp/backu_proto.h"
#include "../burp/burp_proto.h"
#include "../burp/canon_proto.h"
#include "../burp/mvol_proto.h"
#include "../remote/protocol.h"
#ifdef DEBUG
#include "../gpre/prett_proto.h"
#endif

//  For service APIs the follow DB handle is a value stored
//  in thread data.  This is also done for other statics generated by
//  GPRE.  This is to avoid multiple threading problems with module
//  level statics.

/*DATABASE DB = STATIC FILENAME "yachts.lnk" RUNTIME * dbb_file;*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static const ISC_QUAD
   isc_blob_null = {0,0};	/* initializer for blobs */
static isc_db_handle
   DB = 0;		/* database handle */

static isc_tr_handle
   gds_trans = 0;		/* default transaction handle */
static long
   isc_status [20],	/* status vector */
   isc_status2 [20];	/* status vector */
static SLONG
   isc_array_length, 	/* array return size */
   SQLCODE;		/* SQL status code */
static const char
   isc_tpb_3 [4] = {1,9,2,6};

static const char
   isc_tpb_2 [5] = {1,9,2,6,20};

static const char
   isc_tpb_1 [4] = {1,9,2,6};

static const char
   isc_tpb_0 [5] = {1,9,2,6,20};

static const short
   isc_4l = 216;
static const char
   isc_4 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 8,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 7,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 19, 'R','D','B','$','U','S','E','R','_','P','R','I','V','I','L','E','G','E','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 11, 'R','D','B','$','G','R','A','N','T','O','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 8, 'R','D','B','$','U','S','E','R', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','G','R','A','N','T','_','O','P','T','I','O','N', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','P','R','I','V','I','L','E','G','E', 
			blr_parameter, 0, 7,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 4,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_4 */

static const short
   isc_14l = 264;
static const char
   isc_14 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 7,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 19, 'R','D','B','$','U','S','E','R','_','P','R','I','V','I','L','E','G','E','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 11, 'R','D','B','$','G','R','A','N','T','O','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 8, 'R','D','B','$','U','S','E','R', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','O','B','J','E','C','T','_','T','Y','P','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','U','S','E','R','_','T','Y','P','E', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','G','R','A','N','T','_','O','P','T','I','O','N', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','P','R','I','V','I','L','E','G','E', 
			blr_parameter, 0, 9,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 4,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_14 */

static const short
   isc_26l = 222;
static const char
   isc_26 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 6,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 9, 'R','D','B','$','T','Y','P','E','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','T','Y','P','E','_','N','A','M','E', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 8, 'R','D','B','$','T','Y','P','E', 
			blr_parameter, 0, 5,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 3,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_26 */

static const short
   isc_34l = 248;
static const char
   isc_34 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 79,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 2, 
		  blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
		  blr_relation, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','M','E','S','S','A','G','E','S', 1, 
		  blr_boolean, 
		     blr_and, 
			blr_eql, 
			   blr_field, 1, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			   blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			blr_or, 
			   blr_neq, 
			      blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			      blr_literal, blr_long, 0, 1,0,0,0,
			   blr_missing, 
			      blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 1, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 1, 18, 'R','D','B','$','M','E','S','S','A','G','E','_','N','U','M','B','E','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 1, 11, 'R','D','B','$','M','E','S','S','A','G','E', 
			blr_parameter, 0, 3,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_34 */

static const short
   isc_40l = 118;
static const char
   isc_40 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 3,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_parameter, 0, 0,0, 
			   blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
			   blr_parameter2, 1, 2,0, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_40 */

static const short
   isc_47l = 352;
static const char
   isc_47 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','T','R','I','G','G','E','R','_','S','O','U','R','C','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','T','R','I','G','G','E','R','_','B','L','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','I','N','A','C','T','I','V','E', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P','E', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C','E', 
			blr_parameter, 0, 9,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 5,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_47 */

static const short
   isc_59l = 375;
static const char
   isc_59 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','T','R','I','G','G','E','R','_','S','O','U','R','C','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','T','R','I','G','G','E','R','_','B','L','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
			blr_parameter2, 0, 7,0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','I','N','A','C','T','I','V','E', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 9,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P','E', 
			blr_parameter, 0, 10,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C','E', 
			blr_parameter, 0, 11,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 5,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_59 */

static const short
   isc_73l = 107;
static const char
   isc_73 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 9, 'R','D','B','$','R','O','L','E','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','R','O','L','E','_','N','A','M','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 2,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 2,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_73 */

static const short
   isc_78l = 261;
static const char
   isc_78 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_long, 0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 9, 'R','D','B','$','F','I','L','E','S', 0, 
		  blr_boolean, 
		     blr_and, 
			blr_not, 
			   blr_missing, 
			      blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
			blr_neq, 
			   blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
			   blr_literal, blr_long, 0, 0,0,0,0,
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','F','I','L','E','_','L','E','N','G','T','H', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','S','T','A','R','T', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','F','L','A','G','S', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','F','I','L','E','_','S','E','Q','U','E','N','C','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','F','I','L','E','_','N','A','M','E', 
			blr_parameter, 0, 6,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 2,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_78 */

static const short
   isc_87l = 188;
static const char
   isc_87 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 5,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 24, 'R','D','B','$','E','X','T','E','R','N','A','L','_','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','F','I','L','E', 
			   blr_parameter2, 1, 4,0, 3,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_87 */

static const short
   isc_96l = 130;
static const char
   isc_96 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 3,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_parameter2, 1, 0,0, 2,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_96 */

static const short
   isc_103l = 120;
static const char
   isc_103 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 3,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
			   blr_parameter2, 1, 2,0, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_103 */

static const short
   isc_110l = 259;
static const char
   isc_110 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','V','I','E','W','_','S','O','U','R','C','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 12, 'R','D','B','$','V','I','E','W','_','B','L','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','R','E','L','A','T','I','O','N','_','I','D', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 6,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 4,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_110 */

static const short
   isc_119l = 406;
static const char
   isc_119 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 15,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 24, 'R','D','B','$','E','X','T','E','R','N','A','L','_','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','V','I','E','W','_','S','O','U','R','C','E', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			blr_parameter2, 0, 4,0, 11,0, 
		     blr_assignment, 
			blr_field, 0, 12, 'R','D','B','$','V','I','E','W','_','B','L','R', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','R','E','L','A','T','I','O','N','_','I','D', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','F','I','L','E', 
			blr_parameter2, 0, 10,0, 9,0, 
		     blr_assignment, 
			blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
			blr_parameter2, 0, 13,0, 12,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 14,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 7,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_119 */

static const short
   isc_136l = 248;
static const char
   isc_136 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 8,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 4,0, 
	    blr_cstring, 4,0, 
	    blr_cstring, 12,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 24, 'R','D','B','$','R','E','L','A','T','I','O','N','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 22, 'R','D','B','$','I','N','I','T','I','A','L','L','Y','_','D','E','F','E','R','R','E','D', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','D','E','F','E','R','R','A','B','L','E', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','T','Y','P','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 6,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 6,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_136 */

static const short
   isc_146l = 205;
static const char
   isc_146 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 6,0, 
	    blr_cstring, 8,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 12,0, 
	    blr_cstring, 12,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 19, 'R','D','B','$','R','E','F','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','M','A','T','C','H','_','O','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','C','O','N','S','T','_','N','A','M','E','_','U','Q', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','L','E','T','E','_','R','U','L','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','R','U','L','E', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 5,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 5,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_146 */

static const short
   isc_154l = 248;
static const char
   isc_154 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 6,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 24, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','P','A','R','A','M','E','T','E','R','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','A','M','E', 
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 3,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','T','Y','P','E', 
			   blr_parameter, 1, 4,0, 
			blr_assignment, 
			   blr_field, 0, 20, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','U','M','B','E','R', 
			   blr_parameter, 1, 5,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 3,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_154 */

static const short
   isc_164l = 293;
static const char
   isc_164 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 14, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			blr_parameter2, 0, 1,0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','B','L','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','S','O','U','R','C','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 21, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','O','U','T','P','U','T','S', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','I','N','P','U','T','S', 
			blr_parameter, 0, 9,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 6,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_164 */

static const short
   isc_176l = 124;
static const char
   isc_176 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 3,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
			   blr_parameter2, 1, 2,0, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_176 */

static const short
   isc_183l = 280;
static const char
   isc_183 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 13,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','M','I','S','S','I','N','G','_','S','O','U','R','C','E', 
			   blr_parameter2, 1, 0,0, 7,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
			   blr_parameter2, 1, 1,0, 8,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
			   blr_parameter2, 1, 4,0, 3,0, 
			blr_assignment, 
			   blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			   blr_parameter2, 1, 6,0, 5,0, 
			blr_assignment, 
			   blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','L','E','N','G','T','H', 
			   blr_parameter2, 1, 10,0, 9,0, 
			blr_assignment, 
			   blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
			   blr_parameter2, 1, 12,0, 11,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_183 */

static const short
   isc_200l = 199;
static const char
   isc_200 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 5,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','E','X','T','E','R','N','A','L','_','S','C','A','L','E', 
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','T','Y','P','E', 
			   blr_parameter, 1, 3,0, 
			blr_assignment, 
			   blr_field, 0, 19, 'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E','N','G','T','H', 
			   blr_parameter, 1, 4,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_200 */

static const short
   isc_209l = 557;
static const char
   isc_209 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 18,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 126,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L','U','E', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
			blr_parameter, 0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			blr_parameter, 0, 9,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 10,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 11,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N','G','T','H', 
			blr_parameter, 0, 12,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
			blr_parameter, 0, 13,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
			blr_parameter, 0, 14,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
			blr_parameter, 0, 15,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
			blr_parameter, 0, 16,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
			blr_parameter, 0, 17,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 10,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_209 */

static const short
   isc_229l = 887;
static const char
   isc_229 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 36,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 126,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','M','I','S','S','I','N','G','_','S','O','U','R','C','E', 
			blr_parameter2, 0, 0,0, 19,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
			blr_parameter2, 0, 1,0, 20,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
			blr_parameter, 0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L','U','E', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
			blr_parameter, 0, 9,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
			blr_parameter, 0, 10,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			blr_parameter, 0, 11,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 12,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
			blr_parameter2, 0, 14,0, 13,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
			blr_parameter2, 0, 16,0, 15,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			blr_parameter2, 0, 18,0, 17,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','L','E','N','G','T','H', 
			blr_parameter2, 0, 22,0, 21,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
			blr_parameter2, 0, 24,0, 23,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
			blr_parameter, 0, 25,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','E','X','T','E','R','N','A','L','_','S','C','A','L','E', 
			blr_parameter, 0, 26,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','T','Y','P','E', 
			blr_parameter, 0, 27,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E','N','G','T','H', 
			blr_parameter, 0, 28,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 29,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N','G','T','H', 
			blr_parameter, 0, 30,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
			blr_parameter, 0, 31,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
			blr_parameter, 0, 32,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
			blr_parameter, 0, 33,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
			blr_parameter, 0, 34,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
			blr_parameter, 0, 35,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 12,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_229 */

static const short
   isc_267l = 139;
static const char
   isc_267 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 14, 'R','D','B','$','G','E','N','E','R','A','T','O','R','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 1,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_267 */

static const short
   isc_271l = 172;
static const char
   isc_271 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 3,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
			   blr_eql, 
			      blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
			      blr_parameter, 0, 1,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			   blr_parameter2, 1, 2,0, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_271 */

static const short
   isc_279l = 291;
static const char
   isc_279 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 8,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
			   blr_parameter, 1, 3,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
			   blr_parameter, 1, 4,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
			   blr_parameter, 1, 5,0, 
			blr_assignment, 
			   blr_field, 0, 13, 'R','D','B','$','M','E','C','H','A','N','I','S','M', 
			   blr_parameter, 1, 6,0, 
			blr_assignment, 
			   blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
			   blr_parameter, 1, 7,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_279 */

static const short
   isc_291l = 358;
static const char
   isc_291 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 12,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
			   blr_parameter2, 1, 3,0, 2,0, 
			blr_assignment, 
			   blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			   blr_parameter2, 1, 5,0, 4,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
			   blr_parameter, 1, 6,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
			   blr_parameter, 1, 7,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
			   blr_parameter, 1, 8,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
			   blr_parameter, 1, 9,0, 
			blr_assignment, 
			   blr_field, 0, 13, 'R','D','B','$','M','E','C','H','A','N','I','S','M', 
			   blr_parameter, 1, 10,0, 
			blr_assignment, 
			   blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
			   blr_parameter, 1, 11,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_291 */

static const short
   isc_307l = 247;
static const char
   isc_307 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 8,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 13, 'R','D','B','$','F','U','N','C','T','I','O','N','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','T','Y','P','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','R','E','T','U','R','N','_','A','R','G','U','M','E','N','T', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','M','O','D','U','L','E','_','N','A','M','E', 
			blr_parameter, 0, 7,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 4,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_307 */

static const short
   isc_317l = 221;
static const char
   isc_317 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 254,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 11, 'R','D','B','$','F','I','L','T','E','R','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','O','U','T','P','U','T','_','S','U','B','_','T','Y','P','E', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','I','N','P','U','T','_','S','U','B','_','T','Y','P','E', 
			blr_parameter, 0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','M','O','D','U','L','E','_','N','A','M','E', 
			blr_parameter, 0, 6,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 3,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_317 */

static const short
   isc_326l = 167;
static const char
   isc_326 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 5,0, 
	    blr_cstring, 32,0, 
	    blr_long, 0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 20, 'R','D','B','$','F','I','E','L','D','_','D','I','M','E','N','S','I','O','N','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','U','P','P','E','R','_','B','O','U','N','D', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','L','O','W','E','R','_','B','O','U','N','D', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 13, 'R','D','B','$','D','I','M','E','N','S','I','O','N', 
			blr_parameter, 0, 4,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 3,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_326 */

static const short
   isc_333l = 139;
static const char
   isc_333 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_cstring, 79,0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 14, 'R','D','B','$','E','X','C','E','P','T','I','O','N','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','E','X','C','E','P','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 11, 'R','D','B','$','M','E','S','S','A','G','E', 
			blr_parameter, 0, 3,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 2,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_333 */

static const short
   isc_339l = 98;
static const char
   isc_339 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 2,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 1,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_339 */

static const short
   isc_344l = 86;
static const char
   isc_344 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 2,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 1,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_344 */

static const short
   isc_348l = 94;
static const char
   isc_348 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			blr_parameter2, 0, 0,0, 2,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 1,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_348 */

static const short
   isc_353l = 156;
static const char
   isc_353 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 6,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			blr_parameter2, 0, 2,0, 5,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 3,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 3,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_353 */

static const short
   isc_361l = 315;
static const char
   isc_361 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 14, 'R','D','B','$','C','O','L','L','A','T','I','O','N','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter2, 0, 1,0, 5,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 24, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','A','T','T','R','I','B','U','T','E','S', 
			blr_parameter, 0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			blr_parameter, 0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
			blr_parameter, 0, 9,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 3,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_361 */

static const short
   isc_373l = 131;
static const char
   isc_373 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 21, 'R','D','B','$','C','H','E','C','K','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 3,0, 
		     blr_assignment, 
			blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 2,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 2,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_373 */

static const short
   isc_379l = 399;
static const char
   isc_379 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 14,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 18, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','S', 0, 
		  blr_boolean, 
		     blr_or, 
			blr_missing, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_neq, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_literal, blr_long, 0, 1,0,0,0,
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
			blr_parameter2, 0, 0,0, 8,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter2, 0, 1,0, 9,0, 
		     blr_assignment, 
			blr_field, 0, 24, 'R','D','B','$','D','E','F','A','U','L','T','_','C','O','L','L','A','T','E','_','N','A','M','E', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','F','O','R','M','_','O','F','_','U','S','E', 
			blr_parameter2, 0, 3,0, 13,0, 
		     blr_assignment, 
			blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			blr_parameter, 0, 4,0, 
		     blr_assignment, 
			blr_field, 0, 24, 'R','D','B','$','N','U','M','B','E','R','_','O','F','_','C','H','A','R','A','C','T','E','R','S', 
			blr_parameter2, 0, 5,0, 12,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 6,0, 
		     blr_assignment, 
			blr_field, 0, 23, 'R','D','B','$','B','Y','T','E','S','_','P','E','R','_','C','H','A','R','A','C','T','E','R', 
			blr_parameter, 0, 7,0, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_parameter, 0, 10,0, 
		     blr_assignment, 
			blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			blr_parameter, 0, 11,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 6,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_379 */

static const short
   isc_395l = 129;
static const char
   isc_395 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 1,0, 
			   blr_eql, 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_395 */

static const short
   isc_401l = 152;
static const char
   isc_401 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 3,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 13, 'R','D','B','$','V','I','E','W','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
			   blr_parameter, 1, 2,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_401 */

static const short
   isc_408l = 179;
static const char
   isc_408 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 4,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 13, 'R','D','B','$','V','I','E','W','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','C','O','N','T','E','X','T','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
			   blr_parameter, 1, 3,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_408 */

static const short
   isc_416l = 189;
static const char
   isc_416 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 7,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','F','O','R','E','I','G','N','_','K','E','Y', 
			   blr_parameter2, 1, 0,0, 4,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','B','L','R', 
			   blr_parameter2, 1, 1,0, 5,0, 
			blr_assignment, 
			   blr_field, 0, 21, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','S','O','U','R','C','E', 
			   blr_parameter2, 1, 2,0, 6,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 3,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 3,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_416 */

static const short
   isc_427l = 116;
static const char
   isc_427 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','T','Y','P','E', 
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_427 */

static const short
   isc_433l = 148;
static const char
   isc_433 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_sort, 1, 
			blr_ascending, 
			   blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_433 */

static const short
   isc_439l = 120;
static const char
   isc_439 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_439 */

static const short
   isc_445l = 129;
static const char
   isc_445 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_parameter, 0, 1,0, 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_445 */

static const short
   isc_451l = 124;
static const char
   isc_451 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_451 */

static const short
   isc_457l = 197;
static const char
   isc_457 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 5,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','U','N','I','Q','U','E','_','F','L','A','G', 
			   blr_parameter, 1, 3,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','S','E','G','M','E','N','T','_','C','O','U','N','T', 
			   blr_parameter, 1, 4,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_457 */

static const short
   isc_466l = 148;
static const char
   isc_466 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_sort, 1, 
			blr_ascending, 
			   blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_466 */

static const short
   isc_472l = 186;
static const char
   isc_472 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_and, 
			      blr_eql, 
				 blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
				 blr_parameter, 0, 1,0, 
			      blr_eql, 
				 blr_field, 1, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
				 blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_472 */

static const short
   isc_478l = 346;
static const char
   isc_478 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 13,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','F','O','R','E','I','G','N','_','K','E','Y', 
			   blr_parameter2, 1, 0,0, 6,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','B','L','R', 
			   blr_parameter2, 1, 1,0, 7,0, 
			blr_assignment, 
			   blr_field, 0, 21, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','S','O','U','R','C','E', 
			   blr_parameter2, 1, 2,0, 8,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter, 1, 3,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 1, 4,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 5,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','T','Y','P','E', 
			   blr_parameter, 1, 9,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','U','N','I','Q','U','E','_','F','L','A','G', 
			   blr_parameter, 1, 10,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			   blr_parameter, 1, 11,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','S','E','G','M','E','N','T','_','C','O','U','N','T', 
			   blr_parameter, 1, 12,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 5,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_478 */

static const short
   isc_495l = 193;
static const char
   isc_495 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 4,0, 
	    blr_long, 0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 20, 'R','D','B','$','F','I','E','L','D','_','D','I','M','E','N','S','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_sort, 1, 
			blr_ascending, 
			   blr_field, 0, 13, 'R','D','B','$','D','I','M','E','N','S','I','O','N', 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','U','P','P','E','R','_','B','O','U','N','D', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','L','O','W','E','R','_','B','O','U','N','D', 
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 13, 'R','D','B','$','D','I','M','E','N','S','I','O','N', 
			   blr_parameter, 1, 3,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_495 */

static const short
   isc_503l = 334;
static const char
   isc_503 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 11,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_parameter, 0, 1,0, 
			   blr_and, 
			      blr_eql, 
				 blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
				 blr_parameter, 0, 0,0, 
			      blr_eql, 
				 blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
				 blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
			   blr_parameter2, 1, 0,0, 7,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
			   blr_parameter2, 1, 1,0, 8,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
			   blr_parameter2, 1, 4,0, 3,0, 
			blr_assignment, 
			   blr_field, 1, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			   blr_parameter2, 1, 6,0, 5,0, 
			blr_assignment, 
			   blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
			   blr_parameter2, 1, 10,0, 9,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_503 */

static const short
   isc_519l = 115;
static const char
   isc_519 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_519 */

static const short
   isc_525l = 158;
static const char
   isc_525 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 1,0, 
			   blr_eql, 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_525 */

static const short
   isc_532l = 154;
static const char
   isc_532 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 1,0, 
			   blr_eql, 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_532 */

static const short
   isc_539l = 156;
static const char
   isc_539 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_parameter, 0, 1,0, 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','C','O','M','P','L','E','X','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_539 */

static const short
   isc_546l = 607;
static const char
   isc_546 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 22,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_cstring, 126,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
			      blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 1, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 1, 1,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','B','A','S','E','_','F','I','E','L','D', 
			   blr_parameter, 1, 3,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
			   blr_parameter, 1, 4,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 1, 5,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
			   blr_parameter2, 1, 6,0, 15,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter2, 1, 7,0, 16,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 8,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
			   blr_parameter, 1, 9,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','F','L','A','G', 
			   blr_parameter2, 1, 11,0, 10,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
			   blr_parameter, 1, 12,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
			   blr_parameter2, 1, 14,0, 13,0, 
			blr_assignment, 
			   blr_field, 0, 12, 'R','D','B','$','F','I','E','L','D','_','I','D', 
			   blr_parameter, 1, 17,0, 
			blr_assignment, 
			   blr_field, 1, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
			   blr_parameter, 1, 18,0, 
			blr_assignment, 
			   blr_field, 1, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
			   blr_parameter, 1, 19,0, 
			blr_assignment, 
			   blr_field, 1, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
			   blr_parameter, 1, 20,0, 
			blr_assignment, 
			   blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
			   blr_parameter, 1, 21,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 8,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_546 */

static const short
   isc_572l = 838;
static const char
   isc_572 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 35,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_cstring, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring, 126,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
			      blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_eql, 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
			   blr_parameter2, 1, 0,0, 16,0, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
			   blr_parameter2, 1, 1,0, 17,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_parameter, 1, 2,0, 
			blr_assignment, 
			   blr_field, 1, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
			   blr_parameter, 1, 3,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','C','O','M','P','L','E','X','_','N','A','M','E', 
			   blr_parameter, 1, 4,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
			   blr_parameter, 1, 5,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','B','A','S','E','_','F','I','E','L','D', 
			   blr_parameter, 1, 6,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
			   blr_parameter, 1, 7,0, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 1, 8,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
			   blr_parameter2, 1, 9,0, 28,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter2, 1, 10,0, 29,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 11,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
			   blr_parameter2, 1, 13,0, 12,0, 
			blr_assignment, 
			   blr_field, 1, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			   blr_parameter2, 1, 15,0, 14,0, 
			blr_assignment, 
			   blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
			   blr_parameter2, 1, 19,0, 18,0, 
			blr_assignment, 
			   blr_field, 1, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
			   blr_parameter, 1, 20,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			   blr_parameter, 1, 21,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
			   blr_parameter, 1, 22,0, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','F','L','A','G', 
			   blr_parameter2, 1, 24,0, 23,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
			   blr_parameter, 1, 25,0, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
			   blr_parameter2, 1, 27,0, 26,0, 
			blr_assignment, 
			   blr_field, 0, 12, 'R','D','B','$','F','I','E','L','D','_','I','D', 
			   blr_parameter, 1, 30,0, 
			blr_assignment, 
			   blr_field, 1, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
			   blr_parameter, 1, 31,0, 
			blr_assignment, 
			   blr_field, 1, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
			   blr_parameter, 1, 32,0, 
			blr_assignment, 
			   blr_field, 1, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
			   blr_parameter, 1, 33,0, 
			blr_assignment, 
			   blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
			   blr_parameter, 1, 34,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 11,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_572 */

static const short
   isc_611l = 172;
static const char
   isc_611 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 20, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S','E','S', 0, 
		  blr_boolean, 
		     blr_not, 
			blr_starting, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_literal, blr_text, 4,0, 'S','Q','L','$',
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_field, 0, 7, 'R','D','B','$','A','C','L', 
			blr_parameter, 0, 1,0, 
		     blr_assignment, 
			blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			blr_parameter, 0, 2,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 3,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 3,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_611 */


#define gds_blob_null	isc_blob_null	/* compatibility symbols */
#define gds_status	isc_status
#define gds_status2	isc_status2
#define gds_array_length	isc_array_length
#define gds_count	isc_count
#define gds_slack	isc_slack
#define gds_utility	isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
    Generate a compile-time error.
    Picking up a V3 include file after preprocessing with V4 GPRE.
#endif

/**** end of GPRE definitions ****/

#line 67 "backup.epp"

#define DB			tdgbl->db_handle
#define gds_trans	tdgbl->tr_handle
#define isc_status	tdgbl->status

namespace // unnamed, private
{

// VERBOSE INTERVAL WHEN BACKING RECORDS
const ULONG BACKUP_VERBOSE_INTERVAL = 20000;

#define PUT_MESSAGE(attribute, message)	put_message ((attribute), (message), sizeof(message))
#define PUT_TEXT(attribute, text)	put_text ((attribute), (text), sizeof(text))
#define COPY(source, target)       copy ((source), (target), sizeof(target))

inline void put(tgbl* tdgbl, UCHAR c)
{
	if (--(tdgbl->io_cnt) >= 0)
		*(tdgbl->io_ptr)++ = c;
	else
		MVOL_write(c, &tdgbl->io_cnt, &tdgbl->io_ptr);
}
 
inline const UCHAR* put_block(tgbl* tdgbl, const UCHAR* p, ULONG n)
{
	return MVOL_write_block (tdgbl, p, n);
}


void compress(const UCHAR*, ULONG);
int copy(const TEXT *, TEXT *, ULONG);
BURP_FLD get_fields(BURP_REL);
SINT64 get_gen_id(const TEXT *, SSHORT);
void get_ranges(BURP_FLD);
void put_array(BURP_FLD, BURP_REL, ISC_QUAD *);
void put_asciz(const SCHAR, const TEXT*);
void put_blob(BURP_FLD, ISC_QUAD *, ULONG);
bool put_blr_blob(SCHAR, ISC_QUAD *);
void put_data(BURP_REL);
void put_index(BURP_REL);
int put_message(SCHAR, const TEXT *, ULONG);
void put_numeric(SCHAR, SLONG);
void put_relation(BURP_REL);
bool put_source_blob(SCHAR, SCHAR, ISC_QUAD *);
int put_text(SCHAR, const TEXT *, SSHORT);
void set_capabilities(void);
int symbol_length(const TEXT *, ULONG);
void write_character_sets(void);
void write_check_constraints(void);
void write_collations(void);
void write_database(const TEXT*);
void write_exceptions(void);
void write_field_dimensions(void);
void write_filters(void);
void write_functions(void);
void write_function_args(GDS_NAME);
void write_generators(void);
void write_sql_roles(void);
void write_global_fields(void);
void write_procedures(void);
void write_procedure_prms(GDS_NAME);
void write_ref_constraints(void);
void write_rel_constraints(void);
void write_relations(void);
void write_shadow_files(void);
void write_triggers(void);
void write_trigger_messages(void);
void write_types(void);
void write_user_privileges(void);
void general_on_error(void);

enum backup_capabilities
{
	BCK_security		= 1,
	BCK_files			= 2,
	BCK_external		= 4,
	BCK_idx_inactive	= 8,
	BCK_triggers		= 16,	// Obsolete - 1996-Aug-05
	BCK_context_name	= 32,
	BCK_db_description	= 64,
	BCK_ffmptt			= 128,	// rdb$functions, rdb$filters, rdb$trigger_messages,
								// rdb$user_privileges, rdb$triggers, rdb$types
	BCK_attributes_v3	= 256,	// attributes in various system relations new to v3
	BCK_rfr_sys_flag	= 512,	// system flag is missing from Rdb/VMS V3 RFR relation
	BCK_ods6			= 1024,	// rdb$field_dimensions and shadow files
	BCK_ods8			= 2048,	// stored procedures & exceptions & constraints
	BCK_ods9			= 4096,	// SQL roles
	BCK_ods10			= 8192	// FIELD_PRECISION
};

#ifdef DEBUG
UCHAR debug_on = 0;		// able to turn this on in debug mode 
#endif


/*  
   table used to determine capabilities, checking for specific 
   fields in system relations 
*/

struct rfr_tab_t
{
	const TEXT *relation;
	const TEXT *field;
	// Let's be compatible with tgbl.BCK_capabilities, although we could follow
	// the enumeration backup_capabilities but the enum then should be defined
	// in burp.h instead so BCK_capabilities isn't anymore a simple SLONG.
	SLONG bit_mask;
};

const rfr_tab_t rfr_table[] =
{
	{"RDB$INDICES", "RDB$INDEX_INACTIVE", BCK_idx_inactive},
/* Backup of V2 triggers no longer supported 1996-Aug-05 David Schnepper  
	{"RDB$RELATIONS",	"RDB$STORE_TRIGGER",	BCK_triggers}, 
*/
	{"RDB$RELATIONS", "RDB$EXTERNAL_FILE", BCK_external},
	{"RDB$SECURITY_CLASSES", "RDB$SECURITY_CLASS", BCK_security},
	{"RDB$FILES", "RDB$FILE_NAME", BCK_files},
	{"RDB$VIEW_RELATIONS", "RDB$CONTEXT_NAME", BCK_context_name},
	{"RDB$DATABASE", "RDB$DESCRIPTION", BCK_db_description},
	{"RDB$FUNCTIONS", "RDB$FUNCTION_NAME", BCK_ffmptt},
	{"RDB$FIELDS", "RDB$EXTERNAL_LENGTH", BCK_attributes_v3},
	{"RDB$RELATION_FIELDS", "RDB$SYSTEM_FLAG", BCK_rfr_sys_flag},
	{"RDB$FIELD_DIMENSIONS", "RDB$DIMENSION", BCK_ods6},
	{"RDB$PROCEDURES", "RDB$PROCEDURE_NAME", BCK_ods8},
	{"RDB$ROLES", "RDB$ROLE_NAME", BCK_ods9},
	{"RDB$FIELDS", "RDB$FIELD_PRECISION", BCK_ods10},
	{0, 0, 0}
};

const SCHAR blob_items[] =
{
	isc_info_blob_max_segment,
	isc_info_blob_num_segments
};
const SCHAR blr_items[] =
{
	isc_info_blob_max_segment,
	isc_info_blob_total_length
};
const SCHAR source_items[] =
{
	isc_info_blob_max_segment,
	isc_info_blob_total_length,
	isc_info_blob_num_segments
};
const SCHAR db_info_items[] =
{
	isc_info_db_sql_dialect,
	isc_info_page_size,
	isc_info_sweep_interval,
	isc_info_forced_writes,
	isc_info_no_reserve,
	isc_info_set_page_buffers,
	isc_info_db_read_only,
	isc_info_end
};
const SCHAR limbo_tpb[] =
{
	isc_tpb_version1,
	isc_tpb_ignore_limbo
};
const SCHAR limbo_nau_tpb[] =
{
	isc_tpb_version1,
	isc_tpb_ignore_limbo,
	isc_tpb_no_auto_undo
};

} // namespace


int BACKUP_backup(const TEXT* dbb_file, const TEXT* file_name)
{
   struct {
          ISC_QUAD isc_613;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_614;	/* RDB$ACL */
          char  isc_615 [32];	/* RDB$SECURITY_CLASS */
          short isc_616;	/* isc_utility */
   } isc_612;
#line 242 "backup.epp"
/**************************************
 *
 *	B A C K U P _ b a c k u p
 *
 **************************************
 *
 * Functional description
 *	Backup a database.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	TEXT temp[GDS_NAME_LEN];

	TGBL tdgbl = GET_THREAD_DATA;

	tdgbl->gbl_database_file_name = dbb_file;

	tdgbl->io_ptr = NULL;
	tdgbl->io_cnt = 0;
	tdgbl->relations = NULL;
	tdgbl->BCK_capabilities = 0;

	gds_trans = NULL;

	BURP_verbose(130, NULL, NULL, NULL, NULL, NULL);
	// msg 130 starting transaction 

	if (tdgbl->gbl_sw_ignore_limbo)
	{
		if (isc_start_transaction(status_vector, &gds_trans, 1, &DB,
								  sizeof(limbo_nau_tpb), limbo_nau_tpb))
		{
			isc_start_transaction(status_vector, &gds_trans, 1, &DB,
								  sizeof(limbo_tpb), limbo_tpb);
		}
	}
	else
	{
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_0);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 281 "backup.epp"
		if (isc_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_1);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 283 "backup.epp"
	}

	if (!gds_trans)
	{
		/*EXEC SQL SET TRANSACTION NAME gds_trans NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_2);
		SQLCODE = isc_sqlcode (isc_status);
		}
#line 288 "backup.epp"
		if (isc_status[1])
			/*EXEC SQL SET TRANSACTION NAME gds_trans;*/
			{
			isc_start_transaction (isc_status, (isc_handle*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_3);
			SQLCODE = isc_sqlcode (isc_status);
			}
#line 290 "backup.epp"
	}




// decide what type of database we've got 

	set_capabilities();

// Write burp record first with other valuable information 
// In case of split operation, write a 'split' header first to all the files 

	if (tdgbl->action->act_action == ACT_backup_split)
	{
		for (FIL fil = tdgbl->gbl_sw_files; fil; fil = fil->fil_next)
		{
			tdgbl->action->act_file = fil;
			if (MVOL_split_hdr_write() == FALSE)
			{
				BURP_error(269, true, tdgbl->action->act_file->fil_name, 0, 0, 0, 0);
				// msg 269 can't write a header record to file %s 
			}
		}
		tdgbl->action->act_file = tdgbl->gbl_sw_files;
	}

	MVOL_init_write(reinterpret_cast<const UCHAR*>(dbb_file),
					reinterpret_cast<const UCHAR*>(file_name),
					&tdgbl->io_cnt, &tdgbl->io_ptr);

// Write database record 

	write_database(dbb_file);

// Write global fields 

	BURP_verbose(150, NULL, NULL, NULL, NULL, NULL);
	// msg 150  writing global fields 
	write_global_fields();

	if (tdgbl->BCK_capabilities & BCK_ods6)
	{
		write_field_dimensions();

		BURP_verbose(162, NULL, NULL, NULL, NULL, NULL);
		// msg 162  writing shadow files 
		write_shadow_files();
	}

// Write relations 

	BURP_verbose(154, NULL, NULL, NULL, NULL, NULL);
	// msg 154 writing relations 

	write_relations();

	if (tdgbl->BCK_capabilities & BCK_ffmptt)
	{
		// Write functions 
		BURP_verbose(148, NULL, NULL, NULL, NULL, NULL);
		// msg 148 writing functions 
		write_functions();

		// Write types 
		BURP_verbose(161, NULL, NULL, NULL, NULL, NULL);
		// msg 161  writing types 
		write_types();

		// Write filters 
		BURP_verbose(146, NULL, NULL, NULL, NULL, NULL);
		// msg 146 writing filters 
		write_filters();

		// Write generators 

		BURP_verbose(164, NULL, NULL, NULL, NULL, NULL);
		// msg 164  writing id generators 
		write_generators();
	}

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		// Write procedures 
		BURP_verbose(192, NULL, NULL, NULL, NULL, NULL);
		// msg 192 writing stored procedures 
		write_procedures();

		// Write exceptions 
		BURP_verbose(197, NULL, NULL, NULL, NULL, NULL);
		// msg 197 writing exceptions 
		write_exceptions();

		// Write Character Sets 
		BURP_verbose(msgVerbose_write_charsets, NULL, NULL, NULL, NULL, NULL);
		write_character_sets();

		// Write Collations 
		BURP_verbose(msgVerbose_write_collations, NULL, NULL, NULL, NULL,
					 NULL);
		write_collations();

	}

// Now go back and write all data 

	for (BURP_REL relation = tdgbl->relations; relation; relation = relation->rel_next) {
		put(tdgbl, (UCHAR) (rec_relation_data));
		PUT_TEXT(att_relation_name, relation->rel_name);
		put(tdgbl, (UCHAR) (att_end));

		if (!(relation->rel_flags & REL_view) && 
			!(relation->rel_flags & REL_external))
		{
			
			put_index(relation);
			if (!tdgbl->gbl_sw_meta)
				put_data(relation);
		}

		put(tdgbl, (UCHAR) (rec_relation_end));
	}

/* now for the new triggers in rdb$triggers */
	if (tdgbl->BCK_capabilities & BCK_ffmptt) {
		BURP_verbose(159, NULL, NULL, NULL, NULL, NULL);
		// msg 159  writing triggers 
		write_triggers();
		BURP_verbose(158, NULL, NULL, NULL, NULL, NULL);
		// msg 158 writing trigger messages 
		write_trigger_messages();
		write_user_privileges();
	}

// Last, but not least, go back and add any access control lists 

	if (tdgbl->BCK_capabilities & BCK_security)
	{
		isc_req_handle req_handle1 = NULL;
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$SECURITY_CLASSES WITH X.RDB$SECURITY_CLASS NOT STARTING "SQL$"*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_611), (char *) isc_611);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 50, &isc_612, (short) 0);
		   if (!isc_612.isc_616 || isc_status [1]) break;
#line 430 "backup.epp"
			put(tdgbl, rec_security_class);
			const ULONG l = PUT_TEXT (att_class_security_class, /*X.RDB$SECURITY_CLASS*/
									    isc_612.isc_615);
#line 432 "backup.epp"
			MISC_terminate (/*X.RDB$SECURITY_CLASS*/
					isc_612.isc_615, temp, l, sizeof(temp));
#line 433 "backup.epp"
			BURP_verbose (155, temp, NULL, NULL, NULL, NULL);
			// msg 155 writing security class %s 
			put_blr_blob (att_class_acl, (ISC_QUAD *)&/*X.RDB$ACL*/
								  isc_612.isc_614);
#line 436 "backup.epp"
			put_source_blob (att_class_description2, att_class_description,
							 (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
								      isc_612.isc_613);
#line 438 "backup.epp"
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
#line 440 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 441 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 443 "backup.epp"

		MISC_release_request_silent(req_handle1);
	}

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		// Write relation constraints  
		BURP_verbose(206, NULL, NULL, NULL, NULL, NULL);
		// msg 206 writing relation constraints 
		write_rel_constraints();

		// Write referential constraints  
		BURP_verbose(209, NULL, NULL, NULL, NULL, NULL);
		// msg 209 writing referential constraints 
		write_ref_constraints();

		// Write check constraints  
		BURP_verbose(210, NULL, NULL, NULL, NULL, NULL);
		// msg 210 writing check constraints 
		write_check_constraints();

	}

	if (tdgbl->BCK_capabilities & BCK_ods9)
	{
		// Write SQL roles  
		BURP_verbose(248, NULL, NULL, NULL, NULL, NULL);
		// msg 248 writing SQL roles 
		write_sql_roles();
	}

// Finish up 

	put(tdgbl, (UCHAR) (rec_end));
	
	UINT64 cumul_count = MVOL_fini_write(&tdgbl->io_cnt, &tdgbl->io_ptr);
	if (cumul_count <= MAX_SLONG) {
		SLONG tempcount = cumul_count;
		BURP_verbose(176, (void*) tempcount, NULL, NULL, NULL, NULL);
		// msg 176 closing file, committing, and finishing.  %ld bytes written 
	}
	else {
		char psz[64];
		ib_sprintf(psz, "%" QUADFORMAT "d", cumul_count);
		BURP_verbose(283, psz, NULL, NULL, NULL, NULL);
		// msg 283 closing file, committing, and finishing.  %s bytes written 
	}
	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 491 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 492 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 494 "backup.epp"

	if (gds_trans)
		/*COMMIT gds_trans;*/
		{
		isc_commit_transaction (isc_status, (isc_handle*) &gds_trans);;
#line 497 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 498 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 500 "backup.epp"

	/*FINISH*/
	{
	if (DB)
	   isc_detach_database (isc_status, &DB);;
#line 502 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 503 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 505 "backup.epp"

	return FINI_OK;
}

namespace // unnamed, private
{
   struct {
          char  isc_6 [32];	/* RDB$FIELD_NAME */
          char  isc_7 [32];	/* RDB$RELATION_NAME */
          char  isc_8 [32];	/* RDB$GRANTOR */
          char  isc_9 [32];	/* RDB$USER */
          short isc_10;	/* isc_utility */
          short isc_11;	/* gds__null_flag */
          short isc_12;	/* RDB$GRANT_OPTION */
          char  isc_13 [7];	/* RDB$PRIVILEGE */
   } isc_5;
   struct {
          char  isc_16 [32];	/* RDB$FIELD_NAME */
          char  isc_17 [32];	/* RDB$RELATION_NAME */
          char  isc_18 [32];	/* RDB$GRANTOR */
          char  isc_19 [32];	/* RDB$USER */
          short isc_20;	/* isc_utility */
          short isc_21;	/* RDB$OBJECT_TYPE */
          short isc_22;	/* RDB$USER_TYPE */
          short isc_23;	/* gds__null_flag */
          short isc_24;	/* RDB$GRANT_OPTION */
          char  isc_25 [7];	/* RDB$PRIVILEGE */
   } isc_15;
   struct {
          ISC_QUAD isc_28;	/* RDB$DESCRIPTION */
          char  isc_29 [32];	/* RDB$FIELD_NAME */
          char  isc_30 [32];	/* RDB$TYPE_NAME */
          short isc_31;	/* isc_utility */
          short isc_32;	/* RDB$SYSTEM_FLAG */
          short isc_33;	/* RDB$TYPE */
   } isc_27;
   struct {
          char  isc_36 [32];	/* RDB$TRIGGER_NAME */
          short isc_37;	/* isc_utility */
          short isc_38;	/* RDB$MESSAGE_NUMBER */
          char  isc_39 [79];	/* RDB$MESSAGE */
   } isc_35;
   struct {
          short isc_44;	/* isc_utility */
          short isc_45;	/* gds__null_flag */
          short isc_46;	/* RDB$FLAGS */
   } isc_43;
   struct {
          char  isc_42 [32];	/* RDB$TRIGGER_NAME */
   } isc_41;
   struct {
          ISC_QUAD isc_49;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_50;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_51;	/* RDB$TRIGGER_BLR */
          char  isc_52 [32];	/* RDB$RELATION_NAME */
          char  isc_53 [32];	/* RDB$TRIGGER_NAME */
          short isc_54;	/* isc_utility */
          short isc_55;	/* RDB$TRIGGER_INACTIVE */
          short isc_56;	/* RDB$SYSTEM_FLAG */
          short isc_57;	/* RDB$TRIGGER_TYPE */
          short isc_58;	/* RDB$TRIGGER_SEQUENCE */
   } isc_48;
   struct {
          ISC_QUAD isc_61;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_62;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_63;	/* RDB$TRIGGER_BLR */
          char  isc_64 [32];	/* RDB$RELATION_NAME */
          char  isc_65 [32];	/* RDB$TRIGGER_NAME */
          short isc_66;	/* isc_utility */
          short isc_67;	/* gds__null_flag */
          short isc_68;	/* RDB$FLAGS */
          short isc_69;	/* RDB$TRIGGER_INACTIVE */
          short isc_70;	/* RDB$SYSTEM_FLAG */
          short isc_71;	/* RDB$TRIGGER_TYPE */
          short isc_72;	/* RDB$TRIGGER_SEQUENCE */
   } isc_60;
   struct {
          char  isc_75 [32];	/* RDB$OWNER_NAME */
          char  isc_76 [32];	/* RDB$ROLE_NAME */
          short isc_77;	/* isc_utility */
   } isc_74;
   struct {
          SLONG isc_80;	/* RDB$FILE_LENGTH */
          SLONG isc_81;	/* RDB$FILE_START */
          short isc_82;	/* isc_utility */
          short isc_83;	/* RDB$SHADOW_NUMBER */
          short isc_84;	/* RDB$FILE_FLAGS */
          short isc_85;	/* RDB$FILE_SEQUENCE */
          char  isc_86 [254];	/* RDB$FILE_NAME */
   } isc_79;
   struct {
          char  isc_91 [32];	/* RDB$OWNER_NAME */
          ISC_QUAD isc_92;	/* RDB$EXTERNAL_DESCRIPTION */
          short isc_93;	/* isc_utility */
          short isc_94;	/* gds__null_flag */
          char  isc_95 [254];	/* RDB$EXTERNAL_FILE */
   } isc_90;
   struct {
          char  isc_89 [32];	/* RDB$RELATION_NAME */
   } isc_88;
   struct {
          char  isc_100 [32];	/* RDB$SECURITY_CLASS */
          short isc_101;	/* isc_utility */
          short isc_102;	/* gds__null_flag */
   } isc_99;
   struct {
          char  isc_98 [32];	/* RDB$RELATION_NAME */
   } isc_97;
   struct {
          short isc_107;	/* isc_utility */
          short isc_108;	/* gds__null_flag */
          short isc_109;	/* RDB$FLAGS */
   } isc_106;
   struct {
          char  isc_105 [32];	/* RDB$RELATION_NAME */
   } isc_104;
   struct {
          ISC_QUAD isc_112;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_113;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_114;	/* RDB$VIEW_BLR */
          char  isc_115 [32];	/* RDB$RELATION_NAME */
          short isc_116;	/* isc_utility */
          short isc_117;	/* RDB$RELATION_ID */
          short isc_118;	/* RDB$SYSTEM_FLAG */
   } isc_111;
   struct {
          char  isc_121 [32];	/* RDB$OWNER_NAME */
          ISC_QUAD isc_122;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_123;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_124;	/* RDB$DESCRIPTION */
          char  isc_125 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_126;	/* RDB$VIEW_BLR */
          char  isc_127 [32];	/* RDB$RELATION_NAME */
          short isc_128;	/* isc_utility */
          short isc_129;	/* RDB$RELATION_ID */
          short isc_130;	/* gds__null_flag */
          char  isc_131 [254];	/* RDB$EXTERNAL_FILE */
          short isc_132;	/* gds__null_flag */
          short isc_133;	/* gds__null_flag */
          short isc_134;	/* RDB$FLAGS */
          short isc_135;	/* RDB$SYSTEM_FLAG */
   } isc_120;
   struct {
          char  isc_138 [32];	/* RDB$INDEX_NAME */
          char  isc_139 [32];	/* RDB$RELATION_NAME */
          char  isc_140 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_141 [4];	/* RDB$INITIALLY_DEFERRED */
          char  isc_142 [4];	/* RDB$DEFERRABLE */
          char  isc_143 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_144;	/* isc_utility */
          short isc_145;	/* gds__null_flag */
   } isc_137;
   struct {
          char  isc_148 [8];	/* RDB$MATCH_OPTION */
          char  isc_149 [32];	/* RDB$CONST_NAME_UQ */
          char  isc_150 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_151 [12];	/* RDB$DELETE_RULE */
          char  isc_152 [12];	/* RDB$UPDATE_RULE */
          short isc_153;	/* isc_utility */
   } isc_147;
   struct {
          ISC_QUAD isc_158;	/* RDB$DESCRIPTION */
          char  isc_159 [32];	/* RDB$FIELD_SOURCE */
          char  isc_160 [32];	/* RDB$PARAMETER_NAME */
          short isc_161;	/* isc_utility */
          short isc_162;	/* RDB$PARAMETER_TYPE */
          short isc_163;	/* RDB$PARAMETER_NUMBER */
   } isc_157;
   struct {
          char  isc_156 [32];	/* RDB$PROCEDURE_NAME */
   } isc_155;
   struct {
          char  isc_166 [32];	/* RDB$OWNER_NAME */
          char  isc_167 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_168;	/* RDB$PROCEDURE_BLR */
          ISC_QUAD isc_169;	/* RDB$PROCEDURE_SOURCE */
          ISC_QUAD isc_170;	/* RDB$DESCRIPTION */
          char  isc_171 [32];	/* RDB$PROCEDURE_NAME */
          short isc_172;	/* isc_utility */
          short isc_173;	/* gds__null_flag */
          short isc_174;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_175;	/* RDB$PROCEDURE_INPUTS */
   } isc_165;
   struct {
          short isc_180;	/* isc_utility */
          short isc_181;	/* gds__null_flag */
          short isc_182;	/* RDB$FIELD_PRECISION */
   } isc_179;
   struct {
          char  isc_178 [32];	/* RDB$FIELD_NAME */
   } isc_177;
   struct {
          ISC_QUAD isc_187;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_188;	/* RDB$DEFAULT_SOURCE */
          short isc_189;	/* isc_utility */
          short isc_190;	/* gds__null_flag */
          short isc_191;	/* RDB$COLLATION_ID */
          short isc_192;	/* gds__null_flag */
          short isc_193;	/* RDB$CHARACTER_SET_ID */
          short isc_194;	/* gds__null_flag */
          short isc_195;	/* gds__null_flag */
          short isc_196;	/* gds__null_flag */
          short isc_197;	/* RDB$CHARACTER_LENGTH */
          short isc_198;	/* gds__null_flag */
          short isc_199;	/* RDB$NULL_FLAG */
   } isc_186;
   struct {
          char  isc_185 [32];	/* RDB$FIELD_NAME */
   } isc_184;
   struct {
          short isc_204;	/* isc_utility */
          short isc_205;	/* RDB$DIMENSIONS */
          short isc_206;	/* RDB$EXTERNAL_SCALE */
          short isc_207;	/* RDB$EXTERNAL_TYPE */
          short isc_208;	/* RDB$EXTERNAL_LENGTH */
   } isc_203;
   struct {
          char  isc_202 [32];	/* RDB$FIELD_NAME */
   } isc_201;
   struct {
          ISC_QUAD isc_211;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_212;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_213;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_214;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_215;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_216;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_217;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_218;	/* RDB$QUERY_HEADER */
          char  isc_219 [32];	/* RDB$QUERY_NAME */
          char  isc_220 [32];	/* RDB$FIELD_NAME */
          short isc_221;	/* isc_utility */
          short isc_222;	/* RDB$SYSTEM_FLAG */
          short isc_223;	/* RDB$SEGMENT_LENGTH */
          short isc_224;	/* RDB$FIELD_SCALE */
          short isc_225;	/* RDB$FIELD_SUB_TYPE */
          short isc_226;	/* RDB$FIELD_LENGTH */
          short isc_227;	/* RDB$FIELD_TYPE */
          char  isc_228 [126];	/* RDB$EDIT_STRING */
   } isc_210;
   struct {
          ISC_QUAD isc_231;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_232;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_233;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_234;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_235;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_236;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_237;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_238;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_239;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_240;	/* RDB$QUERY_HEADER */
          char  isc_241 [32];	/* RDB$QUERY_NAME */
          char  isc_242 [32];	/* RDB$FIELD_NAME */
          short isc_243;	/* isc_utility */
          short isc_244;	/* gds__null_flag */
          short isc_245;	/* RDB$FIELD_PRECISION */
          short isc_246;	/* gds__null_flag */
          short isc_247;	/* RDB$COLLATION_ID */
          short isc_248;	/* gds__null_flag */
          short isc_249;	/* RDB$CHARACTER_SET_ID */
          short isc_250;	/* gds__null_flag */
          short isc_251;	/* gds__null_flag */
          short isc_252;	/* gds__null_flag */
          short isc_253;	/* RDB$CHARACTER_LENGTH */
          short isc_254;	/* gds__null_flag */
          short isc_255;	/* RDB$NULL_FLAG */
          short isc_256;	/* RDB$DIMENSIONS */
          short isc_257;	/* RDB$EXTERNAL_SCALE */
          short isc_258;	/* RDB$EXTERNAL_TYPE */
          short isc_259;	/* RDB$EXTERNAL_LENGTH */
          short isc_260;	/* RDB$SYSTEM_FLAG */
          short isc_261;	/* RDB$SEGMENT_LENGTH */
          short isc_262;	/* RDB$FIELD_SCALE */
          short isc_263;	/* RDB$FIELD_SUB_TYPE */
          short isc_264;	/* RDB$FIELD_LENGTH */
          short isc_265;	/* RDB$FIELD_TYPE */
          char  isc_266 [126];	/* RDB$EDIT_STRING */
   } isc_230;
   struct {
          char  isc_269 [32];	/* RDB$GENERATOR_NAME */
          short isc_270;	/* isc_utility */
   } isc_268;
   struct {
          short isc_276;	/* isc_utility */
          short isc_277;	/* gds__null_flag */
          short isc_278;	/* RDB$CHARACTER_SET_ID */
   } isc_275;
   struct {
          char  isc_273 [32];	/* RDB$FUNCTION_NAME */
          short isc_274;	/* RDB$ARGUMENT_POSITION */
   } isc_272;
   struct {
          char  isc_283 [32];	/* RDB$FUNCTION_NAME */
          short isc_284;	/* isc_utility */
          short isc_285;	/* RDB$FIELD_SUB_TYPE */
          short isc_286;	/* RDB$FIELD_LENGTH */
          short isc_287;	/* RDB$FIELD_SCALE */
          short isc_288;	/* RDB$FIELD_TYPE */
          short isc_289;	/* RDB$MECHANISM */
          short isc_290;	/* RDB$ARGUMENT_POSITION */
   } isc_282;
   struct {
          char  isc_281 [32];	/* RDB$FUNCTION_NAME */
   } isc_280;
   struct {
          char  isc_295 [32];	/* RDB$FUNCTION_NAME */
          short isc_296;	/* isc_utility */
          short isc_297;	/* gds__null_flag */
          short isc_298;	/* RDB$FIELD_PRECISION */
          short isc_299;	/* gds__null_flag */
          short isc_300;	/* RDB$CHARACTER_SET_ID */
          short isc_301;	/* RDB$FIELD_SUB_TYPE */
          short isc_302;	/* RDB$FIELD_LENGTH */
          short isc_303;	/* RDB$FIELD_SCALE */
          short isc_304;	/* RDB$FIELD_TYPE */
          short isc_305;	/* RDB$MECHANISM */
          short isc_306;	/* RDB$ARGUMENT_POSITION */
   } isc_294;
   struct {
          char  isc_293 [32];	/* RDB$FUNCTION_NAME */
   } isc_292;
   struct {
          char  isc_309 [32];	/* RDB$QUERY_NAME */
          char  isc_310 [32];	/* RDB$ENTRYPOINT */
          ISC_QUAD isc_311;	/* RDB$DESCRIPTION */
          char  isc_312 [32];	/* RDB$FUNCTION_NAME */
          short isc_313;	/* isc_utility */
          short isc_314;	/* RDB$FUNCTION_TYPE */
          short isc_315;	/* RDB$RETURN_ARGUMENT */
          char  isc_316 [254];	/* RDB$MODULE_NAME */
   } isc_308;
   struct {
          char  isc_319 [32];	/* RDB$ENTRYPOINT */
          ISC_QUAD isc_320;	/* RDB$DESCRIPTION */
          char  isc_321 [32];	/* RDB$FUNCTION_NAME */
          short isc_322;	/* isc_utility */
          short isc_323;	/* RDB$OUTPUT_SUB_TYPE */
          short isc_324;	/* RDB$INPUT_SUB_TYPE */
          char  isc_325 [254];	/* RDB$MODULE_NAME */
   } isc_318;
   struct {
          char  isc_328 [32];	/* RDB$FIELD_NAME */
          SLONG isc_329;	/* RDB$UPPER_BOUND */
          SLONG isc_330;	/* RDB$LOWER_BOUND */
          short isc_331;	/* isc_utility */
          short isc_332;	/* RDB$DIMENSION */
   } isc_327;
   struct {
          ISC_QUAD isc_335;	/* RDB$DESCRIPTION */
          char  isc_336 [32];	/* RDB$EXCEPTION_NAME */
          short isc_337;	/* isc_utility */
          char  isc_338 [79];	/* RDB$MESSAGE */
   } isc_334;
   struct {
          char  isc_341 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_342;	/* isc_utility */
          short isc_343;	/* gds__null_flag */
   } isc_340;
   struct {
          ISC_QUAD isc_346;	/* RDB$DESCRIPTION */
          short isc_347;	/* isc_utility */
   } isc_345;
   struct {
          char  isc_350 [32];	/* RDB$SECURITY_CLASS */
          short isc_351;	/* isc_utility */
          short isc_352;	/* gds__null_flag */
   } isc_349;
   struct {
          char  isc_355 [32];	/* RDB$CHARACTER_SET_NAME */
          ISC_QUAD isc_356;	/* RDB$DESCRIPTION */
          char  isc_357 [32];	/* RDB$SECURITY_CLASS */
          short isc_358;	/* isc_utility */
          short isc_359;	/* gds__null_flag */
          short isc_360;	/* gds__null_flag */
   } isc_354;
   struct {
          char  isc_363 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_364;	/* RDB$DESCRIPTION */
          char  isc_365 [32];	/* RDB$COLLATION_NAME */
          short isc_366;	/* isc_utility */
          short isc_367;	/* gds__null_flag */
          short isc_368;	/* gds__null_flag */
          short isc_369;	/* RDB$SYSTEM_FLAG */
          short isc_370;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_371;	/* RDB$CHARACTER_SET_ID */
          short isc_372;	/* RDB$COLLATION_ID */
   } isc_362;
   struct {
          char  isc_375 [32];	/* RDB$TRIGGER_NAME */
          char  isc_376 [32];	/* RDB$CONSTRAINT_NAME */
          short isc_377;	/* isc_utility */
          short isc_378;	/* gds__null_flag */
   } isc_374;
   struct {
          char  isc_381 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_382;	/* RDB$DESCRIPTION */
          char  isc_383 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_384 [32];	/* RDB$FORM_OF_USE */
          char  isc_385 [32];	/* RDB$CHARACTER_SET_NAME */
          SLONG isc_386;	/* RDB$NUMBER_OF_CHARACTERS */
          short isc_387;	/* isc_utility */
          short isc_388;	/* RDB$BYTES_PER_CHARACTER */
          short isc_389;	/* gds__null_flag */
          short isc_390;	/* gds__null_flag */
          short isc_391;	/* RDB$SYSTEM_FLAG */
          short isc_392;	/* RDB$CHARACTER_SET_ID */
          short isc_393;	/* gds__null_flag */
          short isc_394;	/* gds__null_flag */
   } isc_380;
   struct {
          short isc_400;	/* isc_utility */
   } isc_399;
   struct {
          char  isc_397 [32];	/* RDB$FIELD_NAME */
          char  isc_398 [32];	/* RDB$RELATION_NAME */
   } isc_396;
   struct {
          char  isc_405 [32];	/* RDB$RELATION_NAME */
          short isc_406;	/* isc_utility */
          short isc_407;	/* RDB$VIEW_CONTEXT */
   } isc_404;
   struct {
          char  isc_403 [32];	/* RDB$VIEW_NAME */
   } isc_402;
   struct {
          char  isc_412 [32];	/* RDB$CONTEXT_NAME */
          char  isc_413 [32];	/* RDB$RELATION_NAME */
          short isc_414;	/* isc_utility */
          short isc_415;	/* RDB$VIEW_CONTEXT */
   } isc_411;
   struct {
          char  isc_410 [32];	/* RDB$VIEW_NAME */
   } isc_409;
   struct {
          char  isc_420 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_421;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_422;	/* RDB$EXPRESSION_SOURCE */
          short isc_423;	/* isc_utility */
          short isc_424;	/* gds__null_flag */
          short isc_425;	/* gds__null_flag */
          short isc_426;	/* gds__null_flag */
   } isc_419;
   struct {
          char  isc_418 [32];	/* RDB$INDEX_NAME */
   } isc_417;
   struct {
          short isc_431;	/* isc_utility */
          short isc_432;	/* RDB$INDEX_TYPE */
   } isc_430;
   struct {
          char  isc_429 [32];	/* RDB$INDEX_NAME */
   } isc_428;
   struct {
          char  isc_437 [32];	/* RDB$FIELD_NAME */
          short isc_438;	/* isc_utility */
   } isc_436;
   struct {
          char  isc_435 [32];	/* RDB$INDEX_NAME */
   } isc_434;
   struct {
          short isc_443;	/* isc_utility */
          short isc_444;	/* RDB$INDEX_INACTIVE */
   } isc_442;
   struct {
          char  isc_441 [32];	/* RDB$INDEX_NAME */
   } isc_440;
   struct {
          short isc_450;	/* isc_utility */
   } isc_449;
   struct {
          char  isc_447 [32];	/* RDB$RELATION_NAME */
          char  isc_448 [32];	/* RDB$FIELD_NAME */
   } isc_446;
   struct {
          char  isc_455 [32];	/* RDB$FIELD_NAME */
          short isc_456;	/* isc_utility */
   } isc_454;
   struct {
          char  isc_453 [32];	/* RDB$INDEX_NAME */
   } isc_452;
   struct {
          ISC_QUAD isc_461;	/* RDB$DESCRIPTION */
          char  isc_462 [32];	/* RDB$INDEX_NAME */
          short isc_463;	/* isc_utility */
          short isc_464;	/* RDB$UNIQUE_FLAG */
          short isc_465;	/* RDB$SEGMENT_COUNT */
   } isc_460;
   struct {
          char  isc_459 [32];	/* RDB$RELATION_NAME */
   } isc_458;
   struct {
          char  isc_470 [32];	/* RDB$FIELD_NAME */
          short isc_471;	/* isc_utility */
   } isc_469;
   struct {
          char  isc_468 [32];	/* RDB$INDEX_NAME */
   } isc_467;
   struct {
          short isc_477;	/* isc_utility */
   } isc_476;
   struct {
          char  isc_474 [32];	/* RDB$RELATION_NAME */
          char  isc_475 [32];	/* RDB$INDEX_NAME */
   } isc_473;
   struct {
          char  isc_482 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_483;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_484;	/* RDB$EXPRESSION_SOURCE */
          ISC_QUAD isc_485;	/* RDB$DESCRIPTION */
          char  isc_486 [32];	/* RDB$INDEX_NAME */
          short isc_487;	/* isc_utility */
          short isc_488;	/* gds__null_flag */
          short isc_489;	/* gds__null_flag */
          short isc_490;	/* gds__null_flag */
          short isc_491;	/* RDB$INDEX_TYPE */
          short isc_492;	/* RDB$UNIQUE_FLAG */
          short isc_493;	/* RDB$INDEX_INACTIVE */
          short isc_494;	/* RDB$SEGMENT_COUNT */
   } isc_481;
   struct {
          char  isc_480 [32];	/* RDB$RELATION_NAME */
   } isc_479;
   struct {
          SLONG isc_499;	/* RDB$UPPER_BOUND */
          SLONG isc_500;	/* RDB$LOWER_BOUND */
          short isc_501;	/* isc_utility */
          short isc_502;	/* RDB$DIMENSION */
   } isc_498;
   struct {
          char  isc_497 [32];	/* RDB$FIELD_NAME */
   } isc_496;
   struct {
          ISC_QUAD isc_508;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_509;	/* RDB$DEFAULT_VALUE */
          short isc_510;	/* isc_utility */
          short isc_511;	/* gds__null_flag */
          short isc_512;	/* RDB$COLLATION_ID */
          short isc_513;	/* gds__null_flag */
          short isc_514;	/* RDB$CHARACTER_SET_ID */
          short isc_515;	/* gds__null_flag */
          short isc_516;	/* gds__null_flag */
          short isc_517;	/* gds__null_flag */
          short isc_518;	/* RDB$NULL_FLAG */
   } isc_507;
   struct {
          char  isc_505 [32];	/* RDB$RELATION_NAME */
          char  isc_506 [32];	/* RDB$FIELD_NAME */
   } isc_504;
   struct {
          short isc_523;	/* isc_utility */
          short isc_524;	/* RDB$DIMENSIONS */
   } isc_522;
   struct {
          char  isc_521 [32];	/* RDB$FIELD_SOURCE */
   } isc_520;
   struct {
          char  isc_530 [32];	/* RDB$SECURITY_CLASS */
          short isc_531;	/* isc_utility */
   } isc_529;
   struct {
          char  isc_527 [32];	/* RDB$FIELD_NAME */
          char  isc_528 [32];	/* RDB$RELATION_NAME */
   } isc_526;
   struct {
          short isc_537;	/* isc_utility */
          short isc_538;	/* RDB$SYSTEM_FLAG */
   } isc_536;
   struct {
          char  isc_534 [32];	/* RDB$FIELD_NAME */
          char  isc_535 [32];	/* RDB$RELATION_NAME */
   } isc_533;
   struct {
          char  isc_544 [32];	/* RDB$COMPLEX_NAME */
          short isc_545;	/* isc_utility */
   } isc_543;
   struct {
          char  isc_541 [32];	/* RDB$RELATION_NAME */
          char  isc_542 [32];	/* RDB$FIELD_NAME */
   } isc_540;
   struct {
          ISC_QUAD isc_550;	/* RDB$COMPUTED_BLR */
          char  isc_551 [32];	/* RDB$RELATION_NAME */
          char  isc_552 [32];	/* RDB$QUERY_NAME */
          char  isc_553 [32];	/* RDB$BASE_FIELD */
          char  isc_554 [32];	/* RDB$FIELD_SOURCE */
          char  isc_555 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_556;	/* RDB$QUERY_HEADER */
          ISC_QUAD isc_557;	/* RDB$DESCRIPTION */
          short isc_558;	/* isc_utility */
          char  isc_559 [126];	/* RDB$EDIT_STRING */
          short isc_560;	/* gds__null_flag */
          short isc_561;	/* RDB$UPDATE_FLAG */
          short isc_562;	/* RDB$VIEW_CONTEXT */
          short isc_563;	/* gds__null_flag */
          short isc_564;	/* RDB$FIELD_POSITION */
          short isc_565;	/* gds__null_flag */
          short isc_566;	/* gds__null_flag */
          short isc_567;	/* RDB$FIELD_ID */
          short isc_568;	/* RDB$FIELD_SCALE */
          short isc_569;	/* RDB$FIELD_LENGTH */
          short isc_570;	/* RDB$FIELD_SUB_TYPE */
          short isc_571;	/* RDB$FIELD_TYPE */
   } isc_549;
   struct {
          char  isc_548 [32];	/* RDB$RELATION_NAME */
   } isc_547;
   struct {
          ISC_QUAD isc_576;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_577;	/* RDB$DEFAULT_VALUE */
          char  isc_578 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_579;	/* RDB$COMPUTED_BLR */
          char  isc_580 [32];	/* RDB$COMPLEX_NAME */
          char  isc_581 [32];	/* RDB$QUERY_NAME */
          char  isc_582 [32];	/* RDB$BASE_FIELD */
          char  isc_583 [32];	/* RDB$FIELD_SOURCE */
          char  isc_584 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_585;	/* RDB$QUERY_HEADER */
          ISC_QUAD isc_586;	/* RDB$DESCRIPTION */
          short isc_587;	/* isc_utility */
          short isc_588;	/* gds__null_flag */
          short isc_589;	/* RDB$COLLATION_ID */
          short isc_590;	/* gds__null_flag */
          short isc_591;	/* RDB$CHARACTER_SET_ID */
          short isc_592;	/* gds__null_flag */
          short isc_593;	/* gds__null_flag */
          short isc_594;	/* gds__null_flag */
          short isc_595;	/* RDB$NULL_FLAG */
          short isc_596;	/* RDB$DIMENSIONS */
          short isc_597;	/* RDB$SYSTEM_FLAG */
          char  isc_598 [126];	/* RDB$EDIT_STRING */
          short isc_599;	/* gds__null_flag */
          short isc_600;	/* RDB$UPDATE_FLAG */
          short isc_601;	/* RDB$VIEW_CONTEXT */
          short isc_602;	/* gds__null_flag */
          short isc_603;	/* RDB$FIELD_POSITION */
          short isc_604;	/* gds__null_flag */
          short isc_605;	/* gds__null_flag */
          short isc_606;	/* RDB$FIELD_ID */
          short isc_607;	/* RDB$FIELD_SCALE */
          short isc_608;	/* RDB$FIELD_LENGTH */
          short isc_609;	/* RDB$FIELD_SUB_TYPE */
          short isc_610;	/* RDB$FIELD_TYPE */
   } isc_575;
   struct {
          char  isc_574 [32];	/* RDB$RELATION_NAME */
   } isc_573;
#line 511 "backup.epp"

void compress(const UCHAR* data, ULONG length)
{
/**************************************
 *
 *	c o m p r e s s
 *
 **************************************
 *
 * Functional description
 *	Write out data in compressed form.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	const UCHAR* p = data;
	const UCHAR* end = p + length;
	const UCHAR* q = NULL;

	while (p < end)
	{
		for (q = p + 2; q < end && (q[-2] != q[-1] || q[-1] != q[0]); q++)
			;
		USHORT run = (q < end) ? q - p - 2 : end - p;
		if (run)
		{
			for (; run > 127; run -= 127)
			{
				USHORT l = 127;
				put(tdgbl, (UCHAR) (l));
				p = put_block(tdgbl, p, l);
			}
			if (run)
			{
				put(tdgbl, (UCHAR) (run));
				p = put_block(tdgbl, p, run);
			}
		}
		for (q = p; q < end && *q == *p; q++)
			;
		if ((run = q - p) != 0)
		{
			for (; run > 127; run -= 127)
			{
				put(tdgbl, (UCHAR) (-127));
				put(tdgbl, (UCHAR) (*p));
			}
			if (run)
			{
				put(tdgbl, (UCHAR) (-run));
				put(tdgbl, (UCHAR) (*p));
			}
			p = q;
		}
	}
}


int copy( const TEXT* from, TEXT* to, ULONG size_len)
{
/**************************************
 *
 *	c o p y
 *
 **************************************
 *
 * Functional description
 *	Copy a blank or null terminated string into a null terminated
 *	string.
 *
 **************************************/

	const ULONG l = (ULONG) symbol_length (from, size_len);

	MOVE_FAST(from, to, l);
	*(to + l) = '\0';

	return (int) l;
}


void general_on_error(void)
{
/**************************************
 *
 *	g e n e r a l _ o n _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	Handle any general ON_ERROR clause during backup.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	BURP_print_status(isc_status);
	BURP_abort();
}


BURP_FLD get_fields( BURP_REL relation)
{
/**************************************
 *
 *	g e t _ f i e l d s
 *
 **************************************
 *
 * Functional description
 *	Get fields for a relation.  Test
 *	capabilities and get system specific
 *
 **************************************/
	BURP_FLD field;
	ISC_QUAD *blob_id;

	TGBL tdgbl = GET_THREAD_DATA;

	USHORT count = 1;
	BURP_FLD fields = NULL;

/* if we have all capabilities, use the first request to get the 
   most performance out of the latest engine; if we don't 
   have one of the capabilities we must use the second set of 
   requests--this requires more code but it is well worth it 
   for the performance benefits, especially remotely--deej */

	if ((tdgbl->BCK_capabilities & BCK_attributes_v3) &&
		(tdgbl->BCK_capabilities & BCK_ods8) &&
		(tdgbl->BCK_capabilities & BCK_rfr_sys_flag) &&
		(tdgbl->BCK_capabilities & BCK_security))
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle1)
			X IN RDB$RELATION_FIELDS CROSS
			Y IN RDB$FIELDS WITH
			X.RDB$FIELD_SOURCE = Y.RDB$FIELD_NAME AND
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_get_fields_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_fields_req_handle1, (short) sizeof (isc_572), (char *) isc_572);
		isc_vtov ((char*)relation->rel_name, (char*)isc_573.isc_574, 32);
		if (tdgbl->handles_get_fields_req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_573, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle1, (short) 1, (short) 404, &isc_575, (short) 0);
		   if (!isc_575.isc_587 || isc_status [1]) break;
#line 648 "backup.epp"
	
			field = (BURP_FLD) BURP_alloc_zero(sizeof(burp_fld));
			field->fld_number = count++;
			field->fld_type = /*Y.RDB$FIELD_TYPE*/
					  isc_575.isc_610;
#line 652 "backup.epp"
			field->fld_sub_type = /*Y.RDB$FIELD_SUB_TYPE*/
					      isc_575.isc_609;
#line 653 "backup.epp"
			field->fld_length = /*Y.RDB$FIELD_LENGTH*/
					    isc_575.isc_608;
#line 654 "backup.epp"
			field->fld_scale = /*Y.RDB$FIELD_SCALE*/
					   isc_575.isc_607;
#line 655 "backup.epp"
			field->fld_id = /*X.RDB$FIELD_ID*/
					isc_575.isc_606;
#line 656 "backup.epp"
	
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_575.isc_605)
#line 658 "backup.epp"
			{
				blob_id = &/*X.RDB$DESCRIPTION*/
					   isc_575.isc_586;
#line 660 "backup.epp"
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_description = /*X.RDB$DESCRIPTION*/
								 isc_575.isc_586;
#line 662 "backup.epp"
			}
	
			if (!/*X.RDB$QUERY_HEADER.NULL*/
			     isc_575.isc_604)
#line 665 "backup.epp"
			{
				blob_id = &/*X.RDB$QUERY_HEADER*/
					   isc_575.isc_585;
#line 667 "backup.epp"
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_query_header = /*X.RDB$QUERY_HEADER*/
								  isc_575.isc_585;
#line 669 "backup.epp"
			}

			if (/*X.RDB$FIELD_POSITION.NULL*/
			    isc_575.isc_602)
#line 672 "backup.epp"
				field->fld_flags |= FLD_position_missing;
			else
				field->fld_position = /*X.RDB$FIELD_POSITION*/
						      isc_575.isc_603;
#line 675 "backup.epp"
			field->fld_view_context = /*X.RDB$VIEW_CONTEXT*/
						  isc_575.isc_601;
#line 676 "backup.epp"
			if (/*X.RDB$UPDATE_FLAG.NULL*/
			    isc_575.isc_599)
#line 677 "backup.epp"
				field->fld_flags |= FLD_update_missing;
			else
				field->fld_update_flag = /*X.RDB$UPDATE_FLAG*/
							 isc_575.isc_600;
#line 680 "backup.epp"

			COPY (/*X.RDB$FIELD_NAME*/
			      isc_575.isc_584, field->fld_name);
#line 682 "backup.epp"
			COPY (/*X.RDB$FIELD_SOURCE*/
			      isc_575.isc_583, field->fld_source);
#line 683 "backup.epp"
			COPY (/*X.RDB$BASE_FIELD*/
			      isc_575.isc_582, field->fld_base);
#line 684 "backup.epp"
			COPY (/*X.RDB$QUERY_NAME*/
			      isc_575.isc_581, field->fld_query_name);
#line 685 "backup.epp"
			COPY (/*X.RDB$EDIT_STRING*/
			      isc_575.isc_598, field->fld_edit_string);
#line 686 "backup.epp"
			COPY (/*X.RDB$COMPLEX_NAME*/
			      isc_575.isc_580, field->fld_complex_name);
#line 687 "backup.epp"

			blob_id = &/*Y.RDB$COMPUTED_BLR*/
				   isc_575.isc_579;
#line 689 "backup.epp"

			if (blob_id->gds_quad_low || blob_id->gds_quad_high) {
				field->fld_flags |= FLD_computed;
			}

			field->fld_system_flag = /*X.RDB$SYSTEM_FLAG*/
						 isc_575.isc_597;
#line 695 "backup.epp"

			COPY (/*X.RDB$SECURITY_CLASS*/
			      isc_575.isc_578, field->fld_security_class);
#line 697 "backup.epp"

			// use the fld_flags to mark the field as an array and
			// to differentiate it from other blobs

			if (/*Y.RDB$DIMENSIONS*/
			    isc_575.isc_596) {
#line 702 "backup.epp"
				field->fld_flags |= FLD_array;
				field->fld_dimensions = /*Y.RDB$DIMENSIONS*/
							isc_575.isc_596;
#line 704 "backup.epp"
				if (field->fld_dimensions < 0) {
					BURP_error_redirect (NULL, 52, field->fld_name, NULL);
				}
				// msg 52 array dimension for field %s is invalid
				get_ranges (field);
			}

			if (!/*X.RDB$NULL_FLAG.NULL*/
			     isc_575.isc_594) {
#line 712 "backup.epp"
				field->fld_null_flag = /*X.RDB$NULL_FLAG*/
						       isc_575.isc_595;
#line 713 "backup.epp"
				field->fld_flags |= FLD_null_flag;
			}

			if (!/*X.RDB$DEFAULT_VALUE.NULL*/
			     isc_575.isc_593) {
#line 717 "backup.epp"
				blob_id = &/*X.RDB$DEFAULT_VALUE*/
					   isc_575.isc_577;
#line 718 "backup.epp"
				if (blob_id->gds_quad_low || blob_id->gds_quad_high) {
					field->fld_default_value = /*X.RDB$DEFAULT_VALUE*/
								   isc_575.isc_577;
#line 720 "backup.epp"
				}
			}

			if (!/*X.RDB$DEFAULT_SOURCE.NULL*/
			     isc_575.isc_592) {
#line 724 "backup.epp"
				blob_id = &/*X.RDB$DEFAULT_SOURCE*/
					   isc_575.isc_576;
#line 725 "backup.epp"
				if (blob_id->gds_quad_low || blob_id->gds_quad_high) {
					field->fld_default_source = /*X.RDB$DEFAULT_SOURCE*/
								    isc_575.isc_576;
#line 727 "backup.epp"
				}
			}

			if (!(/*Y.RDB$CHARACTER_SET_ID.NULL*/
			      isc_575.isc_590)) {
#line 731 "backup.epp"
				field->fld_character_set_id = /*Y.RDB$CHARACTER_SET_ID*/
							      isc_575.isc_591;
#line 732 "backup.epp"
				field->fld_flags |= FLD_charset_flag;
			}

			if (!/*X.RDB$COLLATION_ID.NULL*/
			     isc_575.isc_588) {
#line 736 "backup.epp"
				field->fld_collation_id = /*X.RDB$COLLATION_ID*/
							  isc_575.isc_589;
#line 737 "backup.epp"
				field->fld_flags |= FLD_collate_flag;
			}
	
			field->fld_next = fields;
			fields = field;
	
		/*END_FOR;*/
		   }
		   };
#line 744 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 745 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 747 "backup.epp"
	}
	else {
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle1)
			X IN RDB$RELATION_FIELDS CROSS Y IN RDB$FIELDS
			WITH X.RDB$FIELD_SOURCE = Y.RDB$FIELD_NAME AND
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_get_fields_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_fields_req_handle1, (short) sizeof (isc_546), (char *) isc_546);
		isc_vtov ((char*)relation->rel_name, (char*)isc_547.isc_548, 32);
		if (tdgbl->handles_get_fields_req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_547, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle1, (short) 1, (short) 336, &isc_549, (short) 0);
		   if (!isc_549.isc_558 || isc_status [1]) break;
#line 753 "backup.epp"

			field = (BURP_FLD) BURP_alloc_zero (sizeof(burp_fld));
			field->fld_number = count++;
			field->fld_type = /*Y.RDB$FIELD_TYPE*/
					  isc_549.isc_571;
#line 757 "backup.epp"
			field->fld_sub_type = /*Y.RDB$FIELD_SUB_TYPE*/
					      isc_549.isc_570;
#line 758 "backup.epp"
			field->fld_length = /*Y.RDB$FIELD_LENGTH*/
					    isc_549.isc_569;
#line 759 "backup.epp"
			field->fld_scale = /*Y.RDB$FIELD_SCALE*/
					   isc_549.isc_568;
#line 760 "backup.epp"
			field->fld_id = /*X.RDB$FIELD_ID*/
					isc_549.isc_567;
#line 761 "backup.epp"
			if (!/*X.RDB$DESCRIPTION.NULL*/
			     isc_549.isc_566) {
#line 762 "backup.epp"
				blob_id = &/*X.RDB$DESCRIPTION*/
					   isc_549.isc_557;
#line 763 "backup.epp"
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_description = /*X.RDB$DESCRIPTION*/
								 isc_549.isc_557;
#line 765 "backup.epp"
			}
			if (!/*X.RDB$QUERY_HEADER.NULL*/
			     isc_549.isc_565) {
#line 767 "backup.epp"
				blob_id = &/*X.RDB$QUERY_HEADER*/
					   isc_549.isc_556;
#line 768 "backup.epp"
				if (blob_id->gds_quad_low || blob_id->gds_quad_high)
					field->fld_query_header = /*X.RDB$QUERY_HEADER*/
								  isc_549.isc_556;
#line 770 "backup.epp"
			}
			if (/*X.RDB$FIELD_POSITION.NULL*/
			    isc_549.isc_563)
#line 772 "backup.epp"
				field->fld_flags |= FLD_position_missing;
			else
				field->fld_position = /*X.RDB$FIELD_POSITION*/
						      isc_549.isc_564;
#line 775 "backup.epp"
			field->fld_view_context = /*X.RDB$VIEW_CONTEXT*/
						  isc_549.isc_562;
#line 776 "backup.epp"
			if (/*X.RDB$UPDATE_FLAG.NULL*/
			    isc_549.isc_560)
#line 777 "backup.epp"
				field->fld_flags |= FLD_update_missing;
			else
				field->fld_update_flag = /*X.RDB$UPDATE_FLAG*/
							 isc_549.isc_561;
#line 780 "backup.epp"
			COPY (/*X.RDB$FIELD_NAME*/
			      isc_549.isc_555, field->fld_name);
#line 781 "backup.epp"
			COPY (/*X.RDB$FIELD_SOURCE*/
			      isc_549.isc_554, field->fld_source);
#line 782 "backup.epp"
			COPY (/*X.RDB$BASE_FIELD*/
			      isc_549.isc_553, field->fld_base);
#line 783 "backup.epp"
			COPY (/*X.RDB$QUERY_NAME*/
			      isc_549.isc_552, field->fld_query_name);
#line 784 "backup.epp"
			COPY (/*X.RDB$EDIT_STRING*/
			      isc_549.isc_559, field->fld_edit_string);
#line 785 "backup.epp"
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle2)
					RFR IN RDB$RELATION_FIELDS WITH RFR.RDB$FIELD_NAME = X.RDB$FIELD_NAME AND
					RFR.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle2)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_fields_req_handle2, (short) sizeof (isc_539), (char *) isc_539);
				isc_vtov ((char*)isc_549.isc_551, (char*)isc_540.isc_541, 32);
				isc_vtov ((char*)isc_549.isc_555, (char*)isc_540.isc_542, 32);
				if (tdgbl->handles_get_fields_req_handle2)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_540, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle2, (short) 1, (short) 34, &isc_543, (short) 0);
				   if (!isc_543.isc_545 || isc_status [1]) break;
#line 790 "backup.epp"
					COPY (/*RFR.RDB$COMPLEX_NAME*/
					      isc_543.isc_544, field->fld_complex_name);
#line 791 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 792 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 793 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 795 "backup.epp"
			}
			blob_id = &/*Y.RDB$COMPUTED_BLR*/
				   isc_549.isc_550;
#line 797 "backup.epp"
			if (blob_id->gds_quad_low || blob_id->gds_quad_high)
				field->fld_flags |= FLD_computed;
			if (tdgbl->BCK_capabilities & BCK_rfr_sys_flag)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle3)
					RFR IN RDB$RELATION_FIELDS WITH
					RFR.RDB$RELATION_NAME = relation->rel_name
					AND RFR.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle3)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_fields_req_handle3, (short) sizeof (isc_532), (char *) isc_532);
				isc_vtov ((char*)isc_549.isc_555, (char*)isc_533.isc_534, 32);
				isc_vtov ((char*)relation->rel_name, (char*)isc_533.isc_535, 32);
				if (tdgbl->handles_get_fields_req_handle3)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle3, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_533, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle3, (short) 1, (short) 4, &isc_536, (short) 0);
				   if (!isc_536.isc_537 || isc_status [1]) break;
#line 805 "backup.epp"
					field->fld_system_flag = /*RFR.RDB$SYSTEM_FLAG*/
								 isc_536.isc_538;
#line 806 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 807 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 808 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 810 "backup.epp"
			}
			if (tdgbl->BCK_capabilities & BCK_security)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle4)
					RFR IN RDB$RELATION_FIELDS WITH
					RFR.RDB$RELATION_NAME = relation->rel_name
					AND RFR.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle4)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_fields_req_handle4, (short) sizeof (isc_525), (char *) isc_525);
				isc_vtov ((char*)isc_549.isc_555, (char*)isc_526.isc_527, 32);
				isc_vtov ((char*)relation->rel_name, (char*)isc_526.isc_528, 32);
				if (tdgbl->handles_get_fields_req_handle4)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle4, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_526, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle4, (short) 1, (short) 34, &isc_529, (short) 0);
				   if (!isc_529.isc_531 || isc_status [1]) break;
#line 817 "backup.epp"
					COPY (/*RFR.RDB$SECURITY_CLASS*/
					      isc_529.isc_530, field->fld_security_class);
#line 818 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 819 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 820 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 822 "backup.epp"
			}
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle5)
					RF IN RDB$FIELDS WITH RF.RDB$FIELD_NAME = X.RDB$FIELD_SOURCE*/
				{
                                if (!tdgbl->handles_get_fields_req_handle5)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_fields_req_handle5, (short) sizeof (isc_519), (char *) isc_519);
				isc_vtov ((char*)isc_549.isc_554, (char*)isc_520.isc_521, 32);
				if (tdgbl->handles_get_fields_req_handle5)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle5, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_520, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle5, (short) 1, (short) 4, &isc_522, (short) 0);
				   if (!isc_522.isc_523 || isc_status [1]) break;
#line 827 "backup.epp"
					// use the fld_flags to mark the field as an array and
					// to differentiate it from other blobs
					if (/*RF.RDB$DIMENSIONS*/
					    isc_522.isc_524)
#line 830 "backup.epp"
					{
						field->fld_flags |= FLD_array;
						field->fld_dimensions = /*RF.RDB$DIMENSIONS*/
									isc_522.isc_524;
#line 833 "backup.epp"
						if (field->fld_dimensions < 0) {
							BURP_error_redirect (NULL, 52, field->fld_name, NULL);
						}
							// msg 52 array dimension for field %s is invalid
						get_ranges (field);
					}
				/*END_FOR;*/
				   }
				   };
#line 840 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 841 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 843 "backup.epp"
			}
			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_get_fields_req_handle6)
					X2 IN RDB$RELATION_FIELDS CROSS F2 IN RDB$FIELDS
					WITH X2.RDB$FIELD_NAME = X.RDB$FIELD_NAME
					AND X2.RDB$RELATION_NAME EQ relation->rel_name
					AND X2.RDB$FIELD_SOURCE EQ F2.RDB$FIELD_NAME*/
				{
                                if (!tdgbl->handles_get_fields_req_handle6)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_fields_req_handle6, (short) sizeof (isc_503), (char *) isc_503);
				isc_vtov ((char*)relation->rel_name, (char*)isc_504.isc_505, 32);
				isc_vtov ((char*)isc_549.isc_555, (char*)isc_504.isc_506, 32);
				if (tdgbl->handles_get_fields_req_handle6)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle6, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_504, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_fields_req_handle6, (short) 1, (short) 34, &isc_507, (short) 0);
				   if (!isc_507.isc_510 || isc_status [1]) break;
#line 851 "backup.epp"

					if (!/*X2.RDB$NULL_FLAG.NULL*/
					     isc_507.isc_517)
#line 853 "backup.epp"
					{
						field->fld_null_flag = /*X2.RDB$NULL_FLAG*/
								       isc_507.isc_518;
#line 855 "backup.epp"
						field->fld_flags |= FLD_null_flag;
					}
					if (!/*X2.RDB$DEFAULT_VALUE.NULL*/
					     isc_507.isc_516)
#line 858 "backup.epp"
					{
						blob_id = &/*X2.RDB$DEFAULT_VALUE*/
							   isc_507.isc_509;
#line 860 "backup.epp"
						if (blob_id->gds_quad_low || blob_id->gds_quad_high)
							field->fld_default_value = /*X2.RDB$DEFAULT_VALUE*/
										   isc_507.isc_509;
#line 862 "backup.epp"
					}
					if (!/*X2.RDB$DEFAULT_SOURCE.NULL*/
					     isc_507.isc_515)
#line 864 "backup.epp"
					{
						blob_id = &/*X2.RDB$DEFAULT_SOURCE*/
							   isc_507.isc_508;
#line 866 "backup.epp"
						if (blob_id->gds_quad_low || blob_id->gds_quad_high)
							field->fld_default_source = /*X2.RDB$DEFAULT_SOURCE*/
										    isc_507.isc_508;
#line 868 "backup.epp"
					}
					if (!(/*F2.RDB$CHARACTER_SET_ID.NULL*/
					      isc_507.isc_513))
#line 870 "backup.epp"
					{
						field->fld_character_set_id = /*F2.RDB$CHARACTER_SET_ID*/
									      isc_507.isc_514;
#line 872 "backup.epp"
						field->fld_flags |= FLD_charset_flag;
					}
					if (!/*X2.RDB$COLLATION_ID.NULL*/
					     isc_507.isc_511)
#line 875 "backup.epp"
					{
						field->fld_collation_id = /*X2.RDB$COLLATION_ID*/
									  isc_507.isc_512;
#line 877 "backup.epp"
						field->fld_flags |= FLD_collate_flag;
					}
				/*END_FOR;*/
				   }
				   };
#line 880 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 881 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 883 "backup.epp"
			}
	
			field->fld_next = fields;
			fields = field;
	
		/*END_FOR;*/
		   }
		   };
#line 889 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 890 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 892 "backup.epp"
	}

	return fields;
}


SINT64 get_gen_id( const TEXT* name, SSHORT name_len)
{
/**************************************
 *
 *	g e t _ g e n _ i d
 *
 **************************************
 *
 * Functional description
 *	Read id for a generator;
 *
 **************************************/
	UCHAR blr_buffer[100];	// enough to fit blr 

	TGBL tdgbl = GET_THREAD_DATA;

	isc_handle gen_id_reqh = NULL;
	UCHAR* blr = blr_buffer;

/* If this is ODS 10 (IB version 6.0) or greater, build BLR to retrieve
   the 64-bit value of the generator.  If not, build BLR to retrieve the
   32-bit value, which we will cast to the expected INT64 format.
*/
	if (tdgbl->BCK_capabilities & BCK_ods10)
	{
		// build the blr with the right relation name and 64-bit results. 
		stuff(&blr, blr_version5);
		stuff(&blr, blr_begin);
		stuff(&blr, blr_message);
		stuff(&blr, 0);
		stuff_word(&blr, 1);
		stuff(&blr, blr_int64);
		stuff(&blr, 0);
		stuff(&blr, blr_send);
		stuff(&blr, 0);
		stuff(&blr, blr_assignment);
		stuff(&blr, blr_gen_id);
		stuff(&blr, name_len);
		while (name_len--)
		{
			const UCHAR c = *name++;
			stuff(&blr, c);
		}
		stuff(&blr, blr_literal);
		stuff(&blr, blr_long);
		stuff(&blr, 0);
		stuff_word(&blr, 0);
		stuff_word(&blr, 0);
		stuff(&blr, blr_parameter);
		stuff(&blr, 0);
		stuff_word(&blr, 0);
		stuff(&blr, blr_end);
		stuff(&blr, blr_eoc);
	}
	else
	{
		// build the blr with the right relation name and 32-bit results 
		stuff(&blr, blr_version4);
		stuff(&blr, blr_begin);
		stuff(&blr, blr_message);
		stuff(&blr, 0);
		stuff_word(&blr, 1);
		stuff(&blr, blr_long);
		stuff(&blr, 0);
		stuff(&blr, blr_send);
		stuff(&blr, 0);
		stuff(&blr, blr_assignment);
		stuff(&blr, blr_gen_id);
		stuff(&blr, name_len);
		while (name_len--)
		{
			const UCHAR c = *name++;
			stuff(&blr, c);
		}
		stuff(&blr, blr_literal);
		stuff(&blr, blr_long);
		stuff(&blr, 0);
		stuff_word(&blr, 0);
		stuff_word(&blr, 0);
		stuff(&blr, blr_parameter);
		stuff(&blr, 0);
		stuff_word(&blr, 0);
		stuff(&blr, blr_end);
		stuff(&blr, blr_eoc);
	}

#ifdef DEBUG
	if (debug_on)
		isc_print_blr((const char*)blr_buffer, NULL, NULL, 0);
#endif

	ISC_STATUS_ARRAY status_vector;
	const SSHORT blr_length = blr - blr_buffer;
	if (isc_compile_request(status_vector, &DB, &gen_id_reqh,
							blr_length, (const char*) blr_buffer))
	{
		// if there's no gen_id, never mind ... 
		return 0;
	}

	if (isc_start_request(status_vector, &gen_id_reqh,
						  &gds_trans, // use the same one generated by gpre
						  0))
	{
		BURP_error_redirect(status_vector, 25, NULL, NULL);
		// msg 25 Failed in put_blr_gen_id 
	}


	SINT64 read_msg1;
	if (tdgbl->BCK_capabilities & BCK_ods10)
	{
		if (isc_receive(status_vector, &gen_id_reqh, 0, sizeof(read_msg1),
						&read_msg1, 0))
		{
			BURP_error_redirect(status_vector, 25, NULL, NULL);
			// msg 25 Failed in put_blr_gen_id 
		}
	}
	else
	{
		SLONG read_msg0;
		if (isc_receive(status_vector, &gen_id_reqh, 0, sizeof(read_msg0),
						&read_msg0, 0))
		{
			BURP_error_redirect(status_vector, 25, NULL, NULL);
			// msg 25 Failed in put_blr_gen_id 
		}
		read_msg1 = (SINT64) read_msg0;
	}

	isc_release_request(status_vector, &gen_id_reqh);

	return read_msg1;
}


void get_ranges( BURP_FLD field)
{
/**************************************
 *
 *	g e t _ r a n g e s
 *
 **************************************
 *
 * Functional description
 *	Fill in the range low and high bounds by reading 
 *      the ranges in rdb$field_dimensions.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	SLONG* rp = field->fld_ranges;
	USHORT count = 0;

/* Get the array dimensions in the rdb$field_dimensions */

	/*FOR (REQUEST_HANDLE tdgbl->handles_get_ranges_req_handle1)
		X IN RDB$FIELD_DIMENSIONS 
		WITH X.RDB$FIELD_NAME EQ field->fld_source 
		SORTED BY X.RDB$DIMENSION*/
	{
        if (!tdgbl->handles_get_ranges_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_get_ranges_req_handle1, (short) sizeof (isc_495), (char *) isc_495);
	isc_vtov ((char*)field->fld_source, (char*)isc_496.isc_497, 32);
	if (tdgbl->handles_get_ranges_req_handle1)
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_get_ranges_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_496, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_get_ranges_req_handle1, (short) 1, (short) 12, &isc_498, (short) 0);
	   if (!isc_498.isc_501 || isc_status [1]) break; 
#line 1059 "backup.epp"
	
		if (count != /*X.RDB$DIMENSION*/
			     isc_498.isc_502)
#line 1061 "backup.epp"
			BURP_error_redirect (NULL, 52, field->fld_name, NULL);
			// msg 52 array dimension for field %s is invalid 
		*rp++ = /*X.RDB$LOWER_BOUND*/
			isc_498.isc_500;
#line 1064 "backup.epp"
		*rp++ = /*X.RDB$UPPER_BOUND*/
			isc_498.isc_499;
#line 1065 "backup.epp"
		count++;
	
	/*END_FOR;*/
	   }
	   };
#line 1068 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 1069 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 1071 "backup.epp"

	if (count != field->fld_dimensions)
		BURP_error_redirect(NULL, 52, field->fld_name, NULL);
	// msg 52 array dimension for field %s is invalid 
}


void put_array( BURP_FLD field, BURP_REL relation, ISC_QUAD * blob_id)
{
/**************************************
 *
 *	p u t _ a r r a y 
 *
 **************************************
 *
 * Functional description
 *	Write out an array.  If, however, it's null, don't even bother.
 *
 **************************************/
	SLONG range_buffer[16];	// enough for 16 dimensions
	UCHAR blr_buffer[200];		// enough for a sdl with 16 dimensions 

	TGBL tdgbl = GET_THREAD_DATA;

// If the array is null, don't store it.  It will be restored as null. 

	if (!blob_id->gds_quad_low && !blob_id->gds_quad_high)
		return;

	LSTRING xdr_buffer;
	xdr_buffer.lstr_allocated = 0;

	UCHAR* blr = blr_buffer;
	const SLONG* const end_ranges = field->fld_ranges + 2 * field->fld_dimensions;

	USHORT field_length = field->fld_length;
	if (tdgbl->gbl_sw_transportable)
		xdr_buffer.lstr_length = field_length + 3;

// build the sdl 

	stuff(&blr, isc_sdl_version1);

	stuff(&blr, isc_sdl_struct);
	stuff(&blr, 1);

	stuff(&blr, field->fld_type);

	if (field->fld_type == blr_short ||
		field->fld_type == blr_long ||
		field->fld_type == blr_quad ||
		field->fld_type == blr_int64)
	{
		stuff(&blr, field->fld_scale);
	}

	if (field->fld_type == blr_text || field->fld_type == blr_varying)
		stuff_word(&blr, field->fld_length);

	if (field->fld_type == blr_varying)
		field_length += sizeof(USHORT);

	stuff(&blr, isc_sdl_rid);
	stuff_word(&blr, relation->rel_id);
	stuff(&blr, isc_sdl_fid);
	stuff_word(&blr, field->fld_id);

	USHORT count;
	const SLONG* range; // used in multiple loops.
	for (range = field->fld_ranges, count = 0; range < end_ranges;
		 range += 2, count++)
	{
		stuff(&blr, isc_sdl_do2);
		stuff(&blr, count);
		stuff(&blr, isc_sdl_long_integer);
		stuff_long(&blr, range[0]);
		stuff(&blr, isc_sdl_long_integer);
		stuff_long(&blr, range[1]);
	}

	stuff(&blr, isc_sdl_element);
	stuff(&blr, 1);
	stuff(&blr, isc_sdl_scalar);
	stuff(&blr, 0);
	stuff(&blr, field->fld_dimensions);

	for (count = 0; count < field->fld_dimensions; count++)
	{
		stuff(&blr, isc_sdl_variable);
		stuff(&blr, count);
	}

	stuff(&blr, isc_sdl_eoc);

#ifdef DEBUG
	if (debug_on)
		PRETTY_print_sdl(blr_buffer, NULL, NULL, 0);
#endif

	const USHORT blr_length = blr - blr_buffer;

/* compute the range size for each dimension = high_range - low_range */

	ULONG slice_length = field_length;
	for (range = field->fld_ranges; range < end_ranges; range += 2)
	{
		slice_length *= (range[1] - range[0] + 1);
		if (tdgbl->gbl_sw_transportable)
			xdr_buffer.lstr_length *= (range[1] - range[0] + 1);
	}
	UCHAR* slice = BURP_alloc(slice_length);

// allocate space for the XDR representation 

	if (tdgbl->gbl_sw_transportable)
	{
		xdr_buffer.lstr_address = BURP_alloc(xdr_buffer.lstr_length);
		xdr_buffer.lstr_allocated = xdr_buffer.lstr_length;
	}

	ISC_STATUS_ARRAY status_vector;
	ISC_LONG return_length = 0;
	if (isc_get_slice(status_vector, &DB, &gds_trans, blob_id,
					  blr_length, (const char*) blr_buffer,
					  0,	// param length for subset of an array handling
					  NULL,	// param for subset of an array handling
					  slice_length, slice, &return_length))
	{
		BURP_print(81, field->fld_name, NULL, NULL, NULL, NULL);
		// msg 81 error accessing blob field %s -- continuing 
		BURP_print_status(status_vector);
#ifdef DEBUG
		PRETTY_print_sdl(blr_buffer, NULL, NULL, 0);
#endif
		// CVC: At this point I would expected calls to deallocate memory
		// See the end of this function.
		BURP_free(slice);
		if (xdr_buffer.lstr_allocated)
			BURP_free(xdr_buffer.lstr_address);
		return;
	}

	if (return_length != slice_length)
	{
		int i1, i3;
		/* Ugh.  The full array wasn't returned.  We must recompute the top
		   element to backup. */

		SLONG returned_elements = (return_length / field_length) - 1;

		SLONG* returned_range = range_buffer;
		for (i1 = 0, i3 = 0, range = end_ranges - 2;
			 range >= field->fld_ranges; range -= 2, returned_range++, i1++)
		{
			int divisor = 1;
			for (int i2 = (2 * (i1 + 1) + 1); i2 <= field->fld_dimensions * 2;
				 i2 += 2)
			{
				divisor *=
					(field->fld_ranges[i2] - field->fld_ranges[i2 - 1] + 1);
			}
			*returned_range =
				(returned_elements - 1) / divisor + field->fld_ranges[i3];
			returned_elements -=
				(*returned_range - field->fld_ranges[i3]) * divisor;
			i3 += 2;
		}
	}

	put(tdgbl, (UCHAR) (rec_array));
	put_numeric(att_blob_field_number, field->fld_number);
	put_numeric(att_array_dimensions, field->fld_dimensions);

	SLONG* returned_range = range_buffer;
	for (range = field->fld_ranges; range < end_ranges;
		 range += 2, returned_range++)
	{
		put_numeric(att_array_range_low, (int) range[0]);
		if (return_length == slice_length)
			put_numeric(att_array_range_high, (int) range[1]);
		else
			put_numeric(att_array_range_high, (int) *returned_range);
	}

	put(tdgbl, (UCHAR) (att_blob_data));
	put(tdgbl, (UCHAR) (return_length));
	put(tdgbl, (UCHAR) (return_length >> 8));
	put(tdgbl, (UCHAR) (return_length >> 16));
	put(tdgbl, (UCHAR) (return_length >> 24));

	if (return_length)
	{
		UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			LSTRING xdr_slice;
			xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
			xdr_slice.lstr_address = slice;
			return_length =
				CAN_slice(&xdr_buffer, &xdr_slice, TRUE, blr_length,
						  blr_buffer);
			put(tdgbl, (UCHAR) (att_xdr_array));
			put(tdgbl, (UCHAR) (return_length));
			put(tdgbl, (UCHAR) (return_length >> 8));
			put(tdgbl, (UCHAR) (return_length >> 16));
			put(tdgbl, (UCHAR) (return_length >> 24));
			p = xdr_buffer.lstr_address;
		}
		else
			p = slice;
		put_block(tdgbl, p, return_length);
	}

	BURP_free(slice);
	if (xdr_buffer.lstr_allocated)
		BURP_free(xdr_buffer.lstr_address);
}


void put_asciz( const SCHAR attribute, const TEXT* string)
{
/**************************************
 *
 *	p u t _ a s c i z
 *
 **************************************
 *
 * Functional description
 *	Write an attribute starting with a null terminated string.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	ULONG l = strlen(string);

	put(tdgbl, (UCHAR) (attribute));
	put(tdgbl, (UCHAR) (l));
	if (l)
		put_block(tdgbl, (const UCHAR*) string, l);
}


void put_blob( BURP_FLD field, ISC_QUAD * blob_id, ULONG count)
{
/**************************************
 *
 *	p u t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Write out a blob.  If, however, it's null, don't even bother.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	UCHAR  blob_info[32], static_buffer[1024];

	TGBL tdgbl = GET_THREAD_DATA;

// If the blob is null, don't store it.  It will be restored as null. 

	if (!blob_id->gds_quad_high && !blob_id->gds_quad_low)
		return;

// Open the blob and get it's vital statistics 

	isc_handle blob = NULL;

	if (isc_open_blob(status_vector, &DB, &gds_trans, &blob, blob_id))
	{
		BURP_print(81, field->fld_name, NULL, NULL, NULL, NULL);
		// msg 81 error accessing blob field %s -- continuing 
		BURP_print_status(status_vector);
		return;
	}

	if (isc_blob_info(status_vector, &blob, sizeof(blob_items),
					  blob_items, sizeof(blob_info),
					  (char*) blob_info))
	{
		BURP_error_redirect(status_vector, 20, NULL, NULL);
		// msg 20 isc_blob_info failed 
	}

	put(tdgbl, (UCHAR) (rec_blob));
	put_numeric(att_blob_field_number, field->fld_number);

	ULONG segments = 0;
	USHORT max_segment = 0;
	UCHAR *p = blob_info;

	UCHAR item;
	while ((item = *p++) != isc_info_end)
	{
		USHORT l = (USHORT) isc_vax_integer((char*) p, 2);
		p += 2;
		USHORT n = (USHORT) isc_vax_integer((char*) p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			put_numeric(att_blob_max_segment, (int) n);
			max_segment = n;
			break;

		case isc_info_blob_type:
			put_numeric(att_blob_type, (int) n);
			break;

		case isc_info_blob_num_segments:
			put_numeric(att_blob_number_segments, (int) n);
			segments = n;
			break;

		default:
			BURP_error_redirect(NULL, 21, (void*) (ULONG) item, NULL);
			// msg 21 don't understand blob info item %ld 
		}
	}

// Allocate a buffer large enough for the largest segment and start grinding. 

	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc(max_segment);

	put(tdgbl, (UCHAR) (att_blob_data));

	while (segments > 0)
	{
		USHORT segment_length;
		if (isc_get_segment(status_vector, &blob, &segment_length, max_segment,
							(char*) buffer))
		{
			BURP_error_redirect(status_vector, 22, NULL, NULL);
		}
		// msg 22 isc_get_segment failed 

		put(tdgbl, (UCHAR) (segment_length));
		put(tdgbl, (UCHAR) (segment_length >> 8));
		if (segment_length)
		{
			put_block(tdgbl, buffer, segment_length);
		}
		--segments;
	}

	if (isc_close_blob(status_vector, &blob))
		BURP_error_redirect(status_vector, 23, NULL, NULL);
	// msg 23 isc_close_blob failed 

	if (buffer != static_buffer)
		BURP_free(buffer);
}


bool put_blr_blob( SCHAR attribute, ISC_QUAD * blob_id)
{
/**************************************
 *
 *	p u t _ b l r _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Write out a blr blob, if present.  Otherwise do nothing.
 *	Return true is there was the blob was present, false otherwise.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	UCHAR blob_info[32], static_buffer[1024];

	TGBL tdgbl = GET_THREAD_DATA;

// If the blob is null, don't store it.  It will be restored as null. 

	if (!blob_id->gds_quad_high && !blob_id->gds_quad_low)
		return false;

// Open the blob and get it's vital statistics 

	isc_handle blob = NULL;

	if (isc_open_blob(status_vector, &DB, &gds_trans, &blob, blob_id))
	{
		BURP_error_redirect(status_vector, 24, NULL, NULL);
		// msg 24 isc_open_blob failed 
	}

	if (isc_blob_info(status_vector, &blob, sizeof(blr_items),
					  (SCHAR *) blr_items, sizeof(blob_info),
					  (char*) blob_info))
	{
		BURP_error_redirect(status_vector, 20, NULL, NULL);
		// msg 20 isc_blob_info failed 
	}

	ULONG length = 0;
	USHORT max_segment = 0;
	const UCHAR* p = blob_info;
	UCHAR item;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = (USHORT) isc_vax_integer((const char*) p, 2);
		p += 2;
		const USHORT n = (USHORT) isc_vax_integer((const char*) p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		default:
			BURP_print(79, (void *) (ULONG) item, NULL, NULL, NULL, NULL);
			// msg 79 don't understand blob info item %ld  
			return false;
		}
	}

	if (!length)
	{
		if (isc_close_blob(status_vector, &blob))
			BURP_error_redirect(status_vector, 23, NULL, NULL);
		// msg 23 isc_close_blob failed 
		return false;
	}

// Rdb sometimes gets the length messed up 

	if (length < max_segment)
		length = max_segment;

	put_numeric(attribute, (int) length);

// Allocate a buffer large enough for the largest segment and start grinding. 

	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc(max_segment);

	USHORT segment_length;
	while (!isc_get_segment(status_vector, &blob, &segment_length,
							(USHORT) max_segment, (char*) buffer))
	{
		if (segment_length)
		{
			put_block(tdgbl, buffer, segment_length);
		}
	}

	if (isc_close_blob(status_vector, &blob))
	{
		BURP_error_redirect(status_vector, 23, NULL, NULL);
	}
	// msg 23 isc_close_blob failed 

	if (buffer != static_buffer)
		BURP_free(buffer);

	return true;
}


void put_data(BURP_REL relation)
{
/**************************************
 *
 *	p u t _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *
 **************************************/
	BURP_FLD field;
	ISC_STATUS_ARRAY status_vector;

	TGBL tdgbl = GET_THREAD_DATA;

	// CVC: A signed short isn't enough if the engine allows near 32K fields,
	// each being char(1) ASCII in the worst case. Looking at BLR generation
	// below, it's clear an extreme case won't compile => blr_length >= 32K.
	// However, SSHORT is the limit for request_length in isc_compile_request.
	SSHORT field_count = 1;

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (!(field->fld_flags & FLD_computed))
		{
			field_count += 2;
		}
	}

/* Time to generate blr to fetch data.  Make sure we allocate a BLR buffer
   large enough to handle the per field overhead */
	UCHAR* const blr_buffer = BURP_alloc(200 + field_count * 9);
	UCHAR* blr = blr_buffer;
	stuff(&blr, blr_version4);
	stuff(&blr, blr_begin);
	stuff(&blr, blr_message);
	stuff(&blr, 0);						// Message number
	stuff_word(&blr, field_count);		// Number of fields, counting eof

	RCRD_OFFSET offset = 0;
	SSHORT count = 0;   // This is param count.

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		SSHORT alignment = 4;
		FLD_LENGTH length = field->fld_length;
		SSHORT dtype = field->fld_type;
		if (field->fld_flags & FLD_array)
		{
			dtype = blr_blob;
			length = 8;
		}
		switch (dtype)
		{
		case blr_text:
			alignment = type_alignments[dtype_text];
			stuff(&blr, field->fld_type);
			stuff_word(&blr, field->fld_length);
			break;

		case blr_varying:
			alignment = type_alignments[dtype_varying];
			stuff(&blr, field->fld_type);
			stuff_word(&blr, field->fld_length);
			length += sizeof(USHORT);
			break;

		case blr_short:
			alignment = type_alignments[dtype_short];
			stuff(&blr, field->fld_type);
			stuff(&blr, field->fld_scale);
			break;

		case blr_long:
			alignment = type_alignments[dtype_long];
			stuff(&blr, field->fld_type);
			stuff(&blr, field->fld_scale);
			break;

		case blr_quad:
			alignment = type_alignments[dtype_quad];
			stuff(&blr, field->fld_type);
			stuff(&blr, field->fld_scale);
			break;

		case blr_int64:
			alignment = type_alignments[dtype_int64];
			stuff(&blr, field->fld_type);
			stuff(&blr, field->fld_scale);
			break;

		case blr_double:
			alignment = type_alignments[dtype_double];
			stuff(&blr, field->fld_type);
			break;

		case blr_timestamp:
			alignment = type_alignments[dtype_timestamp];
			stuff(&blr, field->fld_type);
			break;

		case blr_sql_time:
			alignment = type_alignments[dtype_sql_time];
			stuff(&blr, field->fld_type);
			break;

		case blr_sql_date:
			alignment = type_alignments[dtype_sql_date];
			stuff(&blr, field->fld_type);
			break;

		case blr_float:
			alignment = type_alignments[dtype_real];
			stuff(&blr, field->fld_type);
			break;

		case blr_blob:
			alignment = type_alignments[dtype_blob];
			stuff(&blr, blr_quad);
			stuff(&blr, 0);
			break;

		default:
			BURP_error_redirect(NULL, 26, (void *) (SLONG) field->fld_type, NULL);
			// msg 26 datatype %ld not understood 
			break;
		}
		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_offset = offset;
		field->fld_parameter = count++;
		offset += length;
	}

// Next, build fields for null flags 

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		stuff(&blr, blr_short);
		stuff(&blr, 0);
		offset = FB_ALIGN(offset, sizeof(SSHORT));
		field->fld_missing_parameter = count++;
		offset += sizeof(SSHORT);
	}

// Finally, make up an EOF field 

	stuff(&blr, blr_short);			// eof field 
	stuff(&blr, 0);					// scale for eof field 
	SSHORT eof_parameter = count++;
	RCRD_OFFSET record_length = offset;
	RCRD_OFFSET eof_offset = FB_ALIGN(offset, sizeof(SSHORT));
	// To be used later for the buffer size to receive data
	const FLD_LENGTH length = (USHORT) (eof_offset + sizeof(SSHORT));

// Build FOR loop, body, and eof handler 

	stuff(&blr, blr_for);
	stuff(&blr, blr_rse);
	stuff(&blr, 1);					// count of relations 
	stuff(&blr, blr_rid);
	stuff_word(&blr, relation->rel_id);
	stuff(&blr, 0);					// context variable 
	stuff(&blr, blr_end);

	stuff(&blr, blr_send);
	stuff(&blr, 0);
	stuff(&blr, blr_begin);
	stuff(&blr, blr_assignment);
	stuff(&blr, blr_literal);
	stuff(&blr, blr_short);
	stuff(&blr, 0);
	stuff_word(&blr, 1);
	stuff(&blr, blr_parameter);
	stuff(&blr, 0);
	stuff_word(&blr, eof_parameter);

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		stuff(&blr, blr_assignment);
		stuff(&blr, blr_fid);
		stuff(&blr, 0);
		stuff_word(&blr, field->fld_id);
		stuff(&blr, blr_parameter2);
		stuff(&blr, 0);
		stuff_word(&blr, field->fld_parameter);
		stuff_word(&blr, field->fld_missing_parameter);
	}

	stuff(&blr, blr_end);

	stuff(&blr, blr_send);
	stuff(&blr, 0);
	stuff(&blr, blr_assignment);
	stuff(&blr, blr_literal);
	stuff(&blr, blr_short);
	stuff(&blr, 0);
	stuff_word(&blr, 0);
	stuff(&blr, blr_parameter);
	stuff(&blr, 0);
	stuff_word(&blr, eof_parameter);

	stuff(&blr, blr_end);
	stuff(&blr, blr_eoc);

#ifdef DEBUG
	if (debug_on)
		isc_print_blr((const char*)blr_buffer, NULL, NULL, 0);
#endif


// Compile request 

	isc_handle request = NULL;
	SSHORT blr_length = blr - blr_buffer;
	if (isc_compile_request(status_vector, &DB, &request,
							blr_length, (const SCHAR*) blr_buffer))
	{
		BURP_error_redirect(status_vector, 27, NULL, NULL);
		// msg 27 isc_compile_request failed 
		isc_print_blr((const char*) blr_buffer, NULL, NULL, 0);
	}

	BURP_free(blr_buffer);
	
	BURP_verbose(142, relation->rel_name, NULL, NULL, NULL, NULL);
	// msg 142  writing data for relation %s 

	if (isc_start_request(status_vector, &request, &gds_trans, 0))
	{
		BURP_error_redirect(status_vector, 28, NULL, NULL);
		// msg 28 isc_start_request failed
	}

/* Here is the crux of the problem -- writing data.  All this work
   for the following small loop. */

	UCHAR* buffer = BURP_alloc(length);
	SSHORT* eof = (SSHORT *) (buffer + eof_offset);

// the XDR representation may be even fluffier
	LSTRING xdr_buffer;
	if (tdgbl->gbl_sw_transportable)
	{
		xdr_buffer.lstr_length = xdr_buffer.lstr_allocated =
			length + count * 3;
		xdr_buffer.lstr_address = BURP_alloc(xdr_buffer.lstr_length);
	}
	else
		xdr_buffer.lstr_address = NULL;

	ULONG records = 0;
	while (true)
	{
		if (isc_receive(status_vector, &request, 0, length, buffer, 0))
		{
			BURP_error_redirect(status_vector, 29, NULL, NULL);
			// msg 29 isc_receive failed 
		}
		if (!*eof)
			break;
		records++;
		// Verbose records 
		if ((records % BACKUP_VERBOSE_INTERVAL) == 0)
			BURP_verbose(108, (void *) (SLONG) records, NULL, NULL, NULL, NULL);

		put(tdgbl, (UCHAR) (rec_data));
		put_numeric(att_data_length, record_length);
		const UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			record_length =
				CAN_encode_decode(relation, &xdr_buffer, buffer, TRUE);
			put_numeric(att_xdr_length, record_length);
			p = xdr_buffer.lstr_address;
		}
		else
			p = buffer;
		put(tdgbl, (UCHAR) (att_data_data));
		if (tdgbl->gbl_sw_compress)
			compress(p, record_length);
		else if (record_length)
			put_block(tdgbl, p, record_length);

		// Look for any blobs to write 

		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_type == blr_blob &&
				!(field->fld_flags & FLD_computed) &&
				!(field->fld_flags & FLD_array))
			{
				put_blob(field,
						 (ISC_QUAD*) (buffer + field-> fld_offset),
						 records);
			}
		}

		// Look for any array to write 
		// we got back the blob_id for the array from isc_receive in the second param. 
		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_array)
			{
				put_array(field, relation,
						  (ISC_QUAD *) (buffer + field->fld_offset));
			}
		}
	}

	BURP_free(buffer);

	if (xdr_buffer.lstr_address)
		BURP_free(xdr_buffer.lstr_address);

	BURP_verbose(108, (void *) (SLONG) records, NULL, NULL, NULL, NULL);
// msg 108 %ld records written 

	if (isc_release_request(status_vector, &request))
		BURP_error_redirect(status_vector, 30, NULL, NULL);
	// msg 30 isc_release_request failed 
}


void put_index( BURP_REL relation)
{
/**************************************
 *
 *	p u t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Write information about an index.  First
 *	check that all the segments of the
 *	index exist.
 *
 **************************************/
	ULONG count;
	TEXT temp[GDS_NAME_LEN];

	TGBL tdgbl = GET_THREAD_DATA;

/* if we have all capabilities, use the first request to get the 
   most performance out of the latest engine; if we don't 
   have one of the capabilities we must use the second set of 
   requests--this requires more code but it is well worth it 
   for the performance benefits, especially remotely--deej */

	if ((tdgbl->BCK_capabilities & BCK_idx_inactive) &&
		(tdgbl->BCK_capabilities & BCK_attributes_v3) &&
		(tdgbl->BCK_capabilities & BCK_ods8))
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle1)
			X IN RDB$INDICES WITH 
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_put_index_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle1, (short) sizeof (isc_478), (char *) isc_478);
		isc_vtov ((char*)relation->rel_name, (char*)isc_479.isc_480, 32);
		if (tdgbl->handles_put_index_req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_479, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle1, (short) 1, (short) 104, &isc_481, (short) 0);
		   if (!isc_481.isc_487 || isc_status [1]) break;
#line 1908 "backup.epp"
	
			count = 0;
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle2)
				I_S IN RDB$INDEX_SEGMENTS CROSS 
				RFR IN RDB$RELATION_FIELDS WITH 
				I_S.RDB$FIELD_NAME = RFR.RDB$FIELD_NAME AND 
				I_S.RDB$INDEX_NAME = X.RDB$INDEX_NAME AND 
				RFR.RDB$RELATION_NAME = relation->rel_name*/
			{
                        if (!tdgbl->handles_put_index_req_handle2)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle2, (short) sizeof (isc_472), (char *) isc_472);
			isc_vtov ((char*)relation->rel_name, (char*)isc_473.isc_474, 32);
			isc_vtov ((char*)isc_481.isc_486, (char*)isc_473.isc_475, 32);
			if (tdgbl->handles_put_index_req_handle2)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_473, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle2, (short) 1, (short) 2, &isc_476, (short) 0);
			   if (!isc_476.isc_477 || isc_status [1]) break; 
#line 1916 "backup.epp"
	
				count++;
	
			/*END_FOR;*/
			   }
			   };
#line 1920 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 1921 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 1923 "backup.epp"
	
			if (count != (ULONG) /*X.RDB$SEGMENT_COUNT*/
					     isc_481.isc_494) 
#line 1925 "backup.epp"
			{
				BURP_print(180, /*X.RDB$INDEX_NAME*/
						isc_481.isc_486, (void*) count,
#line 1927 "backup.epp"
							(void*)(ULONG) /*X.RDB$SEGMENT_COUNT*/
								       isc_481.isc_494, NULL, NULL);
#line 1928 "backup.epp"
				continue;
			}
	
			put(tdgbl, rec_index);
			const ULONG l = PUT_TEXT (att_index_name, /*X.RDB$INDEX_NAME*/
								  isc_481.isc_486);
#line 1933 "backup.epp"
			MISC_terminate (/*X.RDB$INDEX_NAME*/
					isc_481.isc_486, temp, l, sizeof(temp));
#line 1934 "backup.epp"
			BURP_verbose (151, temp, NULL, NULL, NULL, NULL);
			// msg 151 writing index %s 
			put_numeric (att_segment_count, /*X.RDB$SEGMENT_COUNT*/
							isc_481.isc_494);
#line 1937 "backup.epp"
			put_numeric (att_index_inactive, /*X.RDB$INDEX_INACTIVE*/
							 isc_481.isc_493);
#line 1938 "backup.epp"
			put_numeric (att_index_unique_flag, /*X.RDB$UNIQUE_FLAG*/
							    isc_481.isc_492);
#line 1939 "backup.epp"
	
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle5)
				Y IN RDB$INDEX_SEGMENTS WITH 
				Y.RDB$INDEX_NAME EQ X.RDB$INDEX_NAME
				SORTED BY Y.RDB$FIELD_POSITION*/
			{
                        if (!tdgbl->handles_put_index_req_handle5)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle5, (short) sizeof (isc_466), (char *) isc_466);
			isc_vtov ((char*)isc_481.isc_486, (char*)isc_467.isc_468, 32);
			if (tdgbl->handles_put_index_req_handle5)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle5, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_467, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle5, (short) 1, (short) 34, &isc_469, (short) 0);
			   if (!isc_469.isc_471 || isc_status [1]) break;
#line 1944 "backup.epp"
	
				PUT_TEXT (att_index_field_name, /*Y.RDB$FIELD_NAME*/
								isc_469.isc_470);
#line 1946 "backup.epp"
	
			/*END_FOR;*/
			   }
			   };
#line 1948 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 1949 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 1951 "backup.epp"
	
			put_source_blob (att_index_description2, att_index_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												     isc_481.isc_485);
#line 1953 "backup.epp"
			put_numeric (att_index_type, /*X.RDB$INDEX_TYPE*/
						     isc_481.isc_491);
#line 1954 "backup.epp"
	
			if (!/*X.RDB$EXPRESSION_SOURCE.NULL*/
			     isc_481.isc_490)
#line 1956 "backup.epp"
				put_source_blob (att_index_expression_source,
								 att_index_expression_source,
								 (ISC_QUAD *)&/*X.RDB$EXPRESSION_SOURCE*/
									      isc_481.isc_484);
#line 1959 "backup.epp"
			if (!/*X.RDB$EXPRESSION_BLR.NULL*/
			     isc_481.isc_489)
#line 1960 "backup.epp"
				put_blr_blob (att_index_expression_blr,
							  (ISC_QUAD *)&/*X.RDB$EXPRESSION_BLR*/
								       isc_481.isc_483);
#line 1962 "backup.epp"
			if (!/*X.RDB$FOREIGN_KEY.NULL*/
			     isc_481.isc_488)
#line 1963 "backup.epp"
				PUT_TEXT (att_index_foreign_key, /*X.RDB$FOREIGN_KEY*/
								 isc_481.isc_482);
#line 1964 "backup.epp"
			put(tdgbl, att_end);
	
		/*END_FOR;*/
		   }
		   };
#line 1967 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 1968 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 1970 "backup.epp"
	}
	else
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle1)
			X IN RDB$INDICES WITH 
			X.RDB$RELATION_NAME EQ relation->rel_name*/
		{
                if (!tdgbl->handles_put_index_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle1, (short) sizeof (isc_457), (char *) isc_457);
		isc_vtov ((char*)relation->rel_name, (char*)isc_458.isc_459, 32);
		if (tdgbl->handles_put_index_req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_458, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle1, (short) 1, (short) 46, &isc_460, (short) 0);
		   if (!isc_460.isc_463 || isc_status [1]) break;
#line 1976 "backup.epp"
	
			count = 0;
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle2)
				I_S IN RDB$INDEX_SEGMENTS WITH 
				I_S.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
			{
                        if (!tdgbl->handles_put_index_req_handle2)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle2, (short) sizeof (isc_451), (char *) isc_451);
			isc_vtov ((char*)isc_460.isc_462, (char*)isc_452.isc_453, 32);
			if (tdgbl->handles_put_index_req_handle2)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_452, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle2, (short) 1, (short) 34, &isc_454, (short) 0);
			   if (!isc_454.isc_456 || isc_status [1]) break;
#line 1981 "backup.epp"
				bool match = false;
	
				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle3)
					RFR IN RDB$RELATION_FIELDS WITH 
					I_S.RDB$FIELD_NAME = RFR.RDB$FIELD_NAME AND
					RFR.RDB$RELATION_NAME = relation->rel_name*/
				{
                                if (!tdgbl->handles_put_index_req_handle3)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle3, (short) sizeof (isc_445), (char *) isc_445);
				isc_vtov ((char*)relation->rel_name, (char*)isc_446.isc_447, 32);
				isc_vtov ((char*)isc_454.isc_455, (char*)isc_446.isc_448, 32);
				if (tdgbl->handles_put_index_req_handle3)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle3, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_446, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle3, (short) 1, (short) 2, &isc_449, (short) 0);
				   if (!isc_449.isc_450 || isc_status [1]) break; 
#line 1987 "backup.epp"
					match = true;
				/*END_FOR;*/
				   }
				   };
#line 1989 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 1990 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 1992 "backup.epp"
				if (!match)
					BURP_print (179, /*I_S.RDB$FIELD_NAME*/
							 isc_454.isc_455, /*X.RDB$INDEX_NAME*/
  isc_460.isc_462, NULL, NULL, NULL); 
#line 1994 "backup.epp"
				else
					count++;
			/*END_FOR;*/
			   }
			   };
#line 1997 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 1998 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 2000 "backup.epp"
	
			if (count != (ULONG) /*X.RDB$SEGMENT_COUNT*/
					     isc_460.isc_465) 
#line 2002 "backup.epp"
			{
				BURP_print(180, /*X.RDB$INDEX_NAME*/
						isc_460.isc_462, (void*) count,
#line 2004 "backup.epp"
						   (void*)(ULONG) /*X.RDB$SEGMENT_COUNT*/
								  isc_460.isc_465, NULL, NULL);
#line 2005 "backup.epp"
				continue; 
			}
	
			put(tdgbl, rec_index);
			const ULONG l = PUT_TEXT (att_index_name, /*X.RDB$INDEX_NAME*/
								  isc_460.isc_462);
#line 2010 "backup.epp"
			MISC_terminate (/*X.RDB$INDEX_NAME*/
					isc_460.isc_462, temp, l, sizeof(temp));
#line 2011 "backup.epp"
			BURP_verbose (151, temp, NULL, NULL, NULL, NULL);
			// msg 151 writing index %s 
			put_numeric (att_segment_count, /*X.RDB$SEGMENT_COUNT*/
							isc_460.isc_465);
#line 2014 "backup.epp"
			if (tdgbl->BCK_capabilities & BCK_idx_inactive)
				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle4)
					I IN RDB$INDICES WITH I.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
				{
                                if (!tdgbl->handles_put_index_req_handle4)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle4, (short) sizeof (isc_439), (char *) isc_439);
				isc_vtov ((char*)isc_460.isc_462, (char*)isc_440.isc_441, 32);
				if (tdgbl->handles_put_index_req_handle4)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle4, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_440, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle4, (short) 1, (short) 4, &isc_442, (short) 0);
				   if (!isc_442.isc_443 || isc_status [1]) break;
#line 2017 "backup.epp"
					put_numeric (att_index_inactive, /*I.RDB$INDEX_INACTIVE*/
									 isc_442.isc_444); 
#line 2018 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 2019 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 2020 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 2022 "backup.epp"
			put_numeric (att_index_unique_flag, /*X.RDB$UNIQUE_FLAG*/
							    isc_460.isc_464);
#line 2023 "backup.epp"
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle5)
				Y IN RDB$INDEX_SEGMENTS WITH Y.RDB$INDEX_NAME EQ X.RDB$INDEX_NAME
				SORTED BY Y.RDB$FIELD_POSITION*/
			{
                        if (!tdgbl->handles_put_index_req_handle5)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle5, (short) sizeof (isc_433), (char *) isc_433);
			isc_vtov ((char*)isc_460.isc_462, (char*)isc_434.isc_435, 32);
			if (tdgbl->handles_put_index_req_handle5)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle5, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_434, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle5, (short) 1, (short) 34, &isc_436, (short) 0);
			   if (!isc_436.isc_438 || isc_status [1]) break;
#line 2026 "backup.epp"
				PUT_TEXT (att_index_field_name, /*Y.RDB$FIELD_NAME*/
								isc_436.isc_437);
#line 2027 "backup.epp"
			/*END_FOR;*/
			   }
			   };
#line 2028 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 2029 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 2031 "backup.epp"
			put_source_blob (att_index_description2, att_index_description,
							 (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
								      isc_460.isc_461);
#line 2033 "backup.epp"
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle6)
					I IN RDB$INDICES WITH I.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
				{
                                if (!tdgbl->handles_put_index_req_handle6)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle6, (short) sizeof (isc_427), (char *) isc_427);
				isc_vtov ((char*)isc_460.isc_462, (char*)isc_428.isc_429, 32);
				if (tdgbl->handles_put_index_req_handle6)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle6, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_428, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle6, (short) 1, (short) 4, &isc_430, (short) 0);
				   if (!isc_430.isc_431 || isc_status [1]) break;
#line 2036 "backup.epp"
					put_numeric (att_index_type, /*I.RDB$INDEX_TYPE*/
								     isc_430.isc_432);
#line 2037 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 2038 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 2039 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 2041 "backup.epp"
			if (tdgbl->BCK_capabilities & BCK_ods8)
				/*FOR (REQUEST_HANDLE tdgbl->handles_put_index_req_handle7)
					I IN RDB$INDICES WITH I.RDB$INDEX_NAME = X.RDB$INDEX_NAME*/
				{
                                if (!tdgbl->handles_put_index_req_handle7)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_index_req_handle7, (short) sizeof (isc_416), (char *) isc_416);
				isc_vtov ((char*)isc_460.isc_462, (char*)isc_417.isc_418, 32);
				if (tdgbl->handles_put_index_req_handle7)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle7, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_417, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_index_req_handle7, (short) 1, (short) 56, &isc_419, (short) 0);
				   if (!isc_419.isc_423 || isc_status [1]) break;
#line 2044 "backup.epp"
					if (!/*I.RDB$EXPRESSION_SOURCE.NULL*/
					     isc_419.isc_426)
#line 2045 "backup.epp"
						put_source_blob (att_index_expression_source,
										 att_index_expression_source,
										 (ISC_QUAD *)&/*I.RDB$EXPRESSION_SOURCE*/
											      isc_419.isc_422);
#line 2048 "backup.epp"
					if (!/*I.RDB$EXPRESSION_BLR.NULL*/
					     isc_419.isc_425)
#line 2049 "backup.epp"
						put_blr_blob (att_index_expression_blr,
									  (ISC_QUAD *)&/*I.RDB$EXPRESSION_BLR*/
										       isc_419.isc_421);
#line 2051 "backup.epp"
					if (!/*I.RDB$FOREIGN_KEY.NULL*/
					     isc_419.isc_424)
#line 2052 "backup.epp"
						PUT_TEXT (att_index_foreign_key, /*I.RDB$FOREIGN_KEY*/
										 isc_419.isc_420);
#line 2053 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 2054 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 2055 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 2057 "backup.epp"
			put(tdgbl, att_end);
	
		/*END_FOR;*/
		   }
		   };
#line 2060 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 2061 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 2063 "backup.epp"
	}
}


int put_message( SCHAR attribute, const TEXT* text, ULONG length)
{
/**************************************
 *
 *	p u t _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Write a variable length text string, with embedded
 *      blanks.  Same as put_text but handles embedded blanks.
 * CVC: As v6 time, put_text handles embedded blanks, too!
 * The only difference is that put_text's length is SSHORT, so
 * in theory put_message can handle much longer input and it's
 * used for exception & trigger's messages (plus update/delete
 * rules for FKs and constraint types, where it's irrelevant
 * which function of the two you use).
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	ULONG l = 0;
	for (const TEXT* p = text; *p && l < length; p++)
		l++;

	l = length = MIN(l, length);
	put(tdgbl, (UCHAR) (attribute));
	put(tdgbl, (UCHAR) (l));
	if (l)
		put_block(tdgbl, reinterpret_cast<const UCHAR*>(text), l);

	return length;
}


void put_numeric( SCHAR attribute, SLONG value)
{
/**************************************
 *
 *	p u t _ n u m e r i c
 *
 **************************************
 *
 * Functional description
 *	Write a numeric value as an attribute.  The number is represented
 *	low byte first, high byte last, as in VAX.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	const SLONG vax_value = (SLONG) isc_vax_integer((const char*) &value, sizeof(value));

	put(tdgbl, (UCHAR) (attribute));
	put(tdgbl, (UCHAR) sizeof(value));
	put_block(tdgbl, (const UCHAR*) &vax_value, sizeof(vax_value));
}


void put_int64( SCHAR attribute, SINT64 value)
{
/**************************************
 *
 *	p u t _ i n t 6 4
 *
 **************************************
 *
 * Functional description
 *	Write a 64-bit numeric value as an attribute.
 *      The number is represented low byte first, high byte last, as in VAX.
 *      This function is just like put_numeric, except that it handles an
 *      INT64 value, while put_numeric handles a 32-bit value.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	const UINT64 le_value =
		(UINT64) isc_portable_integer((const UCHAR*) &value, sizeof(value));

	put(tdgbl, (UCHAR) (attribute));
	put(tdgbl, (UCHAR) (sizeof(value)));
	put_block(tdgbl, (const UCHAR*) &le_value, sizeof(le_value));
}


void put_relation( BURP_REL relation)
{
/**************************************
 *
 * 	p u t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];

	TGBL tdgbl = GET_THREAD_DATA;

/* Write local field information.  This is made slightly more complicated
   by the requirement that computational fields be aligned. */

	BURP_FLD field, aligned, unaligned, aligned4, aligned8;
	aligned = unaligned = aligned4 = aligned8 = NULL;

	BURP_FLD fields = get_fields(relation);

// sort the list of fields into three lists, depending on alignment

	for (field = fields; field = fields;)
	{
		fields = field->fld_next;
		USHORT l = field->fld_length;
		if (field->fld_type == blr_varying)
			l += sizeof(USHORT);
		if (!(l & 7))
		{
			field->fld_next = aligned8;
			aligned8 = field;
		}
		else if (!(l & 3))
		{
			field->fld_next = aligned4;
			aligned4 = field;
		}
		else if (l & 1)
		{
			field->fld_next = unaligned;
			unaligned = field;
		}
		else
		{
			field->fld_next = aligned;
			aligned = field;
		}
	}

/* Next, merge the aligned and unaligned sub-lists.  In the process,
   re-create (approximately) the original order of the fields.  This is
   not strictly required, but it certainly is polite. */

	while (field = unaligned)
	{
		unaligned = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

	while (field = aligned)
	{
		aligned = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

	while (field = aligned4)
	{
		aligned4 = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

	while (field = aligned8)
	{
		aligned8 = field->fld_next;
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
	}

// Now write the fields in what will become physical backup order 

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		put(tdgbl, (UCHAR) (rec_field));
		const USHORT l = PUT_TEXT(att_field_name, field->fld_name);
		MISC_terminate(field->fld_name, temp, l, sizeof(temp));
		BURP_verbose(144, temp, NULL, NULL, NULL, NULL);
		// msg 144  writing field %s 
		PUT_TEXT(att_field_source, field->fld_source);
		if (field->fld_query_name[0])
			PUT_TEXT(att_field_query_name, field->fld_query_name);
		if (field->fld_complex_name[0])
			PUT_TEXT(att_field_complex_name, field->fld_complex_name);
		if (field->fld_edit_string[0])
			PUT_TEXT(att_field_edit_string, field->fld_edit_string);
		put_source_blob(att_field_description2, att_field_description,
						(ISC_QUAD *) & field->fld_description);
		put_source_blob(att_field_query_header, att_field_query_header,
						(ISC_QUAD *) & field->fld_query_header);
		if (field->fld_security_class[0])
			PUT_TEXT(att_field_security_class, field->fld_security_class);
		if (!(field->fld_flags & FLD_position_missing))
			put_numeric(att_field_position, field->fld_position);
		put_numeric(att_field_type, field->fld_type);
		put_numeric(att_field_length, field->fld_length);
		put_numeric(att_field_sub_type, field->fld_sub_type);
		put_numeric(att_field_scale, field->fld_scale);
		put_numeric(att_field_number, field->fld_number);
		put_numeric(att_field_system_flag, field->fld_system_flag);
		if (!(field->fld_flags & FLD_update_missing))
			put_numeric(att_field_update_flag, field->fld_update_flag);
		if (field->fld_flags & FLD_null_flag)
			put_numeric(att_field_null_flag, field->fld_null_flag);
		if (field->fld_flags & FLD_charset_flag)
			put_numeric(att_field_character_set, field->fld_character_set_id);
		if (field->fld_flags & FLD_collate_flag)
			put_numeric(att_field_collation_id, field->fld_collation_id);
		put_blr_blob(att_field_default_value,
					 (ISC_QUAD *) & field->fld_default_value);
		put_source_blob(att_field_default_source, att_field_default_source,
						(ISC_QUAD *) & field->fld_default_source);
		if (relation->rel_flags & REL_view)
		{
			put_numeric(att_view_context, field->fld_view_context);
			PUT_TEXT(att_base_field, field->fld_base);
		}
		if (field->fld_flags & FLD_computed)
			put_numeric(att_field_computed_flag, TRUE);
		if (field->fld_flags & FLD_array)
		{
			put_numeric(att_field_dimensions, field->fld_dimensions);
			const SLONG* rp = field->fld_ranges;
			for (USHORT n = field->fld_dimensions; n; rp += 2, n--)
			{
				put_numeric(att_field_range_low, *rp);
				put_numeric(att_field_range_high, *(rp + 1));
			}
		}
		put(tdgbl, (UCHAR) (att_end));
	}

/* Write out view relations (if a view, of course) */

	if (relation->rel_flags & REL_view)
	{
		if (tdgbl->BCK_capabilities & BCK_context_name)
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_relation_req_handle1)
				X IN RDB$VIEW_RELATIONS WITH X.RDB$VIEW_NAME EQ relation->rel_name*/
			{
                        if (!tdgbl->handles_put_relation_req_handle1)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_relation_req_handle1, (short) sizeof (isc_408), (char *) isc_408);
			isc_vtov ((char*)relation->rel_name, (char*)isc_409.isc_410, 32);
			if (tdgbl->handles_put_relation_req_handle1)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_relation_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_409, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_relation_req_handle1, (short) 1, (short) 68, &isc_411, (short) 0);
			   if (!isc_411.isc_414 || isc_status [1]) break;
#line 2307 "backup.epp"
				put(tdgbl, rec_view);
				PUT_TEXT (att_view_relation_name, /*X.RDB$RELATION_NAME*/
								  isc_411.isc_413);
#line 2309 "backup.epp"
				put_numeric (att_view_context_id, /*X.RDB$VIEW_CONTEXT*/
								  isc_411.isc_415);
#line 2310 "backup.epp"
				PUT_TEXT (att_view_context_name, /*X.RDB$CONTEXT_NAME*/
								 isc_411.isc_412);
#line 2311 "backup.epp"
				put(tdgbl, att_end);
			/*END_FOR*/
			   }
			   };
#line 2313 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 2314 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 2316 "backup.epp"
		}
		else
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_put_relation_req_handle2)
				X IN RDB$VIEW_RELATIONS WITH X.RDB$VIEW_NAME EQ relation->rel_name*/
			{
                        if (!tdgbl->handles_put_relation_req_handle2)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_put_relation_req_handle2, (short) sizeof (isc_401), (char *) isc_401);
			isc_vtov ((char*)relation->rel_name, (char*)isc_402.isc_403, 32);
			if (tdgbl->handles_put_relation_req_handle2)
                           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_put_relation_req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_402, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_put_relation_req_handle2, (short) 1, (short) 36, &isc_404, (short) 0);
			   if (!isc_404.isc_406 || isc_status [1]) break;
#line 2321 "backup.epp"
				put(tdgbl, rec_view);
				PUT_TEXT (att_view_relation_name, /*X.RDB$RELATION_NAME*/
								  isc_404.isc_405);
#line 2323 "backup.epp"
				put_numeric (att_view_context_id, /*X.RDB$VIEW_CONTEXT*/
								  isc_404.isc_407);
#line 2324 "backup.epp"
				put(tdgbl, att_end);
			/*END_FOR;*/
			   }
			   };
#line 2326 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 2327 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 2329 "backup.epp"
		}
	}
	put(tdgbl, (UCHAR) (rec_relation_end));
}


bool put_source_blob(SCHAR		attribute,
						   SCHAR		old_attribute,
						   ISC_QUAD*	blob_id)
{
/**************************************
 *
 *	p u t _ s o u r c e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Write out a source blob or query header if present.
 *	Return true is there was the blob was present, false otherwise.
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	UCHAR blob_info[48], static_buffer[1024];

	TGBL tdgbl = GET_THREAD_DATA;

// If the blob is null, don't store it.  It will be restored as null.

	if (!blob_id->gds_quad_high && !blob_id->gds_quad_low)
		return false;

	if (tdgbl->gbl_sw_old_descriptions && attribute != att_field_query_header)
		return put_blr_blob(old_attribute, (ISC_QUAD *) blob_id);

// Open the blob and get it's vital statistics

	isc_handle blob = NULL;

	if (isc_open_blob(status_vector, &DB, &gds_trans, &blob, blob_id))
	{
		BURP_error_redirect(status_vector, 24, NULL, NULL);
		// msg 24 isc_open_blob failed 
	}

	if (isc_blob_info(status_vector, &blob, sizeof(source_items),
					  (SCHAR *) source_items, sizeof(blob_info),
					  (SCHAR*) blob_info))
	{
		BURP_error_redirect(status_vector, 20, NULL, NULL);
		// msg 20 isc_blob_info failed 
	}

	SLONG length = 0;
	USHORT max_segment = 0, num_seg = 0;
	const UCHAR* p = blob_info;
	UCHAR item;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT l = (USHORT) isc_vax_integer((const SCHAR*) p, 2);
		p += 2;
		const USHORT n = (USHORT) isc_vax_integer((const SCHAR*) p, l);
		p += l;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		case isc_info_blob_num_segments:
			num_seg = n;
			break;

		default:
			BURP_print(79, (void *) (ULONG) item, NULL, NULL, NULL, NULL);
			// msg 79 don't understand blob info item %ld  
			return false;
		}
	}

	if (!length)
	{
		if (isc_close_blob(status_vector, &blob))
		{
			BURP_error_redirect(status_vector, 23, NULL, NULL);
			// msg 23 isc_close_blob failed 
		}
		return false;
	}

// Rdb sometimes gets the length messed up 

	if (length < max_segment)
		length = max_segment;

	put_numeric(attribute, length + num_seg);

// Allocate a buffer large enough for the largest segment and start grinding. 

	UCHAR* buffer;
	if (!max_segment || max_segment <= sizeof(static_buffer))
		buffer = static_buffer;
	else
		buffer = BURP_alloc(max_segment);

	USHORT segment_length;
	while (!isc_get_segment(status_vector, &blob, &segment_length,
							max_segment, (SCHAR*) buffer))
	{
		if (segment_length)
		{
			put_block(tdgbl, buffer, segment_length);
		}
		put(tdgbl, (UCHAR) (NULL));
	}

	if (isc_close_blob(status_vector, &blob))
		BURP_error_redirect(status_vector, 23, NULL, NULL);
	// msg 23 isc_close_blob failed 

	if (buffer != static_buffer)
		BURP_free(buffer);

	return true;
}


int put_text( SCHAR attribute, const TEXT* text, SSHORT size_len)
{
/**************************************
 *
 *	p u t _ t e x t
 *
 **************************************
 *
 * Functional description
 * Write a variable length text string, with embedded spaces.
 * Truncate trailing spaces.
 * Now this routine does not truncate trailing spaces, 3-2002 MOD
 * transfering changes from fb1, I believe this is to do with problems
 * with quoted names and embedded spaces.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	const SSHORT l = (SSHORT) symbol_length (text, (ULONG) size_len);
 
	put(tdgbl, (UCHAR) (attribute));
	put(tdgbl, (UCHAR) (l));
	if (l)
		put_block(tdgbl, (const UCHAR*) text, l);

	return l;
}


void set_capabilities(void)
{
/**************************************
 *
 *	s e t _ c a p a b i l i t i e s
 *
 **************************************
 *
 * Functional description
 *	
 *	set the capabilities bits for the
 *	database being extracted to avoid
 *	unpleasantness later.
 *
 **************************************/
	TGBL tdgbl = GET_THREAD_DATA;

	isc_handle req = NULL;

// Look for desireable fields in system relations

	for (const rfr_tab_t* rel_field_table = rfr_table; rel_field_table->relation;
		 rel_field_table++)
	{
		const TEXT* field = rel_field_table->field;
		const TEXT* relation = rel_field_table->relation;
		/*FOR (REQUEST_HANDLE req) x IN RDB$RELATION_FIELDS
			WITH x.RDB$RELATION_NAME = relation
			AND x.RDB$FIELD_NAME = field*/
		{
                if (!req)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req, (short) sizeof (isc_395), (char *) isc_395);
		isc_vtov ((char*)field, (char*)isc_396.isc_397, 32);
		isc_vtov ((char*)relation, (char*)isc_396.isc_398, 32);
		if (req)
                   isc_start_and_send (isc_status, (isc_handle*) &req, (isc_handle*) &gds_trans, (short) 0, (short) 64, &isc_396, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req, (short) 1, (short) 2, &isc_399, (short) 0);
		   if (!isc_399.isc_400 || isc_status [1]) break;
#line 2518 "backup.epp"
			tdgbl->BCK_capabilities |= rel_field_table->bit_mask;
		/*END_FOR;*/
		   }
		   };
#line 2520 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 2521 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 2523 "backup.epp"
	}

	isc_release_request(isc_status, &req);
}


int symbol_length( const TEXT * symbol, ULONG size_len)
{
/**************************************
 *
 *	s y m b o l _ l e n g t h
 *
 **************************************
 *
 * Functional description
 * Compute length of null terminated symbol.
 *      CVC: This function should acknowledge embedded blanks.  
 *
 **************************************/
	if (size_len < 2) {
		return 0;
	}

	--size_len;

	const TEXT* p = symbol;
	const TEXT* const q = p + size_len;

	while (*p && p < q) {  // find end of string (null or end).
		p++;
	}

	--p;

	while (p >= symbol && *p == ' ') {  // skip trailing blanks
		--p;
	}

	return p + 1 - symbol;

}


void write_character_sets(void)
{
/**************************************
 *
 *	w r i t e _ c h a r a c t e r _ s e t s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each user defined character set.
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$CHARACTER_SETS WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_379), (char *) isc_379);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 156, &isc_380, (short) 0);
	   if (!isc_380.isc_387 || isc_status [1]) break;
#line 2585 "backup.epp"
		put(tdgbl, rec_charset);
		PUT_TEXT (att_charset_name, /*X.RDB$CHARACTER_SET_NAME*/
					    isc_380.isc_385);
#line 2587 "backup.epp"
		if (!/*X.RDB$FORM_OF_USE.NULL*/
		     isc_380.isc_394)
#line 2588 "backup.epp"
			PUT_TEXT (att_charset_form, /*X.RDB$FORM_OF_USE*/
						    isc_380.isc_384);
#line 2589 "backup.epp"
		if (!/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
		     isc_380.isc_393)
#line 2590 "backup.epp"
			put_numeric (att_charset_numchar, /*X.RDB$NUMBER_OF_CHARACTERS*/
							  isc_380.isc_386);
#line 2591 "backup.epp"
		PUT_TEXT (att_charset_coll, /*X.RDB$DEFAULT_COLLATE_NAME*/
					    isc_380.isc_383);
#line 2592 "backup.epp"
		put_numeric (att_charset_id, /*X.RDB$CHARACTER_SET_ID*/
					     isc_380.isc_392);
#line 2593 "backup.epp"
		if (/*X.RDB$SYSTEM_FLAG*/
		    isc_380.isc_391)
#line 2594 "backup.epp"
			put_numeric (att_charset_sysflag, /*X.RDB$SYSTEM_FLAG*/
							  isc_380.isc_391);
#line 2595 "backup.epp"
		if (!/*X.RDB$DESCRIPTION.NULL*/
		     isc_380.isc_390)
#line 2596 "backup.epp"
			put_source_blob (att_charset_description, att_charset_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
													isc_380.isc_382);
#line 2597 "backup.epp"
		if (!/*X.RDB$FUNCTION_NAME.NULL*/
		     isc_380.isc_389)
#line 2598 "backup.epp"
			PUT_TEXT (att_charset_funct, /*X.RDB$FUNCTION_NAME*/
						     isc_380.isc_381);
#line 2599 "backup.epp"
		put_numeric (att_charset_bytes_char, /*X.RDB$BYTES_PER_CHARACTER*/
						     isc_380.isc_388);
#line 2600 "backup.epp"
	
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 2603 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2604 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 2606 "backup.epp"

	MISC_release_request_silent(req_handle1);
}


void write_check_constraints(void)
{
/**************************************
 *
 *	w r i t e _ c h e c k _ c o n s t r a i n t s 
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each check constraint. 
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$CHECK_CONSTRAINTS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_373), (char *) isc_373);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 68, &isc_374, (short) 0);
	   if (!isc_374.isc_377 || isc_status [1]) break;
#line 2630 "backup.epp"
		put(tdgbl, rec_chk_constraint);
	
		PUT_TEXT (att_chk_constraint_name, /*X.RDB$CONSTRAINT_NAME*/
						   isc_374.isc_376);
#line 2633 "backup.epp"
		if (!(/*X.RDB$TRIGGER_NAME.NULL*/
		      isc_374.isc_378))
#line 2634 "backup.epp"
			PUT_TEXT (att_chk_trigger_name, /*X.RDB$TRIGGER_NAME*/
							isc_374.isc_375);
#line 2635 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 2637 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2638 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 2640 "backup.epp"
	
	MISC_release_request_silent(req_handle1);
}


void write_collations(void)
{
/**************************************
 *
 *	w r i t e _ c o l l a t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each user defined collation
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$COLLATIONS WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_361), (char *) isc_361);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 86, &isc_362, (short) 0);
	   if (!isc_362.isc_366 || isc_status [1]) break;
#line 2664 "backup.epp"
		put(tdgbl, rec_collation);
		PUT_TEXT (att_coll_name, /*X.RDB$COLLATION_NAME*/
					 isc_362.isc_365);
#line 2666 "backup.epp"
		put_numeric (att_coll_id, /*X.RDB$COLLATION_ID*/
					  isc_362.isc_372);
#line 2667 "backup.epp"
		put_numeric (att_coll_cs_id, /*X.RDB$CHARACTER_SET_ID*/
					     isc_362.isc_371);
#line 2668 "backup.epp"
		put_numeric (att_coll_attr, /*X.RDB$COLLATION_ATTRIBUTES*/
					    isc_362.isc_370);
#line 2669 "backup.epp"
		if (/*X.RDB$SYSTEM_FLAG*/
		    isc_362.isc_369)
#line 2670 "backup.epp"
			put_numeric (att_coll_sysflag, /*X.RDB$SYSTEM_FLAG*/
						       isc_362.isc_369);
#line 2671 "backup.epp"
		if (!/*X.RDB$DESCRIPTION.NULL*/
		     isc_362.isc_368)
#line 2672 "backup.epp"
			put_source_blob (att_coll_description, att_coll_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												  isc_362.isc_364);
#line 2673 "backup.epp"
		if (!/*X.RDB$FUNCTION_NAME.NULL*/
		     isc_362.isc_367)
#line 2674 "backup.epp"
			PUT_TEXT (att_coll_funct, /*X.RDB$FUNCTION_NAME*/
						  isc_362.isc_363);
#line 2675 "backup.epp"
	
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 2678 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2679 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 2681 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_database( const TEXT* dbb_file)
{
/**************************************
 *
 *	w r i t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 * 	write a physical database record and a
 *	logical database record in the burp file for
 *	the database itself.  
 *
 **************************************/
	ISC_STATUS_ARRAY status_vector;
	SCHAR buffer[256];
	isc_req_handle req_handle1 = NULL, req_handle2 = NULL, req_handle3 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	put(tdgbl, (UCHAR) (rec_physical_db));

	if (isc_database_info(status_vector, &DB, sizeof(db_info_items),
						  db_info_items, sizeof(buffer), buffer))
	{
		BURP_error_redirect(status_vector, 31, NULL, NULL);
		// msg 31 isc_database_info failed 
	}

	USHORT page_size = 0, forced_writes, no_reserve,
		SQL_dialect, db_read_only;
 	ULONG sweep_interval, page_buffers;
 	USHORT length = 0;
	for (const SCHAR* d = buffer; *d != isc_info_end; d += length)
	{
		const SCHAR item = *d++;
		length = (USHORT) isc_vax_integer(d, 2);
		d += 2;
		switch (item)
		{
		case isc_info_end:
			break;

		case isc_info_page_size:
			page_size = (USHORT) isc_vax_integer(d, length);
			put_numeric(att_page_size, page_size);
			break;

		case isc_info_sweep_interval:
			sweep_interval = isc_vax_integer(d, length);
			put_numeric(att_sweep_interval, sweep_interval);
			break;

		case isc_info_forced_writes:
			forced_writes = (USHORT) isc_vax_integer(d, length);
			put_numeric(att_forced_writes, forced_writes);
			break;

		case isc_info_no_reserve:
			if (no_reserve = (USHORT) isc_vax_integer(d, length))
				put_numeric(att_no_reserve, no_reserve);
			break;

		case isc_info_set_page_buffers:
			if (page_buffers = isc_vax_integer(d, length))
				put_numeric(att_page_buffers, page_buffers);
			break;

		case isc_info_error:	// old server does not understand new isc_info 
			break;				// parameter and returns isc_info_error. skip it 

		case isc_info_db_sql_dialect:
			SQL_dialect = (USHORT) isc_vax_integer(d, length);
			put_numeric(att_SQL_dialect, SQL_dialect);
			break;

		case isc_info_db_read_only:
			if (db_read_only = (USHORT) isc_vax_integer(d, length))
				put_numeric(att_db_read_only, db_read_only);
			break;

		default:
			BURP_error_redirect(status_vector, 31, NULL, NULL);
			// msg 31 isc_database_info failed 
			break;
		}
	}

	put_asciz(att_file_name, dbb_file);

	BURP_verbose(77, dbb_file, (void *) (ULONG) page_size, NULL, NULL, NULL);
// msg 77 database %s has a page size of %ld bytes. 

	put(tdgbl, (UCHAR) (att_end));

	put(tdgbl, (UCHAR) (rec_database));

/* if we have all capabilities, use the first request to get the 
   most performance out of the latest engine; if we don't 
   have one of the capabilities we must use the second set of 
   requests--this requires more code but it is well worth it 
   for the performance benefits, especially remotely--deej */

	if ((tdgbl->BCK_capabilities & BCK_security) &&
		(tdgbl->BCK_capabilities & BCK_db_description) &&
		(tdgbl->BCK_capabilities & BCK_ods8))
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			D IN RDB$DATABASE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_353), (char *) isc_353);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 78, &isc_354, (short) 0);
		   if (!isc_354.isc_358 || isc_status [1]) break;
#line 2794 "backup.epp"

			if (!/*D.RDB$SECURITY_CLASS.NULL*/
			     isc_354.isc_360)
#line 2796 "backup.epp"
				PUT_TEXT (att_database_security_class, /*D.RDB$SECURITY_CLASS*/
								       isc_354.isc_357);
#line 2797 "backup.epp"
			put_source_blob (att_database_description2, att_database_description, (ISC_QUAD *)&/*D.RDB$DESCRIPTION*/
													   isc_354.isc_356);
#line 2798 "backup.epp"
			if (!/*D.RDB$CHARACTER_SET_NAME.NULL*/
			     isc_354.isc_359)
#line 2799 "backup.epp"
				PUT_TEXT (att_database_dfl_charset, /*D.RDB$CHARACTER_SET_NAME*/
								    isc_354.isc_355);
#line 2800 "backup.epp"
		/*END_FOR;*/
		   }
		   };
#line 2801 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 2802 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 2804 "backup.epp"
	}
	else
	{
		if (tdgbl->BCK_capabilities & BCK_security)
		{
			/*FOR (REQUEST_HANDLE req_handle1)
				D IN RDB$DATABASE*/
			{
                        if (!req_handle1)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_348), (char *) isc_348);
			if (req_handle1)
                           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 36, &isc_349, (short) 0);
			   if (!isc_349.isc_351 || isc_status [1]) break;
#line 2811 "backup.epp"
				if (!/*D.RDB$SECURITY_CLASS.NULL*/
				     isc_349.isc_352)
#line 2812 "backup.epp"
					PUT_TEXT (att_database_security_class, /*D.RDB$SECURITY_CLASS*/
									       isc_349.isc_350);
#line 2813 "backup.epp"
			/*END_FOR;*/
			   }
			   };
#line 2814 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 2815 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 2817 "backup.epp"
		}

		if (tdgbl->BCK_capabilities & BCK_db_description)
		{
			/*FOR (REQUEST_HANDLE req_handle2)
				D IN RDB$DATABASE*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_344), (char *) isc_344);
			if (req_handle2)
                           isc_start_request (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 0, (short) 10, &isc_345, (short) 0);
			   if (!isc_345.isc_347 || isc_status [1]) break;
#line 2823 "backup.epp"
				put_source_blob (att_database_description2, att_database_description,
					(ISC_QUAD *)&/*D.RDB$DESCRIPTION*/
						     isc_345.isc_346);
#line 2825 "backup.epp"
			/*END_FOR;*/
			   }
			   };
#line 2826 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 2827 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 2829 "backup.epp"
		}

		if (tdgbl->BCK_capabilities & BCK_ods8)
		{
			/*FOR (REQUEST_HANDLE req_handle3)
				D IN RDB$DATABASE*/
			{
                        if (!req_handle3)
                           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle3, (short) sizeof (isc_339), (char *) isc_339);
			if (req_handle3)
                           isc_start_request (isc_status, (isc_handle*) &req_handle3, (isc_handle*) &gds_trans, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (isc_handle*) &req_handle3, (short) 0, (short) 36, &isc_340, (short) 0);
			   if (!isc_340.isc_342 || isc_status [1]) break;
#line 2835 "backup.epp"
				if (!/*D.RDB$CHARACTER_SET_NAME.NULL*/
				     isc_340.isc_343)
#line 2836 "backup.epp"
					PUT_TEXT (att_database_dfl_charset, /*D.RDB$CHARACTER_SET_NAME*/
									    isc_340.isc_341);
#line 2837 "backup.epp"
			/*END_FOR;*/
			   }
			   };
#line 2838 "backup.epp"
			/*ON_ERROR*/
			if (isc_status [1])
			   {
#line 2839 "backup.epp"
				general_on_error();
			/*END_ERROR;*/
			   }
			}
#line 2841 "backup.epp"
		}
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);

	put(tdgbl, (UCHAR) (att_end));
}


void write_exceptions(void)
{
/**************************************
 *
 *	w r i t e _ e x c e p t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each exception.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$EXCEPTIONS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_333), (char *) isc_333);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 121, &isc_334, (short) 0);
	   if (!isc_334.isc_337 || isc_status [1]) break;
#line 2872 "backup.epp"
		put(tdgbl, rec_exception);
		const SSHORT l = PUT_TEXT (att_exception_name, /*X.RDB$EXCEPTION_NAME*/
							       isc_334.isc_336);
#line 2874 "backup.epp"
		MISC_terminate (/*X.RDB$EXCEPTION_NAME*/
				isc_334.isc_336, temp, l, sizeof(temp));
#line 2875 "backup.epp"
		BURP_verbose (198, temp, NULL, NULL, NULL, NULL);
		// msg 198 writing exception %s
		PUT_MESSAGE(att_exception_msg, /*X.RDB$MESSAGE*/
					       isc_334.isc_338);
#line 2878 "backup.epp"
		put_source_blob (att_exception_description2, att_procedure_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												     isc_334.isc_335);
#line 2879 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 2881 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2882 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 2884 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_field_dimensions(void)
{
/**************************************
 *
 *	w r i t e _ f i e l d _ d i m e n s i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each array field dimension.
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FIELD_DIMENSIONS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_326), (char *) isc_326);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 44, &isc_327, (short) 0);
	   if (!isc_327.isc_331 || isc_status [1]) break;
#line 2907 "backup.epp"
		put(tdgbl, rec_field_dimensions);
		PUT_TEXT (att_field_name, /*X.RDB$FIELD_NAME*/
					  isc_327.isc_328);
#line 2909 "backup.epp"
		put_numeric (att_field_dimensions, /*X.RDB$DIMENSION*/
						   isc_327.isc_332);
#line 2910 "backup.epp"
		put_numeric (att_field_range_low, /*X.RDB$LOWER_BOUND*/
						  isc_327.isc_330);
#line 2911 "backup.epp"
		put_numeric (att_field_range_high, /*X.RDB$UPPER_BOUND*/
						   isc_327.isc_329);
#line 2912 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 2914 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2915 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 2917 "backup.epp"

	MISC_release_request_silent(req_handle1);
} 


void write_filters(void)
{
/**************************************
 *
 *	w r i t e _ f i l t e r s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each filter.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FILTERS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_317), (char *) isc_317);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 332, &isc_318, (short) 0);
	   if (!isc_318.isc_322 || isc_status [1]) break;
#line 2942 "backup.epp"
		put(tdgbl, rec_filter);
		const SSHORT l = PUT_TEXT (att_filter_name, /*X.RDB$FUNCTION_NAME*/
							    isc_318.isc_321);
#line 2944 "backup.epp"
		MISC_terminate (/*X.RDB$FUNCTION_NAME*/
				isc_318.isc_321, temp, l, sizeof(temp));
#line 2945 "backup.epp"
		BURP_verbose (145, temp, NULL, NULL, NULL, NULL);
		// msg 145 writing filter %s
		put_source_blob (att_filter_description2, att_filter_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
											       isc_318.isc_320);
#line 2948 "backup.epp"
		PUT_TEXT (att_filter_module_name, /*X.RDB$MODULE_NAME*/
						  isc_318.isc_325);
#line 2949 "backup.epp"
		PUT_TEXT (att_filter_entrypoint, /*X.RDB$ENTRYPOINT*/
						 isc_318.isc_319);
#line 2950 "backup.epp"
		put_numeric (att_filter_input_sub_type, /*X.RDB$INPUT_SUB_TYPE*/
							isc_318.isc_324);
#line 2951 "backup.epp"
		put_numeric (att_filter_output_sub_type, /*X.RDB$OUTPUT_SUB_TYPE*/
							 isc_318.isc_323);
#line 2952 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 2954 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2955 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 2957 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_functions(void)
{
/**************************************
 *                                                                   
 *	w r i t e _ f u n c t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each function.
 *
 **************************************/
	GDS_NAME func;
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FUNCTIONS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_307), (char *) isc_307);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 364, &isc_308, (short) 0);
	   if (!isc_308.isc_313 || isc_status [1]) break;
#line 2982 "backup.epp"
		put(tdgbl, rec_function);
		const SSHORT l = PUT_TEXT (att_function_name, /*X.RDB$FUNCTION_NAME*/
							      isc_308.isc_312);
#line 2984 "backup.epp"
		MISC_terminate (/*X.RDB$FUNCTION_NAME*/
				isc_308.isc_312, temp, l, sizeof(temp));
#line 2985 "backup.epp"
		BURP_verbose (147, temp, NULL, NULL, NULL, NULL);
		/* msg 147 writing function %.*s */
		put_source_blob (att_function_description2, att_function_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												   isc_308.isc_311);
#line 2988 "backup.epp"
		PUT_TEXT (att_function_module_name, /*X.RDB$MODULE_NAME*/
						    isc_308.isc_316);
#line 2989 "backup.epp"
		PUT_TEXT (att_function_entrypoint, /*X.RDB$ENTRYPOINT*/
						   isc_308.isc_310);
#line 2990 "backup.epp"
		put_numeric (att_function_return_arg, /*X.RDB$RETURN_ARGUMENT*/
						      isc_308.isc_315);
#line 2991 "backup.epp"
		put_numeric (att_function_type, /*X.RDB$FUNCTION_TYPE*/
						isc_308.isc_314);
#line 2992 "backup.epp"
		PUT_TEXT (att_function_query_name, /*X.RDB$QUERY_NAME*/
						   isc_308.isc_309);
#line 2993 "backup.epp"
		put(tdgbl, att_end);
		COPY (/*X.RDB$FUNCTION_NAME*/
		      isc_308.isc_312, func);
#line 2995 "backup.epp"
		write_function_args (func);
		put(tdgbl, rec_function_end);
	/*END_FOR;*/
	   }
	   };
#line 2998 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 2999 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3001 "backup.epp"

	MISC_release_request_silent(req_handle1);
} 

void write_function_args( GDS_NAME funcptr)
{
/**************************************
 *
 *	w r i t e _ f u n c t i o n _ a r g s
 *
 **************************************
 *
 * Functional description
 * 	write all arguments for a function.
 *
 **************************************/ 
	TEXT temp[GDS_NAME_LEN];

	TGBL tdgbl = GET_THREAD_DATA;

	/* if we have all capabilities, use the first request to get the 
	   most performance out of the latest engine; if we don't 
	   have one of the capabilities we must use the second set of 
	   requests--this requires more code but it is well worth it 
	   for the performance benefits, especially remotely--deej */

	if (tdgbl->BCK_capabilities & BCK_ods10)
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_write_function_args_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS WITH 
			X.RDB$FUNCTION_NAME EQ funcptr*/
		{
                if (!tdgbl->handles_write_function_args_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_write_function_args_req_handle1, (short) sizeof (isc_291), (char *) isc_291);
		isc_vtov ((char*)funcptr, (char*)isc_292.isc_293, 32);
		if (tdgbl->handles_write_function_args_req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_write_function_args_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_292, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_write_function_args_req_handle1, (short) 1, (short) 54, &isc_294, (short) 0);
		   if (!isc_294.isc_296 || isc_status [1]) break;
#line 3032 "backup.epp"

			put(tdgbl, rec_function_arg);
			const SSHORT l = PUT_TEXT (att_functionarg_name, /*X.RDB$FUNCTION_NAME*/
									 isc_294.isc_295);
#line 3035 "backup.epp"
			MISC_terminate (/*X.RDB$FUNCTION_NAME*/
					isc_294.isc_295, temp, l, sizeof(temp));
#line 3036 "backup.epp"
			BURP_verbose (141, temp, NULL, NULL, NULL, NULL);
			// msg 141 writing argument for function %s 
			put_numeric (att_functionarg_position, /*X.RDB$ARGUMENT_POSITION*/
							       isc_294.isc_306);
#line 3039 "backup.epp"
			put_numeric (att_functionarg_mechanism, /*X.RDB$MECHANISM*/
								isc_294.isc_305);
#line 3040 "backup.epp"
			put_numeric (att_functionarg_field_type, /*X.RDB$FIELD_TYPE*/
								 isc_294.isc_304);
#line 3041 "backup.epp"
			put_numeric (att_functionarg_field_scale, /*X.RDB$FIELD_SCALE*/
								  isc_294.isc_303);
#line 3042 "backup.epp"
			put_numeric (att_functionarg_field_length, /*X.RDB$FIELD_LENGTH*/
								   isc_294.isc_302);
#line 3043 "backup.epp"
			put_numeric (att_functionarg_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
								     isc_294.isc_301);
#line 3044 "backup.epp"
			if (!(/*X.RDB$CHARACTER_SET_ID.NULL*/
			      isc_294.isc_299))
#line 3045 "backup.epp"
				put_numeric (att_functionarg_character_set, /*X.RDB$CHARACTER_SET_ID*/
									    isc_294.isc_300);
#line 3046 "backup.epp"
			
			if (!(/*X.RDB$FIELD_PRECISION.NULL*/
			      isc_294.isc_297))
#line 3048 "backup.epp"
				put_numeric (att_functionarg_field_precision, /*X.RDB$FIELD_PRECISION*/
									      isc_294.isc_298);
#line 3049 "backup.epp"
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
#line 3051 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3052 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3054 "backup.epp"
	}
	else
	{
		/*FOR (REQUEST_HANDLE tdgbl->handles_write_function_args_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS WITH 
			X.RDB$FUNCTION_NAME EQ funcptr*/
		{
                if (!tdgbl->handles_write_function_args_req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_write_function_args_req_handle1, (short) sizeof (isc_279), (char *) isc_279);
		isc_vtov ((char*)funcptr, (char*)isc_280.isc_281, 32);
		if (tdgbl->handles_write_function_args_req_handle1)
                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_write_function_args_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_280, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_write_function_args_req_handle1, (short) 1, (short) 46, &isc_282, (short) 0);
		   if (!isc_282.isc_284 || isc_status [1]) break;
#line 3060 "backup.epp"

			put(tdgbl, rec_function_arg);
			const SSHORT l = PUT_TEXT (att_functionarg_name, /*X.RDB$FUNCTION_NAME*/
									 isc_282.isc_283);
#line 3063 "backup.epp"
			MISC_terminate (/*X.RDB$FUNCTION_NAME*/
					isc_282.isc_283, temp, l, sizeof(temp));
#line 3064 "backup.epp"
			BURP_verbose (141, temp, NULL, NULL, NULL, NULL);
			// msg 141 writing argument for function %s 
			put_numeric (att_functionarg_position, /*X.RDB$ARGUMENT_POSITION*/
							       isc_282.isc_290);
#line 3067 "backup.epp"
			put_numeric (att_functionarg_mechanism, /*X.RDB$MECHANISM*/
								isc_282.isc_289);
#line 3068 "backup.epp"
			put_numeric (att_functionarg_field_type, /*X.RDB$FIELD_TYPE*/
								 isc_282.isc_288);
#line 3069 "backup.epp"
			put_numeric (att_functionarg_field_scale, /*X.RDB$FIELD_SCALE*/
								  isc_282.isc_287);
#line 3070 "backup.epp"
			put_numeric (att_functionarg_field_length, /*X.RDB$FIELD_LENGTH*/
								   isc_282.isc_286);
#line 3071 "backup.epp"
			put_numeric (att_functionarg_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
								     isc_282.isc_285);
#line 3072 "backup.epp"
		
			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE tdgbl->handles_write_function_args_req_handle2)
					X2 IN RDB$FUNCTION_ARGUMENTS WITH 
					X2.RDB$FUNCTION_NAME EQ funcptr AND 
					X2.RDB$ARGUMENT_POSITION = X.RDB$ARGUMENT_POSITION*/
				{
                                if (!tdgbl->handles_write_function_args_req_handle2)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_write_function_args_req_handle2, (short) sizeof (isc_271), (char *) isc_271);
				isc_vtov ((char*)funcptr, (char*)isc_272.isc_273, 32);
				isc_272.isc_274 = isc_282.isc_290;
				if (tdgbl->handles_write_function_args_req_handle2)
                                   isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_write_function_args_req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 34, &isc_272, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &tdgbl->handles_write_function_args_req_handle2, (short) 1, (short) 6, &isc_275, (short) 0);
				   if (!isc_275.isc_276 || isc_status [1]) break;;
#line 3079 "backup.epp"

					if (!(/*X2.RDB$CHARACTER_SET_ID.NULL*/
					      isc_275.isc_277))
#line 3081 "backup.epp"
						put_numeric (att_functionarg_character_set, /*X2.RDB$CHARACTER_SET_ID*/
											    isc_275.isc_278);
#line 3082 "backup.epp"
				/* Note that BCK_ods10 canNOT be set if we're in this
				   "else" branch.  Hence there is no need to test that
				   bit and store the RDB$FIELD_PRECISION. */

				/*END_FOR;*/
				   }
				   };
#line 3087 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 3088 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 3090 "backup.epp"
			}
			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
#line 3094 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3095 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3097 "backup.epp"
	}
}


void write_generators(void)
{
/**************************************
 *
 *	w r i t e _ g e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Write any defined generators.
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;
	TEXT temp[GDS_NAME_LEN];

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$GENERATORS WITH X.RDB$SYSTEM_FLAG MISSING OR X.RDB$SYSTEM_FLAG NE 1*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_267), (char *) isc_267);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 34, &isc_268, (short) 0);
	   if (!isc_268.isc_270 || isc_status [1]) break;
#line 3120 "backup.epp"
		put(tdgbl, rec_generator);
		const SSHORT l = PUT_TEXT (att_gen_generator, /*X.RDB$GENERATOR_NAME*/
							      isc_268.isc_269);
#line 3122 "backup.epp"
		SINT64 value = 0;
		if (!tdgbl->gbl_sw_meta) {
			value = get_gen_id (/*X.RDB$GENERATOR_NAME*/
					    isc_268.isc_269, l);
#line 3125 "backup.epp"
			put_int64 (att_gen_value_int64, value);
		}
		put(tdgbl, att_end);
		MISC_terminate (/*X.RDB$GENERATOR_NAME*/
				isc_268.isc_269, temp, l, sizeof(temp));
#line 3129 "backup.epp"
#pragma FB_COMPILER_MESSAGE("BRS: casting SINT64 to SLONG")
		BURP_verbose (165, temp, (void*) (SLONG) value, NULL, NULL, NULL);
		// msg 165 writing generator %s value %ld
	/*END_FOR;*/
	   }
	   };
#line 3133 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3134 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3136 "backup.epp"

	MISC_release_request_silent(req_handle1);
} 


void write_global_fields(void)
{
/**************************************
 *
 *	w r i t e _ g l o b a l _ f i e l d s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each global field. 
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL, req_handle2 = NULL,
		req_handle3 = NULL, req_handle4 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/* if we have all capabilities, use the first request to get the 
	   most performance out of the latest engine; if we don't 
	   have one of the capabilities we must use the second set of 
	   requests--this requires more code but it is well worth it 
	   for the performance benefits, especially remotely--deej */

	if ((tdgbl->BCK_capabilities & BCK_attributes_v3) &&
		(tdgbl->BCK_capabilities & BCK_ods8) &&
		(tdgbl->BCK_capabilities & BCK_ods10))
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH 
			X.RDB$SYSTEM_FLAG NE 1 OR 
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_229), (char *) isc_229);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 316, &isc_230, (short) 0);
		   if (!isc_230.isc_243 || isc_status [1]) break;
#line 3174 "backup.epp"

			put(tdgbl, rec_global_field);
			const SSHORT l = PUT_TEXT (att_field_name, /*X.RDB$FIELD_NAME*/
								   isc_230.isc_242);
#line 3177 "backup.epp"
			MISC_terminate (/*X.RDB$FIELD_NAME*/
					isc_230.isc_242, temp, l, sizeof(temp));
#line 3178 "backup.epp"
			BURP_verbose (149, temp, NULL, NULL, NULL, NULL);
			/* msg 149  writing global field %.*s */
			if (/*X.RDB$QUERY_NAME*/
			    isc_230.isc_241 [0] != ' ')
#line 3181 "backup.epp"
				PUT_TEXT (att_field_query_name, /*X.RDB$QUERY_NAME*/
								isc_230.isc_241);
#line 3182 "backup.epp"
			if (/*X.RDB$EDIT_STRING*/
			    isc_230.isc_266 [0] != ' ')
#line 3183 "backup.epp"
				PUT_TEXT (att_field_edit_string, /*X.RDB$EDIT_STRING*/
								 isc_230.isc_266);
#line 3184 "backup.epp"
			put_source_blob (att_field_query_header, att_field_query_header, (ISC_QUAD *)&/*X.RDB$QUERY_HEADER*/
												      isc_230.isc_240);
#line 3185 "backup.epp"
			put_numeric (att_field_type, /*X.RDB$FIELD_TYPE*/
						     isc_230.isc_265);
#line 3186 "backup.epp"
			put_numeric (att_field_length, /*X.RDB$FIELD_LENGTH*/
						       isc_230.isc_264);
#line 3187 "backup.epp"
			put_numeric (att_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
							 isc_230.isc_263);
#line 3188 "backup.epp"
			put_numeric (att_field_scale, /*X.RDB$FIELD_SCALE*/
						      isc_230.isc_262);
#line 3189 "backup.epp"
			put_blr_blob (att_field_missing_value, (ISC_QUAD *)&/*X.RDB$MISSING_VALUE*/
									    isc_230.isc_239);
#line 3190 "backup.epp"
			put_blr_blob (att_field_default_value, (ISC_QUAD *)&/*X.RDB$DEFAULT_VALUE*/
									    isc_230.isc_238);
#line 3191 "backup.epp"
			put_blr_blob (att_field_validation_blr, (ISC_QUAD *)&/*X.RDB$VALIDATION_BLR*/
									     isc_230.isc_237);
#line 3192 "backup.epp"
			put_source_blob (att_field_validation_source2, att_field_validation_source, (ISC_QUAD *)&/*X.RDB$VALIDATION_SOURCE*/
														 isc_230.isc_236);
#line 3193 "backup.epp"
			put_blr_blob (att_field_computed_blr, &/*X.RDB$COMPUTED_BLR*/
							       isc_230.isc_235);
#line 3194 "backup.epp"
			put_source_blob (att_field_computed_source2, att_field_computed_source, (ISC_QUAD *)&/*X.RDB$COMPUTED_SOURCE*/
													     isc_230.isc_234);
#line 3195 "backup.epp"
			if (/*X.RDB$SEGMENT_LENGTH*/
			    isc_230.isc_261)
#line 3196 "backup.epp"
				put_numeric (att_field_segment_length, /*X.RDB$SEGMENT_LENGTH*/
								       isc_230.isc_261);
#line 3197 "backup.epp"
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_230.isc_260)
#line 3198 "backup.epp"
				put_numeric (att_field_system_flag, /*X.RDB$SYSTEM_FLAG*/
								    isc_230.isc_260);
#line 3199 "backup.epp"
			put_source_blob (att_field_description2, att_field_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												     isc_230.isc_233);
#line 3200 "backup.epp"
			
			if (/*X.RDB$EXTERNAL_LENGTH*/
			    isc_230.isc_259)
#line 3202 "backup.epp"
				put_numeric (att_field_external_length, /*X.RDB$EXTERNAL_LENGTH*/
									isc_230.isc_259);
#line 3203 "backup.epp"
			if (/*X.RDB$EXTERNAL_TYPE*/
			    isc_230.isc_258) 
#line 3204 "backup.epp"
				put_numeric (att_field_external_type, /*X.RDB$EXTERNAL_TYPE*/
								      isc_230.isc_258);
#line 3205 "backup.epp"
			if (/*X.RDB$EXTERNAL_SCALE*/
			    isc_230.isc_257)
#line 3206 "backup.epp"
				put_numeric (att_field_external_scale, /*X.RDB$EXTERNAL_SCALE*/
								       isc_230.isc_257);
#line 3207 "backup.epp"
			if (/*X.RDB$DIMENSIONS*/
			    isc_230.isc_256)
#line 3208 "backup.epp"
				put_numeric (att_field_dimensions, /*X.RDB$DIMENSIONS*/
								   isc_230.isc_256);
#line 3209 "backup.epp"
			if (!(/*X.RDB$NULL_FLAG.NULL*/
			      isc_230.isc_254))
#line 3210 "backup.epp"
				put_numeric (att_field_null_flag, /*X.RDB$NULL_FLAG*/
								  isc_230.isc_255);
#line 3211 "backup.epp"
			if (!(/*X.RDB$CHARACTER_LENGTH.NULL*/
			      isc_230.isc_252))
#line 3212 "backup.epp"
				put_numeric (att_field_character_length, /*X.RDB$CHARACTER_LENGTH*/
									 isc_230.isc_253);
#line 3213 "backup.epp"
			if (!(/*X.RDB$DEFAULT_SOURCE.NULL*/
			      isc_230.isc_251))
#line 3214 "backup.epp"
				put_source_blob (att_field_default_source, att_field_default_source, (ISC_QUAD *)&/*X.RDB$DEFAULT_SOURCE*/
														  isc_230.isc_232);
#line 3215 "backup.epp"
			if (!(/*X.RDB$MISSING_SOURCE.NULL*/
			      isc_230.isc_250))
#line 3216 "backup.epp"
				put_source_blob (att_field_missing_source, att_field_missing_source, (ISC_QUAD *)&/*X.RDB$MISSING_SOURCE*/
														  isc_230.isc_231);
#line 3217 "backup.epp"
			if (!(/*X.RDB$CHARACTER_SET_ID.NULL*/
			      isc_230.isc_248))
#line 3218 "backup.epp"
				put_numeric (att_field_character_set, /*X.RDB$CHARACTER_SET_ID*/
								      isc_230.isc_249);
#line 3219 "backup.epp"
			if (!(/*X.RDB$COLLATION_ID.NULL*/
			      isc_230.isc_246))
#line 3220 "backup.epp"
				put_numeric (att_field_collation_id, /*X.RDB$COLLATION_ID*/
								     isc_230.isc_247);
#line 3221 "backup.epp"
			
			if (!(/*X.RDB$FIELD_PRECISION.NULL*/
			      isc_230.isc_244))
#line 3223 "backup.epp"
				put_numeric (att_field_precision, /*X.RDB$FIELD_PRECISION*/
								  isc_230.isc_245);
#line 3224 "backup.epp"
			
			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
#line 3228 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3229 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3231 "backup.epp"
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH 
			X.RDB$SYSTEM_FLAG NE 1 OR 
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_209), (char *) isc_209);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 268, &isc_210, (short) 0);
		   if (!isc_210.isc_221 || isc_status [1]) break;
#line 3238 "backup.epp"

			put(tdgbl, rec_global_field);
			const SSHORT l = PUT_TEXT (att_field_name, /*X.RDB$FIELD_NAME*/
								   isc_210.isc_220);
#line 3241 "backup.epp"
			MISC_terminate (/*X.RDB$FIELD_NAME*/
					isc_210.isc_220, temp, l, sizeof(temp));
#line 3242 "backup.epp"
			BURP_verbose (149, temp, NULL, NULL, NULL, NULL);
			/* msg 149  writing global field %.*s */
			if (/*X.RDB$QUERY_NAME*/
			    isc_210.isc_219 [0] != ' ')
#line 3245 "backup.epp"
				PUT_TEXT (att_field_query_name, /*X.RDB$QUERY_NAME*/
								isc_210.isc_219);
#line 3246 "backup.epp"
			if (/*X.RDB$EDIT_STRING*/
			    isc_210.isc_228 [0] != ' ')
#line 3247 "backup.epp"
				PUT_TEXT (att_field_edit_string, /*X.RDB$EDIT_STRING*/
								 isc_210.isc_228);
#line 3248 "backup.epp"
			put_source_blob (att_field_query_header, att_field_query_header, (ISC_QUAD *)&/*X.RDB$QUERY_HEADER*/
												      isc_210.isc_218);
#line 3249 "backup.epp"
			put_numeric (att_field_type, /*X.RDB$FIELD_TYPE*/
						     isc_210.isc_227);
#line 3250 "backup.epp"
			put_numeric (att_field_length, /*X.RDB$FIELD_LENGTH*/
						       isc_210.isc_226);
#line 3251 "backup.epp"
			put_numeric (att_field_sub_type, /*X.RDB$FIELD_SUB_TYPE*/
							 isc_210.isc_225);
#line 3252 "backup.epp"
			put_numeric (att_field_scale, /*X.RDB$FIELD_SCALE*/
						      isc_210.isc_224);
#line 3253 "backup.epp"
			put_blr_blob (att_field_missing_value, (ISC_QUAD *)&/*X.RDB$MISSING_VALUE*/
									    isc_210.isc_217);
#line 3254 "backup.epp"
			put_blr_blob (att_field_default_value, (ISC_QUAD *)&/*X.RDB$DEFAULT_VALUE*/
									    isc_210.isc_216);
#line 3255 "backup.epp"
			put_blr_blob (att_field_validation_blr, (ISC_QUAD *)&/*X.RDB$VALIDATION_BLR*/
									     isc_210.isc_215);
#line 3256 "backup.epp"
			put_source_blob (att_field_validation_source2, att_field_validation_source, (ISC_QUAD *)&/*X.RDB$VALIDATION_SOURCE*/
														 isc_210.isc_214);
#line 3257 "backup.epp"
			put_blr_blob (att_field_computed_blr, (ISC_QUAD *)&/*X.RDB$COMPUTED_BLR*/
									   isc_210.isc_213);
#line 3258 "backup.epp"
			put_source_blob (att_field_computed_source2, att_field_computed_source, (ISC_QUAD *)&/*X.RDB$COMPUTED_SOURCE*/
													     isc_210.isc_212);
#line 3259 "backup.epp"
			if (/*X.RDB$SEGMENT_LENGTH*/
			    isc_210.isc_223)
#line 3260 "backup.epp"
				put_numeric (att_field_segment_length, /*X.RDB$SEGMENT_LENGTH*/
								       isc_210.isc_223);
#line 3261 "backup.epp"
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_210.isc_222)
#line 3262 "backup.epp"
				put_numeric (att_field_system_flag, /*X.RDB$SYSTEM_FLAG*/
								    isc_210.isc_222);
#line 3263 "backup.epp"
			put_source_blob (att_field_description2, att_field_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												     isc_210.isc_211);
#line 3264 "backup.epp"
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE req_handle2)
					F IN RDB$FIELDS WITH F.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!req_handle2)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_200), (char *) isc_200);
				isc_vtov ((char*)isc_210.isc_220, (char*)isc_201.isc_202, 32);
				if (req_handle2)
                                   isc_start_and_send (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_201, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 1, (short) 10, &isc_203, (short) 0);
				   if (!isc_203.isc_204 || isc_status [1]) break;
#line 3268 "backup.epp"
					
					if (/*F.RDB$EXTERNAL_LENGTH*/
					    isc_203.isc_208)
#line 3270 "backup.epp"
						put_numeric (att_field_external_length, /*F.RDB$EXTERNAL_LENGTH*/
											isc_203.isc_208);
#line 3271 "backup.epp"
					if (/*F.RDB$EXTERNAL_TYPE*/
					    isc_203.isc_207) 
#line 3272 "backup.epp"
						put_numeric (att_field_external_type, /*F.RDB$EXTERNAL_TYPE*/
										      isc_203.isc_207);
#line 3273 "backup.epp"
					if (/*F.RDB$EXTERNAL_SCALE*/
					    isc_203.isc_206)
#line 3274 "backup.epp"
						put_numeric (att_field_external_scale, /*F.RDB$EXTERNAL_SCALE*/
										       isc_203.isc_206);
#line 3275 "backup.epp"
					if (/*F.RDB$DIMENSIONS*/
					    isc_203.isc_205)
#line 3276 "backup.epp"
						put_numeric (att_field_dimensions, /*F.RDB$DIMENSIONS*/
										   isc_203.isc_205);
#line 3277 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 3278 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 3279 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 3281 "backup.epp"
			}
			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE req_handle3)
					F IN RDB$FIELDS WITH F.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
				{
                                if (!req_handle3)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle3, (short) sizeof (isc_183), (char *) isc_183);
				isc_vtov ((char*)isc_210.isc_220, (char*)isc_184.isc_185, 32);
				if (req_handle3)
                                   isc_start_and_send (isc_status, (isc_handle*) &req_handle3, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_184, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &req_handle3, (short) 1, (short) 38, &isc_186, (short) 0);
				   if (!isc_186.isc_189 || isc_status [1]) break;
#line 3286 "backup.epp"
					if (!(/*F.RDB$NULL_FLAG.NULL*/
					      isc_186.isc_198))
#line 3287 "backup.epp"
						put_numeric (att_field_null_flag, /*F.RDB$NULL_FLAG*/
										  isc_186.isc_199);
#line 3288 "backup.epp"
					if (!(/*F.RDB$CHARACTER_LENGTH.NULL*/
					      isc_186.isc_196))
#line 3289 "backup.epp"
						put_numeric (att_field_character_length, /*F.RDB$CHARACTER_LENGTH*/
											 isc_186.isc_197);
#line 3290 "backup.epp"
					if (!(/*F.RDB$DEFAULT_SOURCE.NULL*/
					      isc_186.isc_195))
#line 3291 "backup.epp"
						put_source_blob (att_field_default_source, att_field_default_source, (ISC_QUAD *)&/*F.RDB$DEFAULT_SOURCE*/
																  isc_186.isc_188);
#line 3292 "backup.epp"
					if (!(/*F.RDB$MISSING_SOURCE.NULL*/
					      isc_186.isc_194))
#line 3293 "backup.epp"
						put_source_blob (att_field_missing_source, att_field_missing_source, (ISC_QUAD *)&/*F.RDB$MISSING_SOURCE*/
																  isc_186.isc_187);
#line 3294 "backup.epp"
					if (!(/*F.RDB$CHARACTER_SET_ID.NULL*/
					      isc_186.isc_192))
#line 3295 "backup.epp"
						put_numeric (att_field_character_set, /*F.RDB$CHARACTER_SET_ID*/
										      isc_186.isc_193);
#line 3296 "backup.epp"
					if (!(/*F.RDB$COLLATION_ID.NULL*/
					      isc_186.isc_190))
#line 3297 "backup.epp"
						put_numeric (att_field_collation_id, /*F.RDB$COLLATION_ID*/
										     isc_186.isc_191);
#line 3298 "backup.epp"

					if (tdgbl->BCK_capabilities & BCK_ods10)
					{
						/*FOR (REQUEST_HANDLE req_handle4)
							K IN RDB$FIELDS WITH K.RDB$FIELD_NAME = X.RDB$FIELD_NAME*/
						{
                                                if (!req_handle4)
                                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle4, (short) sizeof (isc_176), (char *) isc_176);
						isc_vtov ((char*)isc_210.isc_220, (char*)isc_177.isc_178, 32);
						if (req_handle4)
                                                   isc_start_and_send (isc_status, (isc_handle*) &req_handle4, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_177, (short) 0);
						if (!isc_status [1]) {
						while (1)
						   {
                                                   isc_receive (isc_status, (isc_handle*) &req_handle4, (short) 1, (short) 6, &isc_179, (short) 0);
						   if (!isc_179.isc_180 || isc_status [1]) break;
#line 3303 "backup.epp"
							if (!(/*K.RDB$FIELD_PRECISION.NULL*/
							      isc_179.isc_181))
#line 3304 "backup.epp"
								put_numeric (att_field_precision, /*K.RDB$FIELD_PRECISION*/
												  isc_179.isc_182);
#line 3305 "backup.epp"
						/*END_FOR;*/
						   }
						   };
#line 3306 "backup.epp"
						/*ON_ERROR*/
						if (isc_status [1])
						   {
#line 3307 "backup.epp"
							general_on_error();
						/*END_ERROR;*/
						   }
						}
#line 3309 "backup.epp"
					}
				/*END_FOR;*/
				   }
				   };
#line 3311 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 3312 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 3314 "backup.epp"
			}
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
#line 3317 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3318 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3320 "backup.epp"
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);
	MISC_release_request_silent(req_handle4);
}


void write_procedures(void)
{
/**************************************
 *                                                                   
 *	w r i t e _ p r o c e d u r e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each stored procedure.
 *
 **************************************/
	GDS_NAME proc;
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$PROCEDURES*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_164), (char *) isc_164);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 128, &isc_165, (short) 0);
	   if (!isc_165.isc_172 || isc_status [1]) break;
#line 3350 "backup.epp"
		put(tdgbl, rec_procedure);
		const SSHORT l = PUT_TEXT (att_procedure_name, /*X.RDB$PROCEDURE_NAME*/
							       isc_165.isc_171);
#line 3352 "backup.epp"
		MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
				isc_165.isc_171, temp, l, sizeof(temp));
#line 3353 "backup.epp"
		BURP_verbose (193, temp, NULL, NULL, NULL, NULL);
		/* msg 193 writing stored procedure %.*s */
		put_numeric (att_procedure_inputs, /*X.RDB$PROCEDURE_INPUTS*/
						   isc_165.isc_175);
#line 3356 "backup.epp"
		put_numeric (att_procedure_outputs, /*X.RDB$PROCEDURE_OUTPUTS*/
						    isc_165.isc_174);
#line 3357 "backup.epp"
		put_source_blob (att_procedure_description2, att_procedure_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												     isc_165.isc_170);
#line 3358 "backup.epp"
		put_source_blob (att_procedure_source2, att_procedure_source, (ISC_QUAD *)&/*X.RDB$PROCEDURE_SOURCE*/
											   isc_165.isc_169);
#line 3359 "backup.epp"
		put_blr_blob (att_procedure_blr, (ISC_QUAD *)&/*X.RDB$PROCEDURE_BLR*/
							      isc_165.isc_168);
#line 3360 "backup.epp"
		if (!/*X.RDB$SECURITY_CLASS.NULL*/
		     isc_165.isc_173)
#line 3361 "backup.epp"
			PUT_TEXT (att_procedure_security_class, /*X.RDB$SECURITY_CLASS*/
								isc_165.isc_167);
#line 3362 "backup.epp"
		if (!/*X.RDB$SECURITY_CLASS.NULL*/
		     isc_165.isc_173)
#line 3363 "backup.epp"
			PUT_TEXT (att_procedure_owner_name, /*X.RDB$OWNER_NAME*/
							    isc_165.isc_166);
#line 3364 "backup.epp"
		put(tdgbl, att_end);
		COPY(/*X.RDB$PROCEDURE_NAME*/
		     isc_165.isc_171, proc);
#line 3366 "backup.epp"
		write_procedure_prms (proc);
		put(tdgbl, rec_procedure_end);
	/*END_FOR;*/
	   }
	   };
#line 3369 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3370 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3372 "backup.epp"

	MISC_release_request_silent(req_handle1);
} 


void write_procedure_prms( GDS_NAME procptr)
{
/**************************************
 *
 *	w r i t e _ p r o c e d u r e _ p r m s
 *
 **************************************
 *
 * Functional description
 * 	write all parameters of a stored procedure.
 *
 **************************************/ 
	TEXT temp[GDS_NAME_LEN];

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE tdgbl->handles_write_procedure_prms_req_handle1)
		X IN RDB$PROCEDURE_PARAMETERS WITH X.RDB$PROCEDURE_NAME EQ procptr*/
	{
        if (!tdgbl->handles_write_procedure_prms_req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &tdgbl->handles_write_procedure_prms_req_handle1, (short) sizeof (isc_154), (char *) isc_154);
	isc_vtov ((char*)procptr, (char*)isc_155.isc_156, 32);
	if (tdgbl->handles_write_procedure_prms_req_handle1)
           isc_start_and_send (isc_status, (isc_handle*) &tdgbl->handles_write_procedure_prms_req_handle1, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_155, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &tdgbl->handles_write_procedure_prms_req_handle1, (short) 1, (short) 78, &isc_157, (short) 0);
	   if (!isc_157.isc_161 || isc_status [1]) break;
#line 3395 "backup.epp"
		put(tdgbl, rec_procedure_prm);
		const SSHORT l = PUT_TEXT (att_procedureprm_name, /*X.RDB$PARAMETER_NAME*/
								  isc_157.isc_160);
#line 3397 "backup.epp"
		MISC_terminate (/*X.RDB$PARAMETER_NAME*/
				isc_157.isc_160, temp, l, sizeof(temp));
#line 3398 "backup.epp"
		BURP_verbose (194, temp, NULL, NULL, NULL, NULL);
		// msg 194 writing parameter %s for stored procedure 
		put_numeric (att_procedureprm_number, /*X.RDB$PARAMETER_NUMBER*/
						      isc_157.isc_163);
#line 3401 "backup.epp"
		put_numeric (att_procedureprm_type, /*X.RDB$PARAMETER_type*/
						    isc_157.isc_162);
#line 3402 "backup.epp"
		PUT_TEXT (att_procedureprm_field_source, /*X.RDB$FIELD_SOURCE*/
							 isc_157.isc_159);
#line 3403 "backup.epp"
		put_source_blob (att_procedureprm_description2, att_procedureprm_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
													   isc_157.isc_158);
#line 3404 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 3406 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3407 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3409 "backup.epp"
}


void write_ref_constraints(void)
{
/**************************************
 *
 *	w r i t e _ r e f _ c o n s t r a i n t s 
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each referential constraint. 
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$REF_CONSTRAINTS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_146), (char *) isc_146);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 98, &isc_147, (short) 0);
	   if (!isc_147.isc_153 || isc_status [1]) break;
#line 3431 "backup.epp"
		put(tdgbl, rec_ref_constraint);
		PUT_TEXT (att_ref_constraint_name, /*X.RDB$CONSTRAINT_NAME*/
						   isc_147.isc_150);
#line 3433 "backup.epp"
		PUT_TEXT (att_ref_unique_const_name, /*X.RDB$CONST_NAME_UQ*/
						     isc_147.isc_149);
#line 3434 "backup.epp"
		PUT_TEXT (att_ref_match_option, /*X.RDB$MATCH_OPTION*/
						isc_147.isc_148);
#line 3435 "backup.epp"
		PUT_MESSAGE (att_ref_update_rule, /*X.RDB$UPDATE_RULE*/
						  isc_147.isc_152);
#line 3436 "backup.epp"
		PUT_MESSAGE (att_ref_delete_rule, /*X.RDB$DELETE_RULE*/
						  isc_147.isc_151);
#line 3437 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 3439 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3440 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3442 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_rel_constraints(void)
{
/**************************************
 *
 *	w r i t e _ r e l _ c o n s t r a i n t s 
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each relation constraint. 
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$RELATION_CONSTRAINTS*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_136), (char *) isc_136);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 120, &isc_137, (short) 0);
	   if (!isc_137.isc_144 || isc_status [1]) break;
#line 3466 "backup.epp"
		put(tdgbl, rec_rel_constraint);
		const SSHORT l = PUT_TEXT (att_rel_constraint_name, /*X.RDB$CONSTRAINT_NAME*/
								    isc_137.isc_140);
#line 3468 "backup.epp"
		MISC_terminate (/*X.RDB$CONSTRAINT_NAME*/
				isc_137.isc_140, temp, l, sizeof(temp));
#line 3469 "backup.epp"
		BURP_verbose (207, temp, NULL, NULL, NULL, NULL);
		// msg 207 writing constraint %s 
		PUT_MESSAGE (att_rel_constraint_type, /*X.RDB$CONSTRAINT_TYPE*/
						      isc_137.isc_143);
#line 3472 "backup.epp"
		PUT_TEXT (att_rel_constraint_rel_name, /*X.RDB$RELATION_NAME*/
						       isc_137.isc_139);
#line 3473 "backup.epp"
		PUT_TEXT (att_rel_constraint_defer, /*X.RDB$DEFERRABLE*/
						    isc_137.isc_142);
#line 3474 "backup.epp"
		PUT_TEXT (att_rel_constraint_init, /*X.RDB$INITIALLY_DEFERRED*/
						   isc_137.isc_141);
#line 3475 "backup.epp"
		if (!(/*X.RDB$INDEX_NAME.NULL*/
		      isc_137.isc_145))
#line 3476 "backup.epp"
			PUT_TEXT (att_rel_constraint_index, /*X.RDB$INDEX_NAME*/
							    isc_137.isc_138);
#line 3477 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 3479 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3480 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3482 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_relations(void)
{
/**************************************
 *
 *	w r i t e _ r e l a t i o n s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each relation. 
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL, req_handle2 = NULL, req_handle3 =
		NULL, req_handle4 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/* if we have all capabilities, use the first request to get the 
	most performance out of the latest engine; if we don't 
	have one of the capabilities we must use the second set of 
	requests--this requires more code but it is well worth it 
	for the performance benefits, especially remotely--deej */

	if ((tdgbl->BCK_capabilities & BCK_ods8) &&
		(tdgbl->BCK_capabilities & BCK_security) &&
		(tdgbl->BCK_capabilities & BCK_attributes_v3))
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$RELATIONS WITH X.RDB$SYSTEM_FLAG NE 1 OR 
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_119), (char *) isc_119);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 396, &isc_120, (short) 0);
		   if (!isc_120.isc_128 || isc_status [1]) break;
#line 3518 "backup.epp"

			SSHORT flags = 0;
			put(tdgbl, rec_relation);
			const SSHORT l = PUT_TEXT (att_relation_name, /*X.RDB$RELATION_NAME*/
								      isc_120.isc_127);
#line 3522 "backup.epp"
			MISC_terminate (/*X.RDB$RELATION_NAME*/
					isc_120.isc_127, temp, l, sizeof(temp));
#line 3523 "backup.epp"
			BURP_verbose (153, temp, NULL, NULL, NULL, NULL);
		/* msg 153 writing relation %.*s */

		/* RDB$VIEW_BLR must be the first blob field in the backup file.
			 * RESTORE.EPP makes this assumption in get_relation().
			 */

			if (put_blr_blob (att_relation_view_blr, (ISC_QUAD *)&/*X.RDB$VIEW_BLR*/
									      isc_120.isc_126))
#line 3531 "backup.epp"
				flags |= REL_view;
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_120.isc_135)
#line 3533 "backup.epp"
				put_numeric (att_relation_system_flag, /*X.RDB$SYSTEM_FLAG*/
								       isc_120.isc_135);
#line 3534 "backup.epp"
			if (!(/*X.RDB$FLAGS.NULL*/
			      isc_120.isc_133))
#line 3535 "backup.epp"
				put_numeric (att_relation_flags, /*X.RDB$FLAGS*/
								 isc_120.isc_134);
#line 3536 "backup.epp"
			if (!/*X.RDB$SECURITY_CLASS.NULL*/
			     isc_120.isc_132)
#line 3537 "backup.epp"
				PUT_TEXT (att_relation_security_class, /*X.RDB$SECURITY_CLASS*/
								       isc_120.isc_125);
#line 3538 "backup.epp"
			
			put_source_blob (att_relation_description2, att_relation_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
													   isc_120.isc_124);
#line 3540 "backup.epp"
			put_source_blob (att_relation_view_source2, att_relation_view_source, (ISC_QUAD *)&/*X.RDB$VIEW_SOURCE*/
													   isc_120.isc_123);
#line 3541 "backup.epp"
			
			put_source_blob (att_relation_ext_description2, att_relation_ext_description, (ISC_QUAD *)&/*X.RDB$EXTERNAL_DESCRIPTION*/
														   isc_120.isc_122);
#line 3543 "backup.epp"
			PUT_TEXT (att_relation_owner_name, /*X.RDB$OWNER_NAME*/
							   isc_120.isc_121);
#line 3544 "backup.epp"
			if (!/*X.RDB$EXTERNAL_FILE.NULL*/
			     isc_120.isc_130)
#line 3545 "backup.epp"
				if (!tdgbl->gbl_sw_convert_ext_tables)
				{
					PUT_TEXT(att_relation_ext_file_name, /*X.RDB$EXTERNAL_FILE*/
									     isc_120.isc_131); 
#line 3548 "backup.epp"
					flags |= REL_external;
				}

			put(tdgbl, att_end);
			BURP_REL relation = (BURP_REL) BURP_alloc_zero (sizeof(burp_rel));
			relation->rel_next = tdgbl->relations;
			tdgbl->relations = relation;
			relation->rel_id = /*X.RDB$RELATION_ID*/
					   isc_120.isc_129;
#line 3556 "backup.epp"
			relation->rel_name_length = COPY(/*X.RDB$RELATION_NAME*/
							 isc_120.isc_127, relation->rel_name);
#line 3557 "backup.epp"
			relation->rel_flags |= flags;
			put_relation (relation);
		/*END_FOR;*/
		   }
		   };
#line 3560 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3561 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3563 "backup.epp"
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$RELATIONS WITH X.RDB$SYSTEM_FLAG NE 1 OR 
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_110), (char *) isc_110);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 62, &isc_111, (short) 0);
		   if (!isc_111.isc_116 || isc_status [1]) break;
#line 3569 "backup.epp"

			SSHORT flags = 0;
			put(tdgbl, rec_relation);
			const SSHORT l = PUT_TEXT(att_relation_name, /*X.RDB$RELATION_NAME*/
								     isc_111.isc_115);
#line 3573 "backup.epp"
			MISC_terminate (/*X.RDB$RELATION_NAME*/
					isc_111.isc_115, temp, l, sizeof(temp));
#line 3574 "backup.epp"
			BURP_verbose (153, temp, NULL, NULL, NULL, NULL);
			/* msg 153 writing relation %.*s */
			
			/* RDB$VIEW_BLR must be the first blob field in the backup file.
			 * RESTORE.E makes this assumption in get_relation().
			 */

			if (put_blr_blob (att_relation_view_blr, (ISC_QUAD *)&/*X.RDB$VIEW_BLR*/
									      isc_111.isc_114))
#line 3582 "backup.epp"
				flags |= REL_view;
			if (/*X.RDB$SYSTEM_FLAG*/
			    isc_111.isc_118)
#line 3584 "backup.epp"
				put_numeric (att_relation_system_flag, /*X.RDB$SYSTEM_FLAG*/
								       isc_111.isc_118);
#line 3585 "backup.epp"
			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE req_handle2)
					R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!req_handle2)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_103), (char *) isc_103);
				isc_vtov ((char*)isc_111.isc_115, (char*)isc_104.isc_105, 32);
				if (req_handle2)
                                   isc_start_and_send (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_104, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 1, (short) 6, &isc_106, (short) 0);
				   if (!isc_106.isc_107 || isc_status [1]) break;
#line 3589 "backup.epp"
					if (!(/*R.RDB$FLAGS.NULL*/
					      isc_106.isc_108))
#line 3590 "backup.epp"
						put_numeric (att_relation_flags, /*R.RDB$FLAGS*/
										 isc_106.isc_109);
#line 3591 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 3592 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 3593 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 3595 "backup.epp"
			}
			if (tdgbl->BCK_capabilities & BCK_security)
			{
				/*FOR (REQUEST_HANDLE req_handle3)
					R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!req_handle3)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle3, (short) sizeof (isc_96), (char *) isc_96);
				isc_vtov ((char*)isc_111.isc_115, (char*)isc_97.isc_98, 32);
				if (req_handle3)
                                   isc_start_and_send (isc_status, (isc_handle*) &req_handle3, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_97, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &req_handle3, (short) 1, (short) 36, &isc_99, (short) 0);
				   if (!isc_99.isc_101 || isc_status [1]) break;
#line 3600 "backup.epp"
					if (!/*R.RDB$SECURITY_CLASS.NULL*/
					     isc_99.isc_102)
#line 3601 "backup.epp"
						PUT_TEXT(att_relation_security_class, /*R.RDB$SECURITY_CLASS*/
										      isc_99.isc_100);
#line 3602 "backup.epp"
				/*END_FOR;*/
				   }
				   };
#line 3603 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 3604 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 3606 "backup.epp"
			}
			put_source_blob (att_relation_description2, att_relation_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
													   isc_111.isc_113);
#line 3608 "backup.epp"
			put_source_blob (att_relation_view_source2, att_relation_view_source, (ISC_QUAD *)&/*X.RDB$VIEW_SOURCE*/
													   isc_111.isc_112);
#line 3609 "backup.epp"
			if (tdgbl->BCK_capabilities & BCK_attributes_v3)
			{
				/*FOR (REQUEST_HANDLE req_handle4)
					R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME = X.RDB$RELATION_NAME*/
				{
                                if (!req_handle4)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle4, (short) sizeof (isc_87), (char *) isc_87);
				isc_vtov ((char*)isc_111.isc_115, (char*)isc_88.isc_89, 32);
				if (req_handle4)
                                   isc_start_and_send (isc_status, (isc_handle*) &req_handle4, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_88, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &req_handle4, (short) 1, (short) 298, &isc_90, (short) 0);
				   if (!isc_90.isc_93 || isc_status [1]) break;
#line 3613 "backup.epp"
					put_source_blob (att_relation_ext_description2, att_relation_ext_description, (ISC_QUAD *)&/*R.RDB$EXTERNAL_DESCRIPTION*/
																   isc_90.isc_92);
#line 3614 "backup.epp"
					PUT_TEXT(att_relation_owner_name, /*R.RDB$OWNER_NAME*/
									  isc_90.isc_91);
#line 3615 "backup.epp"
					if (!/*R.RDB$EXTERNAL_FILE.NULL*/
					     isc_90.isc_94)
#line 3616 "backup.epp"
					{
						if (!tdgbl->gbl_sw_convert_ext_tables)
						{
							PUT_TEXT(att_relation_ext_file_name, /*R.RDB$EXTERNAL_FILE*/
											     isc_90.isc_95); 
#line 3620 "backup.epp"
							flags |= REL_external;
						}
					}
				/*END_FOR;*/
				   }
				   };
#line 3624 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 3625 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 3627 "backup.epp"
			}
			put(tdgbl, att_end);
			BURP_REL relation = (BURP_REL) BURP_alloc_zero (sizeof(burp_rel));
			relation->rel_next = tdgbl->relations;
			tdgbl->relations = relation;
			relation->rel_id = /*X.RDB$RELATION_ID*/
					   isc_111.isc_117;
#line 3633 "backup.epp"
			relation->rel_name_length = COPY(/*X.RDB$RELATION_NAME*/
							 isc_111.isc_115, relation->rel_name);
#line 3634 "backup.epp"
			relation->rel_flags |= flags;
			put_relation (relation);
		/*END_FOR;*/
		   }
		   };
#line 3637 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3638 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3640 "backup.epp"
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);
	MISC_release_request_silent(req_handle4);
}


void write_shadow_files(void)
{
/**************************************
 *
 *	w r i t e _ s h a d o w _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	Write out files to use as shadows.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$FILES 
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
		AND X.RDB$SHADOW_NUMBER NE 0*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_78), (char *) isc_78);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 270, &isc_79, (short) 0);
	   if (!isc_79.isc_82 || isc_status [1]) break;
#line 3670 "backup.epp"
		put(tdgbl, rec_files);
		const SSHORT l = PUT_TEXT (att_file_filename, /*X.RDB$FILE_NAME*/
							      isc_79.isc_86);
#line 3672 "backup.epp"
		MISC_terminate (/*X.RDB$FILE_NAME*/
				isc_79.isc_86, temp, l, sizeof(temp));
#line 3673 "backup.epp"
		BURP_verbose (163, temp, NULL, NULL, NULL, NULL);
		// msg 163 writing shadow file %s
		put_numeric (att_file_sequence, /*X.RDB$FILE_SEQUENCE*/
						isc_79.isc_85);
#line 3676 "backup.epp"
		put_numeric (att_file_start, /*X.RDB$FILE_START*/
					     isc_79.isc_81);
#line 3677 "backup.epp"
		put_numeric (att_file_length, /*X.RDB$FILE_LENGTH*/
					      isc_79.isc_80);
#line 3678 "backup.epp"
		put_numeric (att_file_flags, /*X.RDB$FILE_FLAGS*/
					     isc_79.isc_84);
#line 3679 "backup.epp"
		put_numeric (att_shadow_number, /*X.RDB$SHADOW_NUMBER*/
						isc_79.isc_83);
#line 3680 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 3682 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3683 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3685 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_sql_roles(void)
{
/**************************************
 *
 *	w r i t e _ s q l _ r o l e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each SQL roles. 
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;
	TEXT temp[GDS_NAME_LEN];

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$ROLES*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_73), (char *) isc_73);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 66, &isc_74, (short) 0);
	   if (!isc_74.isc_77 || isc_status [1]) break;
#line 3709 "backup.epp"

		put(tdgbl, rec_sql_roles);
		const SSHORT l = PUT_TEXT(att_role_name, /*X.RDB$ROLE_NAME*/
							 isc_74.isc_76);
#line 3712 "backup.epp"
		PUT_TEXT (att_role_owner_name, /*X.RDB$OWNER_NAME*/
					       isc_74.isc_75);
#line 3713 "backup.epp"
		put(tdgbl, att_end);
		MISC_terminate (/*X.RDB$ROLE_NAME*/
				isc_74.isc_76, temp, l, sizeof(temp));
#line 3715 "backup.epp"
		BURP_verbose (249, temp, NULL, NULL, NULL, NULL);
	// msg 249 writing SQL role: %s 
		
	/*END_FOR;*/
	   }
	   };
#line 3719 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3720 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3722 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_triggers(void)
{
/**************************************
 *
 *	w r i t e _ t r i g g e r s
 *
 **************************************
 *
 * Functional description
 * 	write the triggers in rdb$triggers
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL, req_handle2 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/* if we have all capabilities, use the first request to get the 
	most performance out of the latest engine; if we don't 
	have one of the capabilities we must use the second set of 
	requests--this requires more code but it is well worth it 
	for the performance benefits, especially remotely--deej */

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$TRIGGERS WITH 
			X.RDB$SYSTEM_FLAG NE 1 OR 
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_59), (char *) isc_59);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 102, &isc_60, (short) 0);
		   if (!isc_60.isc_66 || isc_status [1]) break;
#line 3755 "backup.epp"

			put(tdgbl, rec_trigger);
			const SSHORT l = PUT_TEXT (att_trig_name, /*X.RDB$TRIGGER_NAME*/
								  isc_60.isc_65);
#line 3758 "backup.epp"
			MISC_terminate (/*X.RDB$TRIGGER_NAME*/
					isc_60.isc_65, temp, l, sizeof(temp));
#line 3759 "backup.epp"
			BURP_verbose (156, temp, NULL, NULL, NULL, NULL);
			// msg 156   writing trigger %s 
		
			PUT_TEXT (att_trig_relation_name, /*X.RDB$RELATION_NAME*/
							  isc_60.isc_64);
#line 3763 "backup.epp"
			put_numeric (att_trig_sequence, /*X.RDB$TRIGGER_SEQUENCE*/
							isc_60.isc_72);
#line 3764 "backup.epp"
			put_numeric (att_trig_type, /*X.RDB$TRIGGER_TYPE*/
						    isc_60.isc_71);
#line 3765 "backup.epp"
			put_blr_blob (att_trig_blr, (ISC_QUAD *)&/*X.RDB$TRIGGER_BLR*/
								 isc_60.isc_63);
#line 3766 "backup.epp"
			put_source_blob (att_trig_source2, att_trig_source, (ISC_QUAD *)&/*X.RDB$TRIGGER_SOURCE*/
											 isc_60.isc_62);
#line 3767 "backup.epp"
			put_source_blob (att_trig_description2, att_trig_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												   isc_60.isc_61);
#line 3768 "backup.epp"
			put_numeric (att_trig_system_flag, /*X.RDB$SYSTEM_FLAG*/
							   isc_60.isc_70);
#line 3769 "backup.epp"
			put_numeric (att_trig_inactive, /*X.RDB$TRIGGER_INACTIVE*/
							isc_60.isc_69);
#line 3770 "backup.epp"
			
			if (!(/*X.RDB$FLAGS.NULL*/
			      isc_60.isc_67))
#line 3772 "backup.epp"
				put_numeric (att_trig_flags, /*X.RDB$FLAGS*/
							     isc_60.isc_68);
#line 3773 "backup.epp"
			
			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
#line 3777 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3778 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3780 "backup.epp"
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$TRIGGERS WITH 
			X.RDB$SYSTEM_FLAG NE 1 OR 
			X.RDB$SYSTEM_FLAG MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_47), (char *) isc_47);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 98, &isc_48, (short) 0);
		   if (!isc_48.isc_54 || isc_status [1]) break;
#line 3787 "backup.epp"

			put(tdgbl, rec_trigger);
			const SSHORT l = PUT_TEXT (att_trig_name, /*X.RDB$TRIGGER_NAME*/
								  isc_48.isc_53);
#line 3790 "backup.epp"
			MISC_terminate (/*X.RDB$TRIGGER_NAME*/
					isc_48.isc_53, temp, l, sizeof(temp));
#line 3791 "backup.epp"
			BURP_verbose (156, temp, NULL, NULL, NULL, NULL);
			// msg 156   writing trigger %s 
			
			PUT_TEXT (att_trig_relation_name, /*X.RDB$RELATION_NAME*/
							  isc_48.isc_52);
#line 3795 "backup.epp"
			put_numeric (att_trig_sequence, /*X.RDB$TRIGGER_SEQUENCE*/
							isc_48.isc_58);
#line 3796 "backup.epp"
			put_numeric (att_trig_type, /*X.RDB$TRIGGER_TYPE*/
						    isc_48.isc_57);
#line 3797 "backup.epp"
			put_blr_blob (att_trig_blr, (ISC_QUAD *)&/*X.RDB$TRIGGER_BLR*/
								 isc_48.isc_51);
#line 3798 "backup.epp"
			put_source_blob (att_trig_source2, att_trig_source, (ISC_QUAD *)&/*X.RDB$TRIGGER_SOURCE*/
											 isc_48.isc_50);
#line 3799 "backup.epp"
			put_source_blob (att_trig_description2, att_trig_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
												   isc_48.isc_49);
#line 3800 "backup.epp"
			put_numeric (att_trig_system_flag, /*X.RDB$SYSTEM_FLAG*/
							   isc_48.isc_56);
#line 3801 "backup.epp"
			put_numeric (att_trig_inactive, /*X.RDB$TRIGGER_INACTIVE*/
							isc_48.isc_55);
#line 3802 "backup.epp"

			if (tdgbl->BCK_capabilities & BCK_ods8)
			{
				/*FOR (REQUEST_HANDLE req_handle2)
					Y IN RDB$TRIGGERS WITH 
					X.RDB$TRIGGER_NAME = Y.RDB$TRIGGER_NAME*/
				{
                                if (!req_handle2)
                                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle2, (short) sizeof (isc_40), (char *) isc_40);
				isc_vtov ((char*)isc_48.isc_53, (char*)isc_41.isc_42, 32);
				if (req_handle2)
                                   isc_start_and_send (isc_status, (isc_handle*) &req_handle2, (isc_handle*) &gds_trans, (short) 0, (short) 32, &isc_41, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (isc_handle*) &req_handle2, (short) 1, (short) 6, &isc_43, (short) 0);
				   if (!isc_43.isc_44 || isc_status [1]) break;
#line 3808 "backup.epp"

					if (!(/*Y.RDB$FLAGS.NULL*/
					      isc_43.isc_45))
#line 3810 "backup.epp"
						put_numeric (att_trig_flags, /*Y.RDB$FLAGS*/
									     isc_43.isc_46);
#line 3811 "backup.epp"

				/*END_FOR;*/
				   }
				   };
#line 3813 "backup.epp"
				/*ON_ERROR*/
				if (isc_status [1])
				   {
#line 3814 "backup.epp"
					general_on_error();
				/*END_ERROR;*/
				   }
				}
#line 3816 "backup.epp"
			}

			put(tdgbl, att_end);

		/*END_FOR;*/
		   }
		   };
#line 3821 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3822 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3824 "backup.epp"
	}

	MISC_release_request_silent(req_handle1);
	MISC_release_request_silent(req_handle2);
}


void write_trigger_messages(void)
{
/**************************************
 *
 *	w r i t e _ t r i g g e r _ m e s s a g e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each trigger message.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		T IN RDB$TRIGGERS CROSS X IN RDB$TRIGGER_MESSAGES
		OVER RDB$TRIGGER_NAME
		WITH T.RDB$SYSTEM_FLAG NE 1 OR T.RDB$SYSTEM_FLAG MISSING*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_34), (char *) isc_34);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 115, &isc_35, (short) 0);
	   if (!isc_35.isc_37 || isc_status [1]) break;;
#line 3853 "backup.epp"

		put(tdgbl, rec_trigger_message);
		const SSHORT l = PUT_TEXT (att_trigmsg_name, /*X.RDB$TRIGGER_NAME*/
							     isc_35.isc_36);
#line 3856 "backup.epp"
		MISC_terminate (/*X.RDB$TRIGGER_NAME*/
				isc_35.isc_36, temp, l, sizeof(temp));
#line 3857 "backup.epp"
		BURP_verbose (157, temp, NULL, NULL, NULL, NULL);
		/* msg 157 writing trigger message for *s */
		put_numeric (att_trigmsg_number, /*X.RDB$MESSAGE_NUMBER*/
						 isc_35.isc_38);
#line 3860 "backup.epp"
		PUT_MESSAGE (att_trigmsg_text, /*X.RDB$MESSAGE*/
					       isc_35.isc_39);
#line 3861 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 3863 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3864 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3866 "backup.epp"

	MISC_release_request_silent(req_handle1);
}

void write_types(void)
{
/**************************************
 *
 *	w r i t e _ t y p e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each type.
 *
 **************************************/
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$TYPES WITH X.RDB$SYSTEM_FLAG NE 1 OR 
		X.RDB$SYSTEM_FLAG MISSING*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_26), (char *) isc_26);
	if (req_handle1)
           isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 78, &isc_27, (short) 0);
	   if (!isc_27.isc_31 || isc_status [1]) break;
#line 3890 "backup.epp"
		put(tdgbl, rec_system_type);
		PUT_TEXT (att_type_name, /*X.RDB$TYPE_NAME*/
					 isc_27.isc_30);
#line 3892 "backup.epp"
		PUT_TEXT (att_type_field_name, /*X.RDB$FIELD_NAME*/
					       isc_27.isc_29);
#line 3893 "backup.epp"
		BURP_verbose (160, /*X.RDB$TYPE_NAME*/
				   isc_27.isc_30, /*X.RDB$FIELD_NAME*/
  isc_27.isc_29, NULL, NULL, NULL);
#line 3894 "backup.epp"
		// msg 160 writing type %s for field %s 
		put_numeric (att_type_type, /*X.RDB$TYPE*/
					    isc_27.isc_33);
#line 3896 "backup.epp"
		put_source_blob (att_type_description2, att_type_description, (ISC_QUAD *)&/*X.RDB$DESCRIPTION*/
											   isc_27.isc_28);
#line 3897 "backup.epp"
		if (/*X.RDB$SYSTEM_FLAG*/
		    isc_27.isc_32)
#line 3898 "backup.epp"
			put_numeric (att_type_system_flag, /*X.RDB$SYSTEM_FLAG*/
							   isc_27.isc_32);
#line 3899 "backup.epp"
		put(tdgbl, att_end);
	/*END_FOR;*/
	   }
	   };
#line 3901 "backup.epp"
	/*ON_ERROR*/
	if (isc_status [1])
	   {
#line 3902 "backup.epp"
		general_on_error();
	/*END_ERROR;*/
	   }
	}
#line 3904 "backup.epp"

	MISC_release_request_silent(req_handle1);
}


void write_user_privileges(void)
{
/**************************************
 *
 *	w r i t e _ u s e r _ p r i v i l e g e s
 *
 **************************************
 *
 * Functional description
 * 	write a record in the burp file for
 *	each user privilege.
 *
 **************************************/
	TEXT temp[GDS_NAME_LEN];
	isc_req_handle req_handle1 = NULL;

	TGBL tdgbl = GET_THREAD_DATA;

	if (tdgbl->BCK_capabilities & BCK_ods8)
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$USER_PRIVILEGES*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_14), (char *) isc_14);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 145, &isc_15, (short) 0);
		   if (!isc_15.isc_20 || isc_status [1]) break;
#line 3931 "backup.epp"
			put(tdgbl, rec_user_privilege);
			const SSHORT l = PUT_TEXT (att_priv_user, /*X.RDB$USER*/
								  isc_15.isc_19);
#line 3933 "backup.epp"
			MISC_terminate (/*X.RDB$USER*/
					isc_15.isc_19, temp, l, sizeof(temp));
#line 3934 "backup.epp"
			BURP_verbose (152, temp, NULL, NULL, NULL, NULL);
			// msg 152 writing privilege for user %s
			PUT_TEXT (att_priv_grantor, /*X.RDB$GRANTOR*/
						    isc_15.isc_18);
#line 3937 "backup.epp"
			PUT_TEXT (att_priv_privilege, /*X.RDB$PRIVILEGE*/
						      isc_15.isc_25);
#line 3938 "backup.epp"
			put_numeric (att_priv_grant_option, /*X.RDB$GRANT_OPTION*/
							    isc_15.isc_24);
#line 3939 "backup.epp"
			PUT_TEXT (att_priv_object_name, /*X.RDB$RELATION_NAME*/
							isc_15.isc_17);
#line 3940 "backup.epp"
			if (!/*X.RDB$FIELD_NAME.NULL*/
			     isc_15.isc_23)
#line 3941 "backup.epp"
			   PUT_TEXT (att_priv_field_name, /*X.RDB$FIELD_NAME*/
							  isc_15.isc_16);
#line 3942 "backup.epp"
			put_numeric (att_priv_user_type, /*X.RDB$USER_TYPE*/
							 isc_15.isc_22);
#line 3943 "backup.epp"
			put_numeric (att_priv_obj_type, /*X.RDB$OBJECT_TYPE*/
							isc_15.isc_21);
#line 3944 "backup.epp"
			put(tdgbl, att_end);
		/*END_FOR*/
		   }
		   };
#line 3946 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3947 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3949 "backup.epp"
	}
	else
	{
		/*FOR (REQUEST_HANDLE req_handle1)
			X IN RDB$USER_PRIVILEGES*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (isc_handle*) &DB, (isc_handle*) &req_handle1, (short) sizeof (isc_4), (char *) isc_4);
		if (req_handle1)
                   isc_start_request (isc_status, (isc_handle*) &req_handle1, (isc_handle*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (isc_handle*) &req_handle1, (short) 0, (short) 141, &isc_5, (short) 0);
		   if (!isc_5.isc_10 || isc_status [1]) break;
#line 3954 "backup.epp"
			put(tdgbl, rec_user_privilege);
			const SSHORT l = PUT_TEXT (att_priv_user, /*X.RDB$USER*/
								  isc_5.isc_9);
#line 3956 "backup.epp"
			MISC_terminate (/*X.RDB$USER*/
					isc_5.isc_9, temp, l, sizeof(temp));
#line 3957 "backup.epp"
			BURP_verbose (152, temp, NULL, NULL, NULL, NULL);
			// msg 152 writing privilege for user %s
			PUT_TEXT (att_priv_grantor, /*X.RDB$GRANTOR*/
						    isc_5.isc_8);
#line 3960 "backup.epp"
			PUT_TEXT (att_priv_privilege, /*X.RDB$PRIVILEGE*/
						      isc_5.isc_13);
#line 3961 "backup.epp"
			put_numeric (att_priv_grant_option, /*X.RDB$GRANT_OPTION*/
							    isc_5.isc_12);
#line 3962 "backup.epp"
			PUT_TEXT (att_priv_object_name, /*X.RDB$RELATION_NAME*/
							isc_5.isc_7);
#line 3963 "backup.epp"
			if (!/*X.RDB$FIELD_NAME.NULL*/
			     isc_5.isc_11)
#line 3964 "backup.epp"
				PUT_TEXT (att_priv_field_name, /*X.RDB$FIELD_NAME*/
							       isc_5.isc_6);
#line 3965 "backup.epp"
			put(tdgbl, att_end);
		/*END_FOR;*/
		   }
		   };
#line 3967 "backup.epp"
		/*ON_ERROR*/
		if (isc_status [1])
		   {
#line 3968 "backup.epp"
			general_on_error();
		/*END_ERROR;*/
		   }
		}
#line 3970 "backup.epp"
	}

	MISC_release_request_silent(req_handle1);
}

} // namespace

