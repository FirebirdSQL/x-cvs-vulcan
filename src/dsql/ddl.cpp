/*
 *	PROGRAM:	Dynamic SQL runtime support
 *	MODULE:		ddl.cpp
 *	DESCRIPTION:	Utilities for generating ddl
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * $Id$
 * 2001.5.20 Claudio Valderrama: Stop null pointer that leads to a crash,
 * caused by incomplete yacc syntax that allows ALTER DOMAIN dom SET;
 *
 * 2001.07.06 Sean Leyne - Code Cleanup, removed "#ifdef READONLY_DATABASE"
 *                         conditionals, as the engine now fully supports
 *                         readonly databases.
 * December 2001 Mike Nordell - Attempt to make it C++
 *
 * 2001.5.20 Claudio Valderrama: Stop null pointer that leads to a crash,
 * caused by incomplete yacc syntax that allows ALTER DOMAIN dom SET;
 * 2001.5.29 Claudio Valderrama: Check for view v/s relation in DROP
 * command will stop a user that uses DROP VIEW and drops a table by
 * accident and vice-versa.
 * 2001.5.30 Claudio Valderrama: alter column should use 1..N for the
 * position argument since the call comes from SQL DDL.
 * 2001.6.27 Claudio Valderrama: DDL_resolve_intl_type() was adding 2 to the
 * length of varchars instead of just checking that len+2<=MAX_COLUMN_SIZE.
 * It required a minor change to put_field() where it was decremented, too.
 * 2001.6.27 Claudio Valderrama: Finally stop users from invoking the same option
 * several times when altering a domain. Specially dangerous with text data types.
 * Ex: alter domain d type char(5) type varchar(5) default 'x' default 'y';
 * Bear in mind that if DYN functions are addressed directly, this protection
 * becomes a moot point.
 * 2001.6.30 Claudio Valderrama: revert changes from 2001.6.26 because the code
 * is called from several places and there are more functions, even in metd.c,
 * playing the same nonsense game with the field's length, so it needs more
 * careful examination. For now, the new checks in DYN_MOD should catch most anomalies.
 * 2001.7.3 Claudio Valderrama: fix Firebird Bug #223059 with mismatch between number
 * of declared fields for a VIEW and effective fields in the SELECT statement.
 * 2001.07.22 Claudio Valderrama: minor fixes and improvements.
 * 2001.08.18 Claudio Valderrama: RECREATE PROCEDURE.
 * 2001.10.01 Claudio Valderrama: modify_privilege() should recognize that a ROLE can
 *   now be made an explicit grantee.
 * 2001.10.08 Claudio Valderrama: implement frb_sysflag enum values for autogenerated
 *   non-system triggers so DFW can recognize them easily.
 * 2001.10.26 Claudio Valderrama: added a call to the new METD_drop_function()
 *   in DDL_execute() so the metadata cache for udfs can be refreshed.
 * 2001.12.06 Claudio Valderrama: DDL_resolve_intl_type should calculate field length
 * 2002.08.04 Claudio Valderrama: allow declaring and defining variables at the same time
 * 2002.08.04 Dmitry Yemanov: ALTER VIEW
 * 2002.08.31 Dmitry Yemanov: allowed user-defined index names for PK/FK/UK constraints
 * 2002.09.01 Dmitry Yemanov: RECREATE VIEW
 * 2002.09.12 Nickolay Samofatov: fixed cached metadata errors
 */

/* AB:Sync FB 1.132 */

#include "fbdev.h"
#include "../jrd/ib_stdio.h"
#include <string.h>
#include "../dsql/dsql.h"
#include "../jrd/ibase.h"
#include "../jrd/thd.h"
#include "../jrd/intl.h"
#include "../jrd/flags.h"
#include "../jrd/constants.h"
#include "../dsql/alld_proto.h"
#include "../dsql/errd_proto.h"
#include "../dsql/ddl_proto.h"
#include "../dsql/gen_proto.h"
#include "../dsql/make_proto.h"
#include "../dsql/metd_proto.h"
#include "../dsql/pass1_proto.h"
#include "../dsql/BlrGen.h"
#include "../jrd/sch_proto.h"
#include "../jrd/thd_proto.h"
#include "../jrd/gds_proto.h"
#include "Database.h"
#include "OSRIException.h"
#include "CsConvertArray.h"
#include "ProcParam.h"
#include "Procedure.h"
#include "ProcManager.h"
#include "../jrd/JrdMove.h"
#include "../jrd/val.h"

#ifdef DSQL_DEBUG
#include "../gpre/prett_proto.h"
#endif


const int BLOB_BUFFER_SIZE    = 4096;	// to read in blr blob for default values


static void assign_field_length(dsql_fld*, USHORT);
static bool is_array_or_blob(const dsql_nod*);
static void check_constraint(CStatement*, dsql_nod*, bool);
static void check_one_call(USHORT*, SSHORT, const TEXT*);
static void create_view_triggers(CStatement*, dsql_nod*, dsql_nod*);
static void define_computed(CStatement*, dsql_nod*, dsql_fld*, dsql_nod*);
static void define_constraint_trigger(CStatement*, dsql_nod*);
static void define_database(CStatement*);
static void define_del_cascade_trg(CStatement*, const dsql_nod*, const dsql_nod*,
	const dsql_nod*, const char*, const char*);
//static void define_del_default_trg(CStatement*, dsql_nod*, dsql_nod*, dsql_nod*, TEXT*, TEXT*);
static void define_dimensions(CStatement*, const dsql_fld*);
static void define_domain(CStatement*);
static void define_exception(CStatement*, NOD_TYPE);
static void define_user(CStatement*, int dynOperator);
static void define_field(CStatement*, dsql_nod*, SSHORT, const dsql_str*);
static void define_filter(CStatement*);
static void define_generator(CStatement*);
static void define_role(CStatement*);
static void define_index(CStatement*);
#ifdef NOT_USED_OR_REPLACED
static dsql_nod* define_insert_action(CStatement*);
#endif
static void define_procedure(CStatement*, NOD_TYPE);
static void define_rel_constraint(CStatement*, dsql_nod*);
static void define_relation(CStatement*);
static void define_set_null_trg(CStatement*, const dsql_nod*, const dsql_nod*,
	const dsql_nod*, const char*, const char*, bool);
static void define_set_default_trg(CStatement*, const dsql_nod*, const dsql_nod*,
	dsql_nod*, const char*, const char*, bool);
static void define_shadow(CStatement*);
static void define_trigger(CStatement*, dsql_nod*);
static void define_udf(CStatement*);
static void define_update_action(CStatement*, dsql_nod**, dsql_nod**, dsql_nod*);
static void define_upd_cascade_trg(CStatement*, const dsql_nod*, const dsql_nod*,
	const dsql_nod*, const char*, const char*);
static void define_view(CStatement*, NOD_TYPE);
static void define_view_relations(CStatement*, Stack*);
static void define_view_trigger(CStatement*, dsql_nod*, dsql_nod*, dsql_nod*);
static void delete_exception(CStatement*, dsql_nod*, bool);
static void delete_parameters(CStatement*, Procedure*);
static void delete_procedure(CStatement*, dsql_nod*, bool);
static void delete_relation_view(CStatement*, dsql_nod*, bool);
static void fix_default_source(dsql_str*);
static void foreign_key(CStatement*, dsql_nod*, const char* index_name);
static void generate_dyn(CStatement*, dsql_nod*);
static void grant_revoke(CStatement*);
static void make_index(CStatement*, const dsql_nod*, const dsql_nod*,
	const dsql_nod*, const char*, const char*);
static void make_index_trg_ref_int(CStatement*, dsql_nod*, dsql_nod*, dsql_nod*,
	const char*, const char*);
static void modify_database(CStatement*);
static void modify_domain(CStatement*);
static void modify_field(CStatement*, dsql_nod*, SSHORT, const dsql_str*);
static void modify_index(CStatement*);
static void modify_privilege(CStatement*, NOD_TYPE, SSHORT, const char*,
	const dsql_nod*, const dsql_nod*, const dsql_str*);
static SCHAR modify_privileges(CStatement*, NOD_TYPE, SSHORT, dsql_nod*,
	const dsql_nod*, const dsql_nod*);
static void modify_relation(CStatement*);
static int	new_parameter_list (CStatement*, dsql_nod*, int);
static void new_parameter_message (CStatement*, dsql_nod*);
static int	new_parameters (CStatement*, dsql_nod*);
static void new_procedure(CStatement*, dsql_str*, dsql_nod*);
static par* parameter_reverse_order(par* parameter, par* prev);
static void process_role_nm_list(CStatement*, SSHORT, dsql_nod*, dsql_nod*, NOD_TYPE);
static void put_descriptor(CStatement*, const dsc*);
static void put_dtype(CStatement*, dsql_fld*, bool);
static void put_field(CStatement*, dsql_fld*, bool);
static void put_local_variable(CStatement*, var*, dsql_nod*);
static void put_local_variables(CStatement*, dsql_nod*, SSHORT);
static void put_msg_field(CStatement*, dsql_fld*);
static dsql_nod* replace_field_names(CStatement* request, dsql_nod*, dsql_nod*, dsql_nod*, bool, const char*);
static void reset_context_stack(CStatement*);
static void save_field(CStatement*, const SCHAR*);
static void save_relation(CStatement*, dsql_str*);
static void set_statistics(CStatement*);
static void stuff_default_blr(CStatement*, const TEXT*, USHORT);
static void stuff_matching_blr(CStatement*, const dsql_nod*, const dsql_nod*);
static void stuff_trg_firing_cond(CStatement*, const dsql_nod*);
static void set_nod_value_attributes(dsql_nod*, const dsql_fld*);
static int getInt (dsql_nod *constant);

#ifdef BLKCHK
#undef BLKCHK
#endif

#ifdef DEV_BUILD
static inline void BLKCHK(const blk* p, const USHORT type)
{
	/***
	if (p && MemoryPool::blk_type(p) != type) {
		ERRD_bugcheck("Invalid block type");
	}
	***/
}
#else
static inline void BLKCHK(const void* p, const USHORT type)
{
}
#endif

static const int inputParameter = 0;
static const int outputParameter = 1;

static const int DEFAULT_BUFFER	= 2048;

static const int DEFAULT_BLOB_SEGMENT_SIZE = 80; // bytes


static const USHORT blr_dtypes[] = {
	0,
	blr_text,					// dtype_text 
	blr_cstring,				// dtype_cstring 
	blr_varying,				// dtype_varying 
	0,
	0,
	0,							// dtype_packed 
	0,							// dtype_byte 
	blr_short,					// dtype_short 
	blr_long,					// dtype_long 
	blr_quad,					// dtype_quad 
	blr_float,					// dtype_real 
	blr_double,					// dtype_double 
	blr_double,					// dtype_d_float 
	blr_sql_date,				// dtype_sql_date 
	blr_sql_time,				// dtype_sql_time 
	blr_timestamp,				// dtype_timestamp 
	blr_blob,					// dtype_blob 
	blr_short,					// dtype_array 
	blr_int64					// dtype_int64 
};

static const UCHAR nonnull_validation_blr[] = {
	blr_version5,
	blr_not,
	blr_missing,
	blr_fid, 0, 0, 0,
	blr_eoc
};

static inline bool hasOldContext(const int value)
{
	const int val1 = ((value + 1) >> 1) & 3;
	const int val2 = ((value + 1) >> 3) & 3;
	const int val3 = ((value + 1) >> 5) & 3;
	return (val1 && val1 != 1) || (val2 && val2 != 1) || (val3 && val3 != 1);
}

static inline bool hasNewContext(const int value)
{
	const int val1 = ((value + 1) >> 1) & 3;
	const int val2 = ((value + 1) >> 3) & 3;
	const int val3 = ((value + 1) >> 5) & 3;
	return (val1 && val1 != 3) || (val2 && val2 != 3) || (val3 && val3 != 3);
}


void DDL_execute(ISC_STATUS *statusVector, CStatement* request, Transaction *transaction)
{
/**************************************
 *
 *	D D L _ e x e c u t e
 *
 **************************************
 *
 * Functional description
 *	Call access method layered service DYN
 *	to interpret dyn string and perform
 *	metadata updates.
 *
 **************************************/
	//TSQL tdsql = GET_THREAD_DATA;

#ifdef DSQL_DEBUG_XXX
	if (DSQL_debug & 4) {
		dsql_trace("Output DYN string for DDL:");
		PRETTY_print_dyn(reinterpret_cast<UCHAR*>(request->req_blr_string->str_data),
						 gds__trace_printer, NULL, 0);
	}
#endif

	//int length = request->blrGen->blrLength();

	//THREAD_EXIT;

	//ISC_STATUS s = request->database->executeDDL (statusVector, transaction, length, request->blrGen->buffer);
		/***
		isc_ddl(tdsql->tsql_status, &request->req_dbb->dbb_database_handle,
				&request->req_trans, length, request->req_blr_string->str_data);
		***/
	//THREAD_ENTER;

	// for delete & modify, get rid of the cached relation metadata

	dsql_str* string = NULL;
	dsql_nod* relation_node;
	
	switch (request->ddlNode->nod_type)
		{
		case nod_mod_relation:
		case nod_redef_relation:
			relation_node = request->ddlNode->nod_arg[e_alt_name];
			if (string = (dsql_str*) relation_node->nod_arg[e_rln_name])
				request->dropRelation (*string);
			break;
			
		case nod_mod_view:
		case nod_replace_view:
		case nod_redef_view:
		case nod_del_relation:
		case nod_del_view:
			if (string = (dsql_str*) request->ddlNode->nod_arg[e_alt_name])
				request->dropRelation (*string);
			break;
			
		case nod_mod_procedure:
		case nod_del_procedure:
		case nod_replace_procedure:
		case nod_redef_procedure:
			string = (dsql_str*) request->ddlNode->nod_arg[e_prc_name];
			//METD_drop_procedure(request, string);
			request->dropProcedure (*string);
			break;
		
		case nod_del_udf:
			string = (dsql_str*) request->ddlNode->nod_arg[e_udf_name];
			//METD_drop_function (request, string);
			request->dropFunction (*string);
			break;
		}		

}

void DDL_gen_block(CStatement* request, dsql_nod* node)
{
/**************************************
 *
 *	D D L _ g e n _ b l o c k
 *
 **************************************
 *
 * Function
 *	Generate BLR for EXECUTE BLOCK statement
 *
 **************************************/
	SSHORT inputs = 0, outputs = 0, locals = 0;
	request->execBlockNode = node;
	
	dsql_nod* parameters;

	// now do the input parameters 
	if (parameters = node->nod_arg[e_exe_blk_inputs])
	{
		SSHORT position = 0;
		
		dsql_nod** ptr = parameters->nod_arg;
		for (const dsql_nod* const* const end = ptr + parameters->nod_count;
			ptr < end; ptr++)
			{
			dsql_nod* parameter = (*ptr)->nod_arg[e_prm_val_fld];
			dsql_fld* field = (dsql_fld*) parameter->nod_arg[e_dfl_field];
			// parameter = (*ptr)->nod_arg[e_prm_val_val]; USELESS

			DDL_resolve_intl_type(request, field, NULL);

			*ptr = MAKE_variable(request->threadData, field, field->fld_name,
						VAR_input, 0, (USHORT) (2 * position), locals++);
			position++;
			}
		inputs = position;
	}

	// now do the output parameters 
	if (parameters = node->nod_arg[e_exe_blk_outputs])
	{
		SSHORT position = 0;
		dsql_nod** ptr = parameters->nod_arg;
		for (const dsql_nod* const* const end = ptr + parameters->nod_count;
			ptr < end; ++ptr)
		{
			dsql_fld* field = (dsql_fld*) (*ptr)->nod_arg[e_dfl_field];

			DDL_resolve_intl_type(request, field, NULL);

			*ptr = MAKE_variable(request->threadData, field, field->fld_name,
						VAR_output, 1, (USHORT) (2 * position), locals++);
			position++;
		}
		outputs = position;
	}

	request->appendUCHAR(blr_begin);

	if (inputs) {
		request->sendMessage->msg_parameters = 
			parameter_reverse_order(request->sendMessage->msg_parameters, NULL);
		GEN_port(request, request->sendMessage);
	}
	else
		request->sendMessage = NULL;

	if (outputs)
	{
		SSHORT	position = 0;
		parameters = node->nod_arg[e_exe_blk_outputs];

		dsql_nod** ptr = parameters->nod_arg;
		for (const dsql_nod* const* const end = ptr + parameters->nod_count;
			 ptr < end; ptr++)
		{
			par* param = request->makeParameter(request->receiveMessage, true, true, ++position);
			param->par_node = *ptr;
			MAKE_desc(request->threadData, &param->par_desc, *ptr, NULL);
			param->par_desc.dsc_flags |= DSC_nullable;

			dsql_nod* parameter = *ptr;
			var* variable = (var*) parameter->nod_arg[e_var_variable];
			dsql_fld* field = variable->var_field;
			param->par_name = param->par_alias = field->fld_name;
		}
	}

	// Set up parameter to handle EOF 
	par* param = request->makeParameter(request->receiveMessage, false, false, 0);
	request->req_eof = param;
	param->par_desc.dsc_dtype = dtype_short;
	param->par_desc.dsc_scale = 0;
	param->par_desc.dsc_length = sizeof(SSHORT);

	request->receiveMessage->msg_parameters = 
		parameter_reverse_order(request->receiveMessage->msg_parameters, NULL);
	GEN_port(request, request->receiveMessage);

	if (inputs) {
		request->appendUCHAR(blr_receive);
		request->appendUCHAR(0);
	}

	request->appendUCHAR(blr_begin);

	if (outputs)
	{
		parameters = node->nod_arg[e_exe_blk_outputs];
		dsql_nod** ptr = parameters->nod_arg;
		for (const dsql_nod* const* const end = ptr + parameters->nod_count;
			 ptr < end; ptr++)
		{
			dsql_nod* parameter = *ptr;
			var* variable = (var*) parameter->nod_arg[e_var_variable];
			put_local_variable(request, variable, 0);
		}
	}

	put_local_variables(request, node->nod_arg[e_exe_blk_dcls], locals);

	request->appendUCHAR(blr_stall);
// Put a label before body of procedure, so that
//   any exit statement can get out
	request->appendUCHAR(blr_label);
	request->appendUCHAR(0);
	request->loopLevel = 0;
	GEN_statement(request,
		PASS1_statement(request, node->nod_arg[e_exe_blk_body], 1));
	if (outputs)
		request->req_type = REQ_SELECT_BLOCK;
	else
		request->req_type = REQ_EXEC_BLOCK;
	request->appendUCHAR(blr_end);
	GEN_return(request, node->nod_arg[e_exe_blk_outputs], true);
	request->appendUCHAR(blr_end);
}


void DDL_generate(CStatement* request, dsql_nod* node)
{
/**************************************
 *
 *	D D L _ g e n e r a t e
 *
 **************************************
 *
 * Functional description
 *	Generate the DYN string for a
 *	metadata update.  Done during the
 *	prepare phase.
 *
 **************************************/

	//if (request->dbb_flags & DBB_read_only)
	if (request->database->dbb_flags & DBB_read_only_flag)
		ERRD_post(isc_read_only_database, 0);
	
	request->appendUCHAR(isc_dyn_version_1);
	generate_dyn(request, node);
	request->appendUCHAR(isc_dyn_eoc);
}


//
// Determine whether ids or names should be referenced
// when generating blr for fields and relations.
//
bool DDL_ids(CStatement* request)
{
	dsql_nod* ddl_node = request->ddlNode;

	if (!ddl_node) {
		return true;
	}

	switch (ddl_node->nod_type)
	{
		case nod_def_view:
		case nod_redef_view:
		case nod_mod_view:
		case nod_replace_view:
		case nod_def_constraint:
		case nod_def_trigger:
		case nod_mod_trigger:
		case nod_replace_trigger:
		case nod_def_procedure:
		case nod_def_computed:
		case nod_mod_procedure:
		case nod_replace_procedure:
		case nod_redef_procedure:
			return false;

		default:
			return true;
	}
}


//
// Emit blr that describes a descriptor.
// Note that this depends on the same stuff variant
// as used in gen.cpp
//
void DDL_put_field_dtype(CStatement* request, dsql_fld* field, bool use_subtype)
{
	put_dtype(request, field, use_subtype);
}


//
// See the next function for description. This is only a
// wrapper that sets the last parameter to false to indicate
// we are creating a field, not modifying one.
//

void DDL_resolve_intl_type(CStatement* request, dsql_fld* field, dsql_str* collation_name)
{
    DDL_resolve_intl_type2 (request, field, collation_name, false);
}



void DDL_resolve_intl_type2(CStatement* request,
                            dsql_fld* field,
                            dsql_str* collation_name,
                            bool     modifying)
{
/**************************************
 *
 *  D D L _ r e s o l v e _ i n t l _ t y p e 2
 *
 **************************************
 *
 * Function

 *	If the field is defined with a character set or collation,
 *	resolve the names to a subtype now.
 *
 *	Also resolve the field length & whatnot.
 *
 *  If the field is being created, it will pick the db-wide charset
 *  and collation if not specified. If the field is being modified,
 *  since we don't allow changes to those attributes, we'll go and
 *  calculate the correct old lenth from the field itself so DYN
 *  can validate the change properly.
 *
 *	For International text fields, this is a good time to calculate
 *	their actual size - when declared they were declared in
 *	lengths of CHARACTERs, not BYTES.
 *
 **************************************/

	if ((field->fld_dtype > dtype_any_text) && field->fld_dtype != dtype_blob)
		{
		if (field->fld_character_set || collation_name || field->fld_flags & FLD_national)
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204,
						isc_arg_gds, isc_dsql_datatype_err,
						isc_arg_gds, isc_collation_requires_text, 0);
		return;
		}

	if (field->fld_dtype == dtype_blob)
		{
		if (field->fld_sub_type_name)
			{
			SSHORT blob_sub_type;
			/***
			if (!METD_get_type(request,
								reinterpret_cast<const dsql_str*>(field->fld_sub_type_name),
								"RDB$FIELD_SUB_TYPE",
								&blob_sub_type))
			***/
			if (!request->getType (*reinterpret_cast<dsql_str*>(field->fld_sub_type_name), "RDB$FIELD_SUB_TYPE", &blob_sub_type))
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204, isc_arg_gds,
							isc_dsql_datatype_err, isc_arg_gds, 
							isc_dsql_blob_type_unknown, isc_arg_string,
							((dsql_str*) field->fld_sub_type_name)->str_data, 0);
			field->fld_sub_type = blob_sub_type;
			}
			
		if (field->fld_character_set && (field->fld_sub_type == BLOB_untyped))
			field->fld_sub_type = BLOB_text;

		if (field->fld_character_set && (field->fld_sub_type != BLOB_text))
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204, isc_arg_gds,
						isc_dsql_datatype_err, isc_arg_gds,
						isc_collation_requires_text, 0);

		if (collation_name)
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204, isc_arg_gds,
						isc_dsql_datatype_err, isc_arg_gds,
						isc_collation_requires_text, 0);

		if (field->fld_sub_type != BLOB_text) 
			return;
		}

	if (field->fld_character_set_id != 0 && !collation_name) 
		// This field has already been resolved once, and the collation
		// hasn't changed.  Therefore, no need to do it again.
		return;


    if (modifying)
		{
		dsql_rel* relation = request->req_relation;
		dsql_fld* afield = field->fld_next;
		USHORT bpc = 0;
		
        while (afield) 
			{
            // The first test is redundant. 
            if (afield != field && afield->fld_relation && !strcmp (afield->fld_name, field->fld_name))
				{
                fb_assert(afield->fld_relation == relation || !relation);
                break;
				}
            afield = afield->fld_next;
			}
			
        if (afield) 
			{
            field->fld_character_set_id = afield->fld_character_set_id;
            //bpc = METD_get_charset_bpc (request, field->fld_character_set_id);
			bpc = request->getCharsetBytesPerCharacter (field->fld_character_set_id);
            field->fld_collation_id = afield->fld_collation_id;
            field->fld_ttype = afield->fld_ttype;

            if (afield->fld_flags & FLD_national)
                field->fld_flags |= FLD_national;
            else 
                field->fld_flags &= ~FLD_national;
            
            assign_field_length (field, bpc);
            
            return;
			}
		}

	if (!(field->fld_character_set || field->fld_character_set_id ||	// set if a domain 
		  (field->fld_flags & FLD_national)))
		{

		// Attach the database default character set, if not otherwise specified

		//const dsql_str* dfl_charset = METD_get_default_charset(request);
		dsql_str* dfl_charset = request->getDefaultCharset();
		
		if (dfl_charset)
			field->fld_character_set = (dsql_nod*) dfl_charset;
		else
			{
			/* If field is not specified with NATIONAL, or CHARACTER SET
			 * treat it as a single-byte-per-character field of character set NONE.
			 */
            assign_field_length (field, 1);
            field->fld_ttype = 0;
            
			if (!collation_name) 
				return;
			}
		}

	const char* charset_name = 0;

	if (field->fld_flags & FLD_national) 
		charset_name = NATIONAL_CHARACTER_SET;
	else if (field->fld_character_set) 
		charset_name = ((dsql_str*) field->fld_character_set)->str_data;

	// Find an intlsym for any specified character set name & collation name
	
	CharSetContainer* resolved_type;
	
	if (charset_name)
		{
		CharSetContainer* resolved_charset = request->findCharset (charset_name);
			/***
			METD_get_charset(request,
							(USHORT) strlen(charset_name),
							charset_name);
			***/
		// Error code -204 (IBM's DB2 manual) is close enough
		if (!resolved_charset)
			{
			// specified character set not found
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204,
					  isc_arg_gds, isc_dsql_datatype_err,
					  isc_arg_gds, isc_charset_not_found, isc_arg_string,
					  charset_name, 0);
			}
		field->fld_character_set_id = resolved_charset->getCharsetId();
		resolved_type = resolved_charset;
		}

	if (collation_name)
		{
		CharSetContainer* resolved_collation = request->findCollation (*collation_name);
			//METD_get_collation(request, collation_name);

		if (!resolved_collation)
			// Specified collation not found
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204,
					  isc_arg_gds, isc_dsql_datatype_err,
					  isc_arg_gds, isc_collation_not_found, isc_arg_string,
					  collation_name->str_data, 0);

		// If both specified, must be for same character set
		// A "literal constant" must be handled (charset as ttype_dynamic)

		resolved_type = resolved_collation;
		
		if ((field->fld_character_set_id != resolved_type->getCharsetId()) &&
			 (field->fld_character_set_id != ttype_dynamic))
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204, isc_arg_gds,
					  isc_dsql_datatype_err, isc_arg_gds,
					  isc_collation_not_for_charset, isc_arg_string,
					  collation_name->str_data, 0);
		}

    assign_field_length (field, resolved_type->getBytesPerChar());

	field->fld_ttype            = resolved_type->getTType();
	field->fld_character_set_id = resolved_type->getCharsetId();
	field->fld_collation_id     = resolved_type->getCollationId();
}



static void assign_field_length (
    dsql_fld* field,
    USHORT  bytes_per_char)
{
/**************************************
 *
 *  a s s i g n _ f i e l d _ l e n g t h
 *
 **************************************
 *
 * Function
 *  We'll see if the field's length fits in the maximum
 *  allowed field, including charset and space for varchars.
 *  Either we raise an error or assign the field's length.
 *  If the charlen comes as zero, we do nothing, although we
 *  know that DYN, MET and DFW will blindly set field length
 *  to zero if they don't catch charlen or another condition.
 *
 **************************************/

	if (field->fld_character_length)
	{
		ULONG field_length = (ULONG) bytes_per_char * 
            field->fld_character_length;

		if (field->fld_dtype == dtype_varying) {
			field_length += sizeof(USHORT);
		}
		if (field_length > (ULONG) MAX_COLUMN_SIZE)
		{
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204,
					  isc_arg_gds, isc_dsql_datatype_err,
					  isc_arg_gds, isc_imp_exc,
					  isc_arg_gds, isc_field_name, isc_arg_string,
					  (const char*) field->fld_name, 0);
		}
		field->fld_length = (USHORT) field_length;
	}

}


static bool is_array_or_blob(const dsql_nod* node)
{
/**************************************
 *
 *	i s _ a r r a y _ o r _ b l o b
 *
 **************************************
 *
 * Functional description
 *	return true if there is an array or blob in expression, else false.
 *	Array and blob expressions have limited usefullness in a computed
 *	expression - so we detect it here to report a syntax error at
 *	definition time, rather than a runtime error at execution.
 *
 **************************************/

	BLKCHK(node, dsql_type_nod);

	switch (node->nod_type) 
		{
		case nod_agg_count:
		case nod_count:
		case nod_gen_id:
		case nod_gen_id2:
		case nod_dbkey:
		case nod_current_date:
		case nod_current_time:
		case nod_current_timestamp:
		case nod_constant:
		case nod_null:
		case nod_via:
		case nod_substr:
		case nod_internal_info:
			return false;

		case nod_map:
			{
			const dsql_map* map = (dsql_map*) node->nod_arg[e_map_map];
			return is_array_or_blob(map->map_node);
			}

		case nod_agg_max:
		case nod_agg_min:
		case nod_agg_average:
		case nod_agg_total:
		case nod_agg_average2:
		case nod_agg_total2:
		case nod_upcase:
		case nod_negate:
			return is_array_or_blob(node->nod_arg[0]);

		case nod_cast:
			{
			const dsql_fld* fld = (dsql_fld*) node->nod_arg[e_cast_target];
			if ((fld->fld_dtype == dtype_blob) || (fld->fld_dtype == dtype_array)) 
				return true;

			return is_array_or_blob(node->nod_arg[e_cast_source]);
			}

		case nod_add:
		case nod_subtract:
		case nod_concatenate:
		case nod_multiply:
		case nod_divide:
		case nod_add2:
		case nod_subtract2:
		case nod_multiply2:
		case nod_divide2:
			if (is_array_or_blob(node->nod_arg[0])) 
				return true;

			return is_array_or_blob(node->nod_arg[1]);

		case nod_alias:
			return is_array_or_blob(node->nod_arg[e_alias_value]);

		case nod_udf:
			{
			//const dsql_udf* userFunc = (dsql_udf*) node->nod_arg[0];
			UserFunction* userFunc = (UserFunction*) node->nod_arg[0];
			dsc desc = userFunc->fun_rpt[userFunc->fun_return_arg].fun_desc;
			return (desc.dsc_dtype == dtype_blob) || (desc.dsc_dtype == dtype_array);
			}

		case nod_extract:
		case nod_list:
			{
			const dsql_nod* const* const end = node->nod_arg + node->nod_count;
			for (const dsql_nod* const* ptr = node->nod_arg; ptr < end; ++ptr)
				if (is_array_or_blob(*ptr)) 
					return true;

			return false;
			}

		case nod_field:
			return (node->nod_desc.dsc_dtype == dtype_blob) || (node->nod_desc.dsc_dtype == dtype_array);

		default:
			fb_assert(false);
			return false;
		}
}


static void check_constraint(	CStatement*		request,
								dsql_nod*		element,
								bool delete_trigger_required)
{
/* *************************************
 *
 *	c h e c k _ c o n s t r a i n t
 *
 **************************************
 *
 * Function
 *	Generate triggers to implement the CHECK
 *	clause, either at the field or table level.
 *
 **************************************/

	dsql_nod* ddl_node = request->ddlNode;

	if (!(element->nod_arg[e_cnstr_table])) {
		element->nod_arg[e_cnstr_table] = ddl_node->nod_arg[e_drl_name];
	}

	// specify that the trigger should abort if the condition is not met

	dsql_nod* list_node = MAKE_node(request->threadData, nod_list, (int) 1);
	element->nod_arg[e_cnstr_actions] = list_node;
	list_node->nod_arg[0] = MAKE_node(request->threadData, nod_gdscode, (int) 1);

	dsql_nod** errorcode_node = &list_node->nod_arg[0]->nod_arg[0];
	*errorcode_node = (dsql_nod*) MAKE_cstring(request->threadData, "check_constraint");
	element->nod_arg[e_cnstr_message] = NULL;

	// create the INSERT trigger

// element->nod_arg[e_cnstr_message] =
//   (dsql_nod*) MAKE_cstring ("insert violates CHECK constraint on table");

	element->nod_arg[e_cnstr_type] =
		MAKE_constant(request->threadData, (dsql_str*) PRE_STORE_TRIGGER, CONSTANT_SLONG);
	define_constraint_trigger(request, element);

	// create the UPDATE trigger

// element->nod_arg[e_cnstr_message] =
//  (dsql_nod*) MAKE_cstring ("update violates CHECK constraint on table");

	element->nod_arg[e_cnstr_type] =
		MAKE_constant(request->threadData, (dsql_str*) PRE_MODIFY_TRIGGER, CONSTANT_SLONG);
	define_constraint_trigger(request, element);

	// create the DELETE trigger, if required
	if (delete_trigger_required)
	{
//
//		element->nod_arg[e_cnstr_message] =
//			(dsql_nod*) MAKE_cstring ("delete violates CHECK constraint on table");
//
		element->nod_arg[e_cnstr_type] =
			MAKE_constant(request->threadData, (dsql_str*) PRE_ERASE_TRIGGER, CONSTANT_SLONG);
		define_constraint_trigger(request, element);
	}

	request->appendUCHAR(isc_dyn_end);	// For CHECK constraint definition
}


static void check_one_call (USHORT* repetition_count,
							SSHORT pos,
							const TEXT* error_msg)
{
/**************************************
 *
 *  c h e c k _ o n e _ c a l l
 *
 **************************************
 *
 * Function
 *  Ensure that each option in modify_domain() is called only once.
 *  This restriction cannot be enforced by the DSQL parser.
 *
 **************************************/
	if (++repetition_count[pos] > 1) {
		ERRD_post (isc_sqlerr, isc_arg_number, (SLONG) -637,
				   isc_arg_gds, isc_dsql_duplicate_spec,
                   isc_arg_string, error_msg,
                   0);
	}
}


static void create_view_triggers(CStatement* request, dsql_nod* element,
	dsql_nod* items)
{								// Fields in the VIEW actually  
/* *************************************
 *
 *	c r e a t e _ v i e w _ t r i g g e r s
 *
 **************************************
 *
 * Function
 *	Generate triggers to implement the WITH CHECK OPTION
 *	clause for a VIEW
 *  
 **************************************/

	dsql_nod* ddl_node = request->ddlNode;

	if (!(element->nod_arg[e_cnstr_table])) {
		element->nod_arg[e_cnstr_table] = ddl_node->nod_arg[e_drl_name];
	}

	// specify that the trigger should abort if the condition is not met

	dsql_nod* list_node = MAKE_node(request->threadData, nod_list, (int) 1);
	element->nod_arg[e_cnstr_actions] = list_node;
	list_node->nod_arg[0] = MAKE_node(request->threadData, nod_gdscode, (int) 1);

	dsql_nod** errorcode_node = &list_node->nod_arg[0]->nod_arg[0];
	*errorcode_node = (dsql_nod*) MAKE_cstring(request->threadData, "check_constraint");
	element->nod_arg[e_cnstr_message] = NULL;

	// create the UPDATE trigger

// element->nod_arg[e_cnstr_message] =
//   (dsql_nod*) MAKE_cstring ("update violates CHECK constraint on view");

	element->nod_arg[e_cnstr_type] =
		MAKE_constant(request->threadData, (dsql_str*) PRE_MODIFY_TRIGGER, CONSTANT_SLONG);
		
	dsql_nod* base_and_node = 0;
	dsql_nod* base_relation = 0;
	define_update_action(request, &base_and_node, &base_relation, items);

	dsql_nod* rse = MAKE_node(request->threadData, nod_rse, e_rse_count);
	rse->nod_arg[e_rse_boolean] = base_and_node;
	dsql_nod* temp = MAKE_node(request->threadData, nod_list, 1);
	rse->nod_arg[e_rse_streams] = temp;
	temp->nod_arg[0] = base_relation;
	define_view_trigger(request, element, rse, items);

	// create the INSERT trigger

// element->nod_arg[e_cnstr_message] =
//   (dsql_nod*) MAKE_cstring ("insert violates CHECK constraint on view");

	element->nod_arg[e_cnstr_type] =
		MAKE_constant(request->threadData, (dsql_str*) PRE_STORE_TRIGGER, CONSTANT_SLONG);
	define_view_trigger(request, element, NULL, items);

	request->appendUCHAR(isc_dyn_end);	// For triggers definition
}


static void define_computed(CStatement* request,
							dsql_nod* relation_node,
							dsql_fld* field,
							dsql_nod* node)
{
/**************************************
 *
 *	d e f i n e _ c o m p u t e d
 *
 **************************************
 *
 * Function
 *	Create the ddl to define a computed field
 *	or an expression index.
 *
 **************************************/

	dsql_nod* ddl_node = request->ddlNode;
	request->ddlNode = node;

	// Get the table node & set up correct context

	if (request->contextNumber) {
		reset_context_stack(request);
	}

	dsc save_desc;
	// Save the size of the field if it is specified
	save_desc.dsc_dtype = 0;

	if (field && field->fld_dtype)
	{
		fb_assert(field->fld_dtype <= MAX_UCHAR);
		save_desc.dsc_dtype = (UCHAR) field->fld_dtype;
		save_desc.dsc_length = field->fld_length;
		fb_assert(field->fld_scale <= MAX_SCHAR);
		save_desc.dsc_scale = (SCHAR) field->fld_scale;

		field->fld_dtype = 0;
		field->fld_length = 0;
		field->fld_scale = 0;
	}

	PASS1_make_context(request, relation_node);

	dsql_nod* input = PASS1_node(request, node->nod_arg[e_cmp_expr], false);

	// check if array or blobs are used in expression

	if (is_array_or_blob(input))
	{
		ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
				  isc_arg_gds, isc_dsql_no_blob_array, 0);
	}


	// generate the blr expression

	request->appendUCHAR(isc_dyn_fld_computed_blr);
	request->blrBegin(0);
	GEN_expr(request, input);
	request->blrEnd();

	// try to calculate size of the computed field. The calculated size
	// may be ignored, but it will catch self references
	dsc desc;
	MAKE_desc(request->threadData, &desc, input, NULL);

	if (save_desc.dsc_dtype) {
		// restore the field size/type overrides
		field->fld_dtype  = save_desc.dsc_dtype;
		field->fld_length = save_desc.dsc_length;
		field->fld_scale  = save_desc.dsc_scale;
	}
	else if (field) {
		// use size calculated
		field->fld_dtype  = desc.dsc_dtype;
		field->fld_length = desc.dsc_length;
		field->fld_scale  = desc.dsc_scale;
	}

	request->req_type = REQ_DDL;
	request->ddlNode = ddl_node;
	reset_context_stack(request);

	// generate the source text
	const dsql_str* source = (dsql_str*) node->nod_arg[e_cmp_text];
	fb_assert(source->str_length <= MAX_USHORT);
	request->appendDynString(	isc_dyn_fld_computed_source,
							source->str_data,
							(USHORT) source->str_length);
}


static void define_constraint_trigger(CStatement* request, dsql_nod* node)
{
/**************************************
 *
 *	d e f i n e _ c o n s t r a i n t _ t r i g g e r
 *
 **************************************
 *
 * Function
 *	Create the ddl to define or alter a constraint trigger.
 * This is a SQL's check constraint.  
 *
 **************************************/

	/* make the "define trigger" node the current request ddl node so
	  that generating of BLR will be appropriate for trigger */

	dsql_nod* ddl_node = request->ddlNode;
	request->ddlNode = node;

	if (node->nod_type != nod_def_constraint)
		return;

	const dsql_str* trigger_name = (dsql_str*) node->nod_arg[e_cnstr_name];
	fb_assert(trigger_name->str_length <= MAX_USHORT);

	request->appendDynString(isc_dyn_def_trigger,trigger_name->str_data, trigger_name->str_length);
	dsql_nod* relation_node = node->nod_arg[e_cnstr_table];
	const dsql_str* relation_name = (dsql_str*) relation_node->nod_arg[e_rln_name];
	fb_assert(trigger_name->str_length <= MAX_USHORT);
	request->appendDynString(isc_dyn_rel_name,relation_name->str_data,(USHORT) relation_name->str_length);
	const dsql_str* source = (dsql_str*) node->nod_arg[e_cnstr_source];
	
	if (source)
		{
		fb_assert(source->str_length <= MAX_USHORT);
		request->appendDynString(isc_dyn_trg_source,source->str_data,(USHORT) source->str_length);
		}

	dsql_nod* constant = node->nod_arg[e_cnstr_position];
	
	if (constant)
		request->appendNumber(isc_dyn_trg_sequence, getInt(constant));
				   //(SSHORT)(long) (constant ? constant->nod_arg[0] : 0));

	constant = node->nod_arg[e_cnstr_type];
	
	if (constant != NULL)
		{
		//const SSHORT type = (SSHORT)(long) constant->nod_arg[0];
		int type = getInt(constant);
		request->appendNumber(isc_dyn_trg_type, type);
		}

	request->appendUCHAR(isc_dyn_sql_object);
	const dsql_str* message = (dsql_str*) node->nod_arg[e_cnstr_message];
	
	if (message)
		{
		request->appendNumber(isc_dyn_def_trigger_msg, 0);
		fb_assert(message->str_length <= MAX_USHORT);
		request->appendDynString(	isc_dyn_trg_msg,
								message->str_data,
								(USHORT) message->str_length);
		request->appendUCHAR(isc_dyn_end);
		}

	// generate the trigger blr

	if (node->nod_arg[e_cnstr_condition] && node->nod_arg[e_cnstr_actions])
		{
		request->blrBegin(isc_dyn_trg_blr);
		request->appendUCHAR(blr_begin);

		/* create the "OLD" and "NEW" contexts for the trigger --
		   the new one could be a dummy place holder to avoid resolving
		   fields to that context but prevent relations referenced in
		   the trigger actions from referencing the predefined "1" context */

		if (request->contextNumber)
			reset_context_stack(request);

        // CVC: check_constraint() is the only caller and it always receives 
        // false for the delete_trigger_required flag. Hence, I thought I could
        // disable the OLD context here to avoid "ambiguous field name" errors
        // in pre_store and pre_modify triggers. Also, what sense can I make 
        // from NEW in pre_delete? However, we clash at JRD with "no current 
        // record for fetch operation".

		relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, OLD_CONTEXT);
		PASS1_make_context(request, relation_node);
		relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, NEW_CONTEXT);
		PASS1_make_context(request, relation_node);

		// generate the condition for firing the trigger

		request->appendUCHAR(blr_if);
		GEN_expr(request, PASS1_node(request, node->nod_arg[e_cnstr_condition], false));
		request->appendUCHAR(blr_begin);
		request->appendUCHAR(blr_end);		// of begin

		// generate the action statements for the trigger
		dsql_nod*  actions = node->nod_arg[e_cnstr_actions];
		dsql_nod** ptr = actions->nod_arg;

		for (dsql_nod* const* const end = ptr + actions->nod_count; ptr < end; ptr++)
			GEN_statement(request, PASS1_statement(request, *ptr, false));

		// generate the action statements for the trigger 

		if ((actions = node->nod_arg[e_cnstr_else]) != NULL)
			{
			request->appendUCHAR(blr_begin);
			ptr = actions->nod_arg;
			for (dsql_nod* const* const end = ptr + actions->nod_count;  ptr < end; ptr++)
				GEN_statement(request, PASS1_statement(request, *ptr, false));
			request->appendUCHAR(blr_end);	// of begin
			}
		else
			request->appendUCHAR(blr_end);	// of if

		request->blrEnd();
		}

    request->appendNumber(isc_dyn_system_flag, frb_sysflag_check_constraint);
	request->appendUCHAR(isc_dyn_end);

	/* the request type may have been set incorrectly when parsing
	   the trigger actions, so reset it to reflect the fact that this
	   is a data definition request; also reset the ddl node */

	request->req_type = REQ_DDL;
	request->ddlNode = ddl_node;
	reset_context_stack(request);
}


static void define_database( CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ d a t a b a s e
 *
 **************************************
 *
 * Function
 *	Create a database. Assumes that
 *	database is created elsewhere with
 *	initial options. Modify the
 *	database using DYN to add the remaining
 *	options.
 *
 **************************************/
	SLONG start = 0;

	dsql_nod* ddl_node = request->ddlNode;
	request->appendUCHAR(isc_dyn_mod_database);
	
	//request->appendNumber(isc_dyn_rel_sql_protection, 1);

	dsql_nod* elements = ddl_node->nod_arg[e_database_initial_desc];

	if (elements) 
		{
		dsql_nod* const* ptr = elements->nod_arg;
		
		for (dsql_nod* const* const end = ptr + elements->nod_count; ptr < end; ptr++)
			{
			dsql_nod* element = *ptr;
			if (element->nod_type == nod_file_length)
				start = (long) (element->nod_arg[0]) + 1;
			}
		}
		
	const dsql_str* name;
	const dsql_fil* file;
	//SLONG temp_long;
	//SSHORT temp_short;
	//SSHORT number = 0;
	elements = ddl_node->nod_arg[e_database_rem_desc];
	
	if (elements)
		{
		const dsql_nod* const* ptr = elements->nod_arg;
		for (const dsql_nod* const* const end = ptr + elements->nod_count; ptr < end; ptr++)
			{
			const dsql_nod* element = *ptr;

			switch (element->nod_type) 
				{
				case nod_difference_file:
					request->appendDynString(isc_dyn_def_difference, 
						((dsql_str*)element->nod_arg[0])->str_data);
					break;
					
				case nod_file_desc:
					file = (dsql_fil*) element->nod_arg[0];
					request->appendDynString(isc_dyn_def_file,
								file->fil_name->str_data);

					start = MAX(start, file->fil_start);
					request->appendNumber (isc_dyn_file_start, start);
					request->appendNumber (isc_dyn_file_length, file->fil_length);
					request->appendUCHAR(isc_dyn_end);
					start += file->fil_length;
					break;

/*
				case nod_log_file_desc:
					file = (dsql_fil*) element->nod_arg[0];

					if (file->fil_flags & LOG_default) 
						{
						request->appendUCHAR(isc_dyn_def_default_log);
						break;
						}
						
					request->appendDynString(isc_dyn_def_log_file, file->fil_name->str_data);
					request->appendNumber (isc_dyn_file_length, file->fil_length);
					request->appendUCHAR(isc_dyn_log_file_sequence);
					request->appendNumber(number);
					++number;
					request->appendUCHAR(isc_dyn_log_file_partitions);
					request->appendNumber(file->fil_partitions);
					
					if (file->fil_flags & LOG_serial) 
						request->appendUCHAR(isc_dyn_log_file_serial);
					if (file->fil_flags & LOG_overflow) 
						request->appendUCHAR(isc_dyn_log_file_overflow);
					if (file->fil_flags & LOG_raw) 
						request->appendUCHAR(isc_dyn_log_file_raw);
					request->appendUCHAR(isc_dyn_end);
					break;

				case nod_cache_file_desc:
					file = (dsql_fil*) element->nod_arg[0];
					request->appendDynString(isc_dyn_def_cache_file,
								file->fil_name->str_data);
					request->appendNumber (isc_dyn_file_length, file->fil_length);
					request->appendUCHAR(isc_dyn_end);
					break;

				case nod_group_commit_wait:
					request->appendUCHAR(isc_dyn_log_group_commit_wait);
					temp_long = (long) (element->nod_arg[0]);
					request->appendNumber(temp_long);
					break;

				case nod_check_point_len:
					request->appendUCHAR(isc_dyn_log_check_point_length);
					temp_long = (long) (element->nod_arg[0]);
					request->appendNumber(temp_long);
					break;

				case nod_num_log_buffers:
					request->appendUCHAR(isc_dyn_log_num_of_buffers);
					temp_short = getInt(element); //(SSHORT)(long) (element->nod_arg[0]);
					request->appendNumber(temp_short);
					break;

				case nod_log_buffer_size:
					request->appendUCHAR(isc_dyn_log_buffer_size);
					temp_short = getInt(element); //(SSHORT)(long) (element->nod_arg[0]);
					request->appendNumber(temp_short);
					break;
*/

				case nod_dfl_charset:
					name = (dsql_str*) element->nod_arg[0];
					request->appendDynString(isc_dyn_fld_character_set_name, name->str_data);
					break;

				default:
					break;
				}
			}
		}

	request->appendUCHAR(isc_dyn_end);
}


static void define_del_cascade_trg(	CStatement*    request,
									const dsql_nod*    element,
									const dsql_nod*    for_columns,
									const dsql_nod*    prim_columns,
									const char* prim_rel_name,
									const char* for_rel_name)
{
/*****************************************************
 *
 *	d e f i n e _ d e l _ c a s c a d e _ t r g
 *
 *****************************************************
 *
 * Function
 *	define "on delete cascade" trigger (for referential integrity)
 *      along with its blr
 *
 *****************************************************/

	if (element->nod_type != nod_foreign) {
		return;
	}

	// stuff a trigger_name of size 0. So the dyn-parser will make one up.
	request->appendDynString(	isc_dyn_def_trigger, "", 0);

	request->appendNumber(isc_dyn_trg_type, (SSHORT) POST_ERASE_TRIGGER);

	request->appendUCHAR(isc_dyn_sql_object);
	request->appendNumber(isc_dyn_trg_sequence, (SSHORT) 1);
	request->appendNumber(isc_dyn_trg_inactive, (SSHORT) 0);
	request->appendDynString(isc_dyn_rel_name, prim_rel_name);

	// the trigger blr
	request->blrBegin(isc_dyn_trg_blr);
	request->appendUCHAR(blr_for);
	request->appendUCHAR(blr_rse);

	// the context for the prim. key relation
	request->appendUCHAR(1);

	request->appendUCHAR(blr_relation);
	request->appendBlrString(for_rel_name);
	// the context for the foreign key relation
	request->appendUCHAR(2);

	stuff_matching_blr(request, for_columns, prim_columns);

	request->appendUCHAR(blr_erase);
	request->appendUCHAR(2);
	request->blrEnd();
	// end of the blr

    request->appendNumber(isc_dyn_system_flag, 
                           frb_sysflag_referential_constraint);

	// no trg_source and no trg_description
	request->appendUCHAR(isc_dyn_end);

}


static void define_set_default_trg(	CStatement*    request,
									const dsql_nod*    element,
									dsql_nod*    for_columns,
									dsql_nod*    prim_columns,
									const char*	prim_rel_name,
									const char*	for_rel_name,
									bool        on_upd_trg)
{
/*****************************************************
 *
 *	d e f i n e _ s e t _ d e f a u l t _ t r g
 *
 *****************************************************
 *
 * Function
 *	define "on delete|update set default" trigger (for
 *      referential integrity) along with its blr
 *
 *****************************************************/

	char default_val[BLOB_BUFFER_SIZE];

	if (element->nod_type != nod_foreign) {
		return;
	}

	/***
	request->generate_unnamed_trigger_beginning(on_upd_trg,
												prim_rel_name,
												prim_columns,
												for_rel_name,
												for_columns);
	***/
	request->genUnnamedTriggerBeginning (on_upd_trg, prim_rel_name, prim_columns, for_rel_name, for_columns);

	USHORT num_fields = 0;
	const dsql_nod* const* for_key_flds = for_columns->nod_arg;
	const dsql_nod* ddl_node = request->ddlNode;

	do {
		// for every column in the foreign key .... 
		dsql_str* for_key_fld_name_str = (dsql_str*) (*for_key_flds)->nod_arg[1];

		request->appendUCHAR(blr_assignment);

		/* here stuff the default value as blr_literal .... or blr_null
		   if this col. does not have an applicable default */

		/* the default is determined in many cases:
		   (1) the info. for the column is in memory. (This is because
		   the column is being created in this ddl statement)
		   (1-a) the table has a column level default. We get this by
		   searching the dsql parse tree starting from the ddl node.
		   (1-b) the table does not have a column level default, but
		   has a domain default. We get the domain name from the dsql
		   parse tree and call METD_get_domain_default to read the
		   default from the system tables.
		   (2) The default-info for this column is not in memory (This is
		   because this is an alter table ddl statement). The table
		   already exists; therefore we get the column and/or domain
		   default value from the system tables by calling:
		   METD_get_col_default().  */

		bool found_default = false;
		bool search_for_default = true;

		// search the parse tree to find the column 

		const dsql_nod* elem = ddl_node->nod_arg[e_drl_elements];
		const dsql_nod* const* ptr = elem->nod_arg;
		for (const dsql_nod* const* const end = ptr + elem->nod_count;
			ptr < end; ++ptr)
		{
			elem = *ptr;
			if (elem->nod_type != nod_def_field) {
				continue;
			}

			dsql_fld* field = (dsql_fld*) elem->nod_arg[e_dfl_field];
			if (strcmp(field->fld_name, for_key_fld_name_str->str_data))
			{
				continue;
			}

			/* Now, we have the right column in the parse tree. case (1) above */

			dsql_nod* default_node = elem->nod_arg[e_dfl_default];
			if (default_node)
			{
				/* case (1-a) above: there is a col. level default */
				GEN_expr(request, default_node);
				found_default = true;
				search_for_default = false;
			}
			else
			{
				const TEXT* domain_name;
				const dsql_str* domain_name_str;
				const dsql_nod* tmp_node;

				const dsql_nod* domain_node = elem->nod_arg[e_dfl_domain];
				if (!domain_node ||
					!(tmp_node = domain_node->nod_arg[e_dom_name]) ||
					!(domain_name_str = (dsql_str*) tmp_node->nod_arg[e_fln_name])
					|| !(domain_name = domain_name_str->str_data))
				{
					break;
				}

				/* case: (1-b): domain name is available. Column level default
				   is not declared. so get the domain default */
				/***
				METD_get_domain_default(request, domain_name, &found_default,
										default_val,
										sizeof(default_val));
				***/
				found_default = request->getDomainDefault (domain_name, default_val, sizeof (default_val));
				search_for_default = false;
				if (found_default)
				{
					stuff_default_blr(request, default_val, sizeof(default_val));
				}
				else
				{
					// neither col level nor domain level default exists
					request->appendUCHAR(blr_null);
				}
			}
			break;
		}

		if (search_for_default)
			{
			// case 2: see if the column/domain has already been created 
			/***
			METD_get_col_default(request, for_rel_name,
								 for_key_fld_name_str->str_data,
								 &found_default,
								 default_val,
								 sizeof(default_val));
			***/
			found_default = request->getColumnDefault (for_rel_name, *for_key_fld_name_str, default_val, sizeof (default_val));

			if (found_default) 
				stuff_default_blr(request, default_val, sizeof(default_val));
			else
				request->appendUCHAR(blr_null);
			}

		// the context for the foreign key relation
		request->appendUCHAR(blr_field);
		request->appendUCHAR(2);
		request->appendBlrString(for_key_fld_name_str->str_data);

		num_fields++;
		for_key_flds++;

	} while (num_fields < for_columns->nod_count);

	request->appendUCHAR(blr_end);

	if (on_upd_trg) {
		request->appendUCHARs(blr_end, 3);
	}

	request->blrEnd();

    request->appendNumber(isc_dyn_system_flag, 
                            frb_sysflag_referential_constraint);

	// no trg_source and no trg_description
	request->appendUCHAR(isc_dyn_end);
}


static void define_dimensions( CStatement* request, const dsql_fld* field)
{
/*****************************************
 *
 *	d e f i n e _ d i m e n s i o n s
 *
 *****************************************
 *
 * Function
 *	Define dimensions of an array
 *
 **************************************/

	dsql_nod* elements = field->fld_ranges;
	const USHORT dims = elements->nod_count / 2;

	if (dims > MAX_ARRAY_DIMENSIONS)
		ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -604,
				  isc_arg_gds, isc_dsql_max_arr_dim_exceeded, 0);

	request->appendNumber(isc_dyn_fld_dimensions, (SSHORT) dims);
	SSHORT position = 0;
	dsql_nod** ptr = elements->nod_arg;

	for (dsql_nod** const end = ptr + elements->nod_count; ptr < end; ++position)
		{
		request->appendNumber(isc_dyn_def_dimension, position);
		dsql_nod* element = *ptr++;
		const int lrange = getInt(element);
		request->appendNumber(isc_dyn_dim_lower, lrange);
		
		element = *ptr++;
		const int hrange = getInt(element);
		request->appendNumber(isc_dyn_dim_upper, hrange);
		request->appendUCHAR(isc_dyn_end);

		if (lrange >= hrange)
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -604,
					  isc_arg_gds, isc_dsql_arr_range_error, 0);
		}
}


static void define_domain(CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ d o m a i n
 *
 **************************************
 *
 * Function
 *	Define a domain (global field)
 *
 **************************************/

	dsql_nod* element = request->ddlNode;
	dsql_fld* field = (dsql_fld*) element->nod_arg[e_dom_name];

	request->appendDynString(isc_dyn_def_global_fld, field->fld_name);

	DDL_resolve_intl_type(request, field,
						  (dsql_str*) element->nod_arg[e_dom_collate]);
	put_field(request, field, false);

	// check for a default value

	dsql_nod* node = element->nod_arg[e_dom_default];
	if (node)
	{
		node = PASS1_node(request, node, false);
		request->blrBegin(isc_dyn_fld_default_value);
		GEN_expr(request, node);
		request->blrEnd();

		dsql_str* string = (dsql_str*) element->nod_arg[e_dom_default_source];
		if (string)
		{
			fb_assert(string->str_length <= MAX_USHORT);
			fix_default_source(string);
			request->appendDynString(	isc_dyn_fld_default_source,
									string->str_data,
									string->str_length);
		}
	}

	if (field->fld_ranges)
	{
		define_dimensions(request, field);
	}

	bool	null_flag = false;
	bool	check_flag = false;

	// check for constraints
	node = element->nod_arg[e_dom_constraint];
	if (node)
	{
		dsql_nod** ptr = node->nod_arg;
		const dsql_nod* const* const end_ptr = ptr + node->nod_count;
		for (; ptr < end_ptr; ++ptr)
		{
			if ((*ptr)->nod_type == nod_rel_constraint)
			{
				dsql_nod* node1 = (*ptr)->nod_arg[e_rct_type];
				if (node1->nod_type == nod_null)
				{
					if (!null_flag)
					{
						request->appendUCHAR(isc_dyn_fld_not_null);
						null_flag = true;
					}
					else
					{
						ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -637,
								  isc_arg_gds, isc_dsql_duplicate_spec,
								  isc_arg_string, "NOT NULL", 0);
					}
				}
				else if (node1->nod_type == nod_def_constraint)
				{
					if (check_flag)
					{
						ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -637,
								  isc_arg_gds, isc_dsql_duplicate_spec,
								  isc_arg_string, "DOMAIN CHECK CONSTRAINT",
								  0);
					}
					check_flag = true;

					const dsql_str* string = (dsql_str*) node1->nod_arg[e_cnstr_source];
					if (string)
						{
						fb_assert(string->str_length <= MAX_USHORT);
						request->appendDynString(	isc_dyn_fld_validation_source,
												string->str_data,
												string->str_length);
						}
					request->blrBegin(isc_dyn_fld_validation_blr);

					// Set any VALUE nodes to the type of the domain being defined. 
					if (node1->nod_arg[e_cnstr_condition])
						set_nod_value_attributes(node1->nod_arg[e_cnstr_condition],
												 field);
	

					/* Increment the context level for this request, so
					   that the context number for any RSE generated for a
					   SELECT within the CHECK clause will be greater than
					   0.  In the environment of a domain check
					   constraint, context number 0 is reserved for the
					   "blr_fid, 0, 0, 0," which is emitted for a
					   nod_dom_value, corresponding to an occurance of the
					   VALUE keyword in the bod of the check constraint.
					   -- chrisj 1999-08-20 */

					request->contextNumber++;

					GEN_expr(request,
							 PASS1_node(request,
										node1->nod_arg[e_cnstr_condition],
										false));

					request->blrEnd();
				}
			}
		}
	}

	request->appendUCHAR(isc_dyn_end);
}


static void define_exception(CStatement* request, NOD_TYPE op)
{
/**************************************
 *
 *	d e f i n e _ e x c e p t i o n
 *
 **************************************
 *
 * Function
 *	Generate ddl to create an exception code.
 *
 **************************************/
	const dsql_nod* ddl_node = request->ddlNode;
	const dsql_str* name = (dsql_str*) ddl_node->nod_arg[e_xcp_name];

	if (op == nod_replace_exception) {		
		//if (METD_get_exception(request, name)) {
		if (request->existsException(name->str_data)) {
			define_exception(request, nod_mod_exception);
		}
		else {
			define_exception(request, nod_def_exception);
		}
	}
	else if (op == nod_def_exception || op == nod_redef_exception)
		request->appendDynString(isc_dyn_def_exception, name->str_data);
	else if (op == nod_mod_exception)
		request->appendDynString(isc_dyn_mod_exception, name->str_data);
	else
		fb_assert(false);

	const dsql_str* text = (dsql_str*) ddl_node->nod_arg[e_xcp_text];
	fb_assert(text->str_length <= MAX_USHORT);
	request->appendDynString(isc_dyn_xcp_msg, text->str_data, text->str_length);
	request->appendUCHAR(isc_dyn_end);
}


static void define_field(CStatement* request,
						 dsql_nod* element, SSHORT position,
						 const dsql_str* relation_name)
{
/**************************************
 *
 *	d e f i n e _ f i e l d
 *
 **************************************
 *
 * Function
 *	Define a field, either as part of a create
 *	table or an alter table statement.
 *
 **************************************/
 
	dsql_fld* field = (dsql_fld*) element->nod_arg[e_dfl_field];
	field->fld_flags |= FLD_temporary;
	
	// add the field to the relation being defined for parsing purposes 

	dsql_rel* relation = request->req_relation;
	
	if (relation != NULL) 
		relation->addField(field);
	
	dsql_nod* domain_node = element->nod_arg[e_dfl_domain];

	if (domain_node) 
		{
		request->appendDynString(isc_dyn_def_local_fld, field->fld_name);
		const dsql_nod* node1 = domain_node->nod_arg[e_dom_name];
		dsql_str* domain_name = (dsql_str*) node1->nod_arg[e_fln_name];
		request->appendDynString(isc_dyn_fld_source, domain_name->str_data);

		// Get the domain information 


		//if (!(METD_get_domain(request, field, domain_name->str_data)))
		if (!(request->getDomain (*domain_name, field)))
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_dsql_domain_not_found,
                      isc_arg_string, domain_name->str_data,
					  // Specified domain or source field does not exist 
					  0);

		DDL_resolve_intl_type(	request,
								field,
								reinterpret_cast<dsql_str*>(element->nod_arg[e_dfl_collate]));
		if (element->nod_arg[e_dfl_collate]) 
			request->appendNumber(isc_dyn_fld_collation, field->fld_collation_id);
		}
	else
		{
		request->appendDynString(isc_dyn_def_sql_fld, field->fld_name);
		if (relation_name) 
			request->appendDynString(isc_dyn_rel_name, relation_name->str_data);

		if (element->nod_arg[e_dfl_computed])
			{
			field->fld_flags |= FLD_computed;
			dsql_nod* computed_node = element->nod_arg[e_dfl_computed];
			define_computed(request,
							request->ddlNode->nod_arg[e_drl_name], field,
							computed_node);
			}

		DDL_resolve_intl_type(request, field,
							  reinterpret_cast<dsql_str*>(element->nod_arg[e_dfl_collate]));
		put_field(request, field, false);
		}

	if (position != -1)
		request->appendNumber(isc_dyn_fld_position, position);

	// check for a default value
	
	bool default_null_flag = false;
	dsql_nod* node = element->nod_arg[e_dfl_default];
	
	if (node)
		{
		node = PASS1_node(request, node, false);
		request->blrBegin(isc_dyn_fld_default_value);
		
		if (node->nod_type == nod_null) 
			default_null_flag = true;

		GEN_expr(request, node);
		request->blrEnd();
		dsql_str* string = (dsql_str*) element->nod_arg[e_dfl_default_source];

		if (string)
			{
			fb_assert(string->str_length <= MAX_USHORT);
			fix_default_source(string);
			request->appendDynString(isc_dyn_fld_default_source, string->str_data, string->str_length);
			}
		}

	if (field->fld_ranges) 
		define_dimensions(request, field);

	// check for constraints
	
	bool cnstrt_flag = false;
	
	if (node = element->nod_arg[e_dfl_constraint])
		{
		dsql_nod* const* const end_ptr = node->nod_arg + node->nod_count;
		
		for (dsql_nod** ptr = node->nod_arg; ptr < end_ptr; ++ptr)
			{
			if ((*ptr)->nod_type == nod_rel_constraint)
				{
				const dsql_str* string = (dsql_str*) (*ptr)->nod_arg[e_rct_name];
				dsql_nod* node1 = (*ptr)->nod_arg[e_rct_type];

				if (node1->nod_type == nod_null)
					{
					if (default_null_flag)
						ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204,
								  isc_arg_gds, isc_bad_default_value,
								  isc_arg_gds, isc_invalid_clause,
								  isc_arg_string, "default null not null", 0);

					request->appendUCHAR(isc_dyn_fld_not_null);
					
					if (!cnstrt_flag) 
						{
						request->appendUCHAR(isc_dyn_end);	// For field definition  
						cnstrt_flag = true;
						}
						
					request->appendDynString(isc_dyn_rel_constraint, string ? string->str_data : 0);
					request->appendUCHAR(isc_dyn_fld_not_null);
					request->appendUCHAR(isc_dyn_end);	// For NOT NULL Constraint definition  
					}
				else if (node1->nod_type == nod_primary || node1->nod_type == nod_unique)
					{
					if (!cnstrt_flag)
						{
						request->appendUCHAR(isc_dyn_end);	// For field definition  
						cnstrt_flag = true;
						}

					const char* constraint_name = string ? string->str_data : 0;
					request->appendDynString(isc_dyn_rel_constraint, constraint_name);

					dsql_nod* index = node1->nod_arg[e_pri_index];
					fb_assert(index);
					const char* index_name = constraint_name;
					string = (dsql_str*) index->nod_arg[e_idx_name];
					
					if (string)
						index_name = string->str_data;

					if (node1->nod_type == nod_primary)
						request->appendDynString(isc_dyn_def_primary_key, index_name);
					else if (node1->nod_type == nod_unique)
						request->appendDynString(isc_dyn_def_unique, index_name);

					request->appendNumber(isc_dyn_idx_unique, 1);

					if (index->nod_arg[e_idx_asc_dsc])
						request->appendNumber(isc_dyn_idx_type, 1);

					request->appendDynString(isc_dyn_fld_name, field->fld_name);
					request->appendUCHAR(isc_dyn_end);
					}
				else if (node1->nod_type == nod_foreign) 
					{
					if (!cnstrt_flag) 
						{
						request->appendUCHAR(isc_dyn_end);	// For field definition  
						cnstrt_flag = true;
						}
						
					const char* constraint_name = string ? string->str_data : 0;
					request->appendDynString(isc_dyn_rel_constraint, constraint_name);
					foreign_key(request, node1, constraint_name);
					}
				else if (node1->nod_type == nod_def_constraint) 
					{
					if (!cnstrt_flag) 
						{
						request->appendUCHAR(isc_dyn_end);	// For field definition  
						cnstrt_flag = true;
						}
					request->appendDynString(isc_dyn_rel_constraint, string ? string->str_data : 0);
					check_constraint(request, node1, false); // No delete trigger
					}
				}
			}
		}

	if (!cnstrt_flag) 
		request->appendUCHAR(isc_dyn_end);

/* TODO:AB

	// dimitr:  store the final position of the vector to insert a not null
	//			item later, if required. This is a kind of a hack, but I see
	//			no other way to ensure that NOT NULL is properly understood
	//			everywhere in the column constraint definition.	A better
	//			solution would be a special class which handles all append_*
	//			operations for BLR/DYN (we could store constraints in the
	//			separate object and then merge them into req_blr_data), but
	//			this is for another day.
	const size_t end = request->getBlrLength req_blr_data.getCount();
	request->appendUCHAR(isc_dyn_end);

	// check for constraints
	
	bool not_null_flag = false;
	
	if (node = element->nod_arg[e_dfl_constraint])
		{
		dsql_nod* const* const end_ptr = node->nod_arg + node->nod_count;
		
		for (dsql_nod** ptr = node->nod_arg; ptr < end_ptr; ++ptr)
			{
			if ((*ptr)->nod_type == nod_rel_constraint)
				{
				const dsql_str* string = (dsql_str*) (*ptr)->nod_arg[e_rct_name];
				dsql_nod* node1 = (*ptr)->nod_arg[e_rct_type];

                switch (node1->nod_type) {

					case nod_null:
					case nod_primary:
						if (default_null_flag)
							ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204,
									isc_arg_gds, isc_bad_default_value,
									isc_arg_gds, isc_invalid_clause,
									isc_arg_string, "default null not null", 0);

						if (!not_null_flag)
							{
							request->appendDynString(isc_dyn_rel_constraint, string ? string->str_data : 0);
							request->appendUCHAR(isc_dyn_fld_not_null);
							request->appendUCHAR(isc_dyn_end);	// For NOT NULL Constraint definition  
							not_null_flag = true;
							}

						if (node1->nod_type == nod_null)
							break;
						// nod_primary falls into
					case nod_unique:
					{
						const char* constraint_name = string ? string->str_data : 0;
						request->appendDynString(isc_dyn_rel_constraint, constraint_name);

						dsql_nod* index = node1->nod_arg[e_pri_index];
						fb_assert(index);
						const char* index_name = constraint_name;
						string = (dsql_str*) index->nod_arg[e_idx_name];
						
						if (string)
							index_name = string->str_data;

						if (node1->nod_type == nod_primary)
							request->appendDynString(isc_dyn_def_primary_key, index_name);
						else if (node1->nod_type == nod_unique)
							request->appendDynString(isc_dyn_def_unique, index_name);

						request->appendNumber(isc_dyn_idx_unique, 1);

						if (index->nod_arg[e_idx_asc_dsc])
							request->appendNumber(isc_dyn_idx_type, 1);

						request->appendDynString(isc_dyn_fld_name, field->fld_name);
						request->appendUCHAR(isc_dyn_end);
						break;
					}
				case nod_foreign:
					{
					const char* constraint_name = string ? string->str_data : 0;
					request->appendDynString(isc_dyn_rel_constraint, constraint_name);
					foreign_key(request, node1, constraint_name);
					break;
					}
				case nod_def_constraint:
					request->appendDynString(isc_dyn_rel_constraint, string ? string->str_data : 0);
					check_constraint(request, node1, false); // No delete trigger
					break;				
				}
		}

	if (not_null_flag) 
		request->BlrInsert(end, isc_dyn_fld_not_null);
*/
}


static void define_filter( CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ f i l t e r
 *
 **************************************
 *
 * Function
 *	define a filter to the database.
 *
 **************************************/
	const dsql_nod* filter_node = request->ddlNode;
	dsql_nod* const* ptr = filter_node->nod_arg;
	request->appendDynString(isc_dyn_def_filter,
				((dsql_str*) (ptr[e_filter_name]))->str_data);
	request->appendNumber(isc_dyn_filter_in_subtype, getInt(ptr[e_filter_in_type]));
			   //(SSHORT)(long) ((ptr[e_filter_in_type])->nod_arg[0]));
	request->appendNumber(isc_dyn_filter_out_subtype, getInt(ptr[e_filter_out_type]));
			   //(SSHORT)(long) ((ptr[e_filter_out_type])->nod_arg[0]));
	request->appendDynString(isc_dyn_func_entry_point,
				((dsql_str*) (ptr[e_filter_entry_pt]))->str_data);
	request->appendDynString(isc_dyn_func_module_name,
				((dsql_str*) (ptr[e_filter_module]))->str_data);

	request->appendUCHAR(isc_dyn_end);
}


static void define_generator( CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ g e n e r a t o r
 *
 **************************************
 *
 * Function
 *	create a generator.
 *
 **************************************/

	const dsql_str* gen_name = (dsql_str*) request->ddlNode->nod_arg[e_gen_name];
	request->appendDynString(isc_dyn_def_generator, gen_name->str_data);
	request->appendUCHAR(isc_dyn_end);
}


static void define_index(CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ i n d e x
 *
 **************************************
 *
 * Function
 *	Generate ddl to create an index.
 *
 **************************************/
	request->appendUCHAR(isc_dyn_begin);

	const dsql_nod* ddl_node = request->ddlNode;
	dsql_nod* relation_node = (dsql_nod*) ddl_node->nod_arg[e_idx_table];
	const dsql_str* relation_name = (dsql_str*) relation_node->nod_arg[e_rln_name];
	dsql_nod* field_list = ddl_node->nod_arg[e_idx_fields];
	const dsql_str* index_name = (dsql_str*) ddl_node->nod_arg[e_idx_name];

	request->appendDynString(isc_dyn_def_idx, index_name->str_data);
	request->appendDynString(isc_dyn_rel_name, relation_name->str_data);

/* go through the fields list, making an index segment for each field,
   unless we have a computation, in which case generate an expression index */

	if (field_list->nod_type == nod_list)
	{
	    const dsql_nod* const* ptr = field_list->nod_arg;
	    const dsql_nod* const* const end = ptr + field_list->nod_count;
		for (; ptr < end; ptr++)
			request->appendDynString(isc_dyn_fld_name,
						((dsql_str*) (*ptr)->nod_arg[1])->str_data);
	}
#ifdef EXPRESSION_INDICES
	else if (field_list->nod_type == nod_def_computed)
		define_computed(request, relation_node, NULL, field_list);
#endif

// check for a unique index 

	if (ddl_node->nod_arg[e_idx_unique]) {
		request->appendNumber(isc_dyn_idx_unique, 1);
	}

	if (ddl_node->nod_arg[e_idx_asc_dsc]) {
		request->appendNumber(isc_dyn_idx_type, 1);
	}

	request->appendUCHAR(isc_dyn_end);			// of define index 
	request->appendUCHAR(isc_dyn_end);			// of begin 
}

#ifdef NOT_USED_OR_REPLACED
static dsql_nod* define_insert_action( CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ i n s e r t _ a c t i o n
 *
 **************************************
 *
 * Function
 *	Define an action statement which, given a view
 *	definition, will store a record from
 *	a view of a single relation into the
 *	base relation.
 *
 **************************************/
	dsql_nod* select_node, *select_expr, *from_list;
	dsql_nod* fields_node, *values_node, *field_node;
	dsql_nod **ptr, **end, **ptr2, **end2;
	Stack field_stack;
	Stack value_stack;
	dsql_rel* relation;
	dsql_fld* field;

	dsql_nod* ddl_node = request->ddlNode;

// check whether this is an updatable view definition 

	if ((ddl_node->nod_type != nod_def_view && ddl_node->nod_type != nod_redef_view) ||
		!(select_node = ddl_node->nod_arg[e_view_select]) ||
		/*
		   Handle VIEWS with UNION : nod_select now points to nod_list
		   which in turn points to nod_select_expr
		 */
		!(select_expr = select_node->nod_arg[0]->nod_arg[0]) ||
		!(from_list = select_expr->nod_arg[e_sel_from]) ||
		from_list->nod_count != 1)
		return NULL;

// make up an action node consisting of a list of 1 insert statement 

	dsql_nod* action_node = MAKE_node(request->threadData, nod_list, (int) 1);
	dsql_nod* insert_node = MAKE_node(request->threadData, nod_insert, (int) e_ins_count);
	action_node->nod_arg[0] = insert_node;

// use the relation referenced in the select statement to insert into 

	dsql_nod* relation_node = MAKE_node(request->threadData, nod_relation_name, (int) e_rln_count);
	insert_node->nod_arg[e_ins_relation] = relation_node;
	relation_node->nod_arg[e_rln_name] =
		from_list->nod_arg[0]->nod_arg[e_rln_name];
	relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, TEMP_CONTEXT);

/* get the list of values and fields to assign to -- if there is
   no list of fields, get all fields in the base relation that
   are not computed */

	values_node = ddl_node->nod_arg[e_view_fields];
	fields_node = select_expr->nod_arg[e_sel_list];
	if (!fields_node)
	{
		const dsql_str* rel_name =
			reinterpret_cast<const dsql_str*>(relation_node->nod_arg[e_rln_name]);
		relation = request->findRelation (*rel_name); //METD_get_relation(request, rel_name);

#ifdef SHARED_CACHE
		Sync sync(&relation->syncFields, "define_insert_action");
		sync.lock(Shared);
#endif

		field_stack = NULL;
		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			field_node = MAKE_node(request->threadData, nod_field_name, (int) e_fln_count);
			field_node->nod_arg[e_fln_name] = (dsql_nod*)MAKE_cstring(request->threadData, field->fld_name);
			LLS_PUSH(field_node, &field_stack);
		}
		fields_node = MAKE_list(field_stack);
	}

	if (!values_node)
		values_node = fields_node;

// generate the list of assignments to fields in the base relation 

	ptr = fields_node->nod_arg;
	end = ptr + fields_node->nod_count;
	ptr2 = values_node->nod_arg;
	end2 = ptr2 + values_node->nod_count;
	value_stack = field_stack = NULL;
	for (; (ptr < end) && (ptr2 < end2); ptr++, ptr2++) {
		field_node = *ptr;
		if (field_node->nod_type == nod_alias)
			field_node = field_node->nod_arg[e_alias_value];

		// generate the actual assignment, assigning from a field in the "NEW" context 

		if (field_node->nod_type == nod_field_name) {
			field_node->nod_arg[e_fln_context] =
				(dsql_nod*) MAKE_cstring(request->threadData, TEMP_CONTEXT);
			LLS_PUSH(field_node, &field_stack);

			dsql_nod* value_node = MAKE_node(request->threadData, nod_field_name, (int) e_fln_count);
			value_node->nod_arg[e_fln_name] = (*ptr2)->nod_arg[e_fln_name];
			value_node->nod_arg[e_fln_context] =
				(dsql_nod*) MAKE_cstring(request->threadData, NEW_CONTEXT);
			LLS_PUSH(value_node, &value_stack);
		}
	}

	insert_node->nod_arg[e_ins_values] = MAKE_list(value_stack);
	insert_node->nod_arg[e_ins_fields] = MAKE_list(field_stack);

	return action_node;
}
#endif

static void define_procedure( CStatement* request, NOD_TYPE op)
{
/**************************************
 *
 *	d e f i n e _ p r o c e d u r e
 *
 **************************************
 *
 * Function
 *	Create DYN to store a procedure
 *
 **************************************/
	//TSQL tdsql = GET_THREAD_DATA;

	dsql_nod* procedure_node = request->ddlNode;
	dsql_str* procedure_name = (dsql_str*) procedure_node->nod_arg[e_prc_name];
	const char *procName = procedure_name->str_data; 
	
	switch (op)
		{
		case  nod_replace_procedure:
			if (request->findProcedure (*procedure_name))
				define_procedure(request, nod_mod_procedure);
			else
				define_procedure(request, nod_def_procedure);

			return;

		case nod_def_procedure:
		case nod_redef_procedure:
			request->appendDynString(isc_dyn_def_procedure, procName);
			request->appendNumber(isc_dyn_rel_sql_protection, 1);
			break;

		case nod_mod_procedure:
			{
			request->appendDynString(isc_dyn_mod_procedure, procName);
			Procedure *procedure = request->findProcedure (procName);
			if (procedure)
				delete_parameters (request, procedure);
			break;
			}

		default:
			ERRD_bugcheck ("Unknown code in define procedure");
		}

	new_procedure (request, procedure_name,  procedure_node);
}

//
// Define a constraint, either as part of a create
// table or an alter table statement.
//
static void define_rel_constraint( CStatement* request, dsql_nod* element)
{
	const dsql_str* string           = (dsql_str*) element->nod_arg[e_rct_name];
	const char* constraint_name = string ? string->str_data : 0;

	request->appendDynString(isc_dyn_rel_constraint, constraint_name);

	dsql_nod* node = element->nod_arg[e_rct_type];

	switch(node->nod_type) {
	case nod_unique:
	case nod_primary:
		make_index(request, node, node->nod_arg[0], 0, 0, constraint_name);
		break;
	case nod_foreign:
		foreign_key(request, node, constraint_name);
		break;
	case nod_def_constraint:
		check_constraint(request, node, false); // false = No delete trigger
		break;
	default:   // silence compiler
	    break;
	}
}


static void define_relation( CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ r e l a t i o n
 *
 **************************************
 *
 * Function
 *	Create an SQL table, relying on DYN to generate
 *	global fields for the local fields.
 *
 **************************************/
	dsql_nod* ddl_node = request->ddlNode;

	const dsql_nod* relation_node = ddl_node->nod_arg[e_drl_name];
	dsql_str* relation_name = (dsql_str*) relation_node->nod_arg[e_rln_name];
	request->appendDynString(isc_dyn_def_rel, relation_name->str_data);
	const dsql_str* external_file = (dsql_str*) ddl_node->nod_arg[e_drl_ext_file];

	if (external_file)
		request->appendDynString(isc_dyn_rel_ext_file, external_file->str_data);

	save_relation(request, relation_name);
	request->appendNumber(isc_dyn_rel_sql_protection, 1);

	// now do the actual metadata definition 

	dsql_nod* elements = ddl_node->nod_arg[e_drl_elements];
	SSHORT position = 0;
	dsql_nod** ptr = elements->nod_arg;

	for (const dsql_nod* const* const end = ptr + elements->nod_count; ptr < end; ptr++)
		{
		dsql_nod* element = *ptr;
		
		switch (element->nod_type) 
			{
			case nod_def_field:
				define_field(request, element, position, relation_name);
				++position;
				break;

			case nod_rel_constraint:
				define_rel_constraint(request, element);
				break;

			default:
				break;
			}
		}

	request->appendUCHAR(isc_dyn_end);
}


//
//	Create a SQL role.
//
static void define_role(CStatement* request)
{
	const dsql_str* gen_name = (dsql_str*) request->ddlNode->nod_arg[e_gen_name];
	request->appendDynString(isc_dyn_def_sql_role, gen_name->str_data);
	request->appendUCHAR(isc_dyn_end);
}


static void define_set_null_trg(CStatement*    request,
								const dsql_nod*    element,
								dsql_nod*    for_columns,
								dsql_nod*    prim_columns,
								const char*	prim_rel_name,
								const char*	for_rel_name,
								bool        on_upd_trg)
{
/*****************************************************
 *
 *	d e f i n e _ s e t _ n u l l _ t r g
 *
 *****************************************************
 *
 * Function
 *	define "on delete/update set null" trigger (for referential integrity)
 *      The trigger blr is the same for both the delete and update
 *      cases. Only difference is its TRIGGER_TYPE (ON DELETE or ON UPDATE)
 *      The on_upd_trg parameter == true is an update trigger.
 *
 *****************************************************/

	if (element->nod_type != nod_foreign) {
		return;
	}

	// count of foreign key columns
	fb_assert(prim_columns->nod_count == for_columns->nod_count);
	fb_assert(prim_columns->nod_count != 0);

	/***
	request->generate_unnamed_trigger_beginning(on_upd_trg,
												prim_rel_name,
												prim_columns,
												for_rel_name,
												for_columns);
	***/
	request->genUnnamedTriggerBeginning (on_upd_trg, prim_rel_name, prim_columns, for_rel_name,for_columns);

	USHORT num_fields = 0;
	const dsql_nod* const* for_key_flds = for_columns->nod_arg;

	do {
		const dsql_str* for_key_fld_name_str = (dsql_str*) (*for_key_flds)->nod_arg[1];

		request->appendUCHAR(blr_assignment);
		request->appendUCHAR(blr_null);
		request->appendUCHAR(blr_field);
		request->appendUCHAR(2);
		request->appendBlrString(for_key_fld_name_str->str_data);

		num_fields++;
		for_key_flds++;

	} while (num_fields < for_columns->nod_count);

	request->appendUCHAR(blr_end);

	if (on_upd_trg) {
		request->appendUCHARs(blr_end, 3);
	}
	request->blrEnd();
	// end of the blr

    request->appendNumber(isc_dyn_system_flag, 
                            frb_sysflag_referential_constraint);

	// no trg_source and no trg_description
	request->appendUCHAR(isc_dyn_end);

}


//
// create a shadow for the database
//
static void define_shadow(CStatement* request)
{
	const dsql_nod*  shadow_node = request->ddlNode;
	dsql_nod* const* ptr = shadow_node->nod_arg;

	if (!ptr[e_shadow_number])
		ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
				  isc_arg_gds, isc_dsql_command_err,
				  isc_arg_gds, isc_dsql_shadow_number_err, 0);

	request->appendNumber(isc_dyn_def_shadow, (SSHORT)(long) (ptr[e_shadow_number]));
	request->appendDynString(isc_dyn_def_file, ((dsql_str*) (ptr[e_shadow_name]))->str_data);
	request->appendNumber(isc_dyn_shadow_man_auto, getInt(ptr[e_shadow_man_auto]));
			   //(SSHORT)(long) ((ptr[e_shadow_man_auto])->nod_arg[0]));
	request->appendNumber(isc_dyn_shadow_conditional, getInt(ptr[e_shadow_conditional]));
			   //(SSHORT)(long) ((ptr[e_shadow_conditional])->nod_arg[0]));

	request->appendNumber (isc_dyn_file_start, 0);

	SLONG length = (long) ptr[e_shadow_length];
	request->appendNumber (isc_dyn_file_length, length);

	request->appendUCHAR(isc_dyn_end);
	const dsql_nod* elements = ptr[e_shadow_sec_files];
	
	if (elements)
		{
		ptr = elements->nod_arg;
		
		for (const dsql_nod* const* const end = ptr + elements->nod_count;  ptr < end; ++ptr)
			{
			const dsql_nod* element = *ptr;
			const dsql_fil* file    = (dsql_fil*) element->nod_arg[0];
			request->appendDynString(isc_dyn_def_file, file->fil_name->str_data);

			if (!length && !file->fil_start)
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
						  isc_arg_gds, isc_dsql_command_err,
						  isc_arg_gds, isc_dsql_file_length_err,
						  isc_arg_number, file->fil_name->str_data,
						  // Preceding file did not specify length, so %s must include starting page number 
						  0);

			const SLONG start = file->fil_start;
			request->appendNumber (isc_dyn_file_start, start);
			length = file->fil_length;
			request->appendNumber (isc_dyn_file_length, length);
			request->appendUCHAR(isc_dyn_end);
			}
		}

	request->appendUCHAR(isc_dyn_end);
}


//
// Create the ddl to define or alter a trigger.
//
static void define_trigger( CStatement* request, dsql_nod* node)
{

	// make the "define trigger" node the current request ddl node so
	// that generating of BLR will be appropriate for trigger

	request->ddlNode = node;
	dsql_str* trigger_name = (dsql_str*) node->nod_arg[e_trg_name];
	USHORT trig_type;
	dsql_nod* relation_node = NULL;

	if (node->nod_type == nod_replace_trigger)
		{
		//if (METD_get_trigger_relation(request, trigger_name, &trig_type))
		if (request->getTriggerRelation (*trigger_name, &trig_type))
			node->nod_type = nod_mod_trigger;
		else
			node->nod_type = nod_def_trigger;
		define_trigger(request, node);
		
		return;
		}
	else if (node->nod_type == nod_def_trigger)
		{
		fb_assert(trigger_name->str_length <= MAX_USHORT);
		request->appendDynString(isc_dyn_def_trigger, trigger_name->str_data, trigger_name->str_length);
		relation_node = node->nod_arg[e_trg_table];
		const dsql_str* relation_name = (dsql_str*) relation_node->nod_arg[e_rln_name];
		fb_assert(relation_name->str_length <= MAX_USHORT);
		request->appendDynString(isc_dyn_rel_name, relation_name->str_data, relation_name->str_length);
		request->appendUCHAR(isc_dyn_sql_object);
		}
	else // nod_mod_trigger
		{						
		fb_assert(node->nod_type == nod_mod_trigger);
		fb_assert(trigger_name->str_length <= MAX_USHORT);
		request->appendDynString(isc_dyn_mod_trigger, trigger_name->str_data, trigger_name->str_length);
		
		if (node->nod_arg[e_trg_actions])
			{
			/* Since we will be updating the body of the trigger, we need
			   to know what relation the trigger relates to. */

			const dsql_str* relation_name = request->getTriggerRelation (*trigger_name, &trig_type);
				 //METD_get_trigger_relation(request, trigger_name, &trig_type);
			if (!relation_name)
					ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -204,
							  isc_arg_gds, isc_dsql_trigger_err, isc_arg_gds,
							  isc_random, isc_arg_string,
							  trigger_name->str_data, 0);
			relation_node = FB_NEW_RPT(*request->threadData->tsql_default, e_rln_count) dsql_nod;
			node->nod_arg[e_trg_table] = relation_node;
			relation_node->nod_type = nod_relation_name;
			relation_node->nod_count = e_rln_count;
			// Warning: implicit const cast
			relation_node->nod_arg[e_rln_name] = (dsql_nod*) relation_name;
			}
		}

	const dsql_str* source = (dsql_str*) node->nod_arg[e_trg_source];
	dsql_nod* actions = (node->nod_arg[e_trg_actions]) ?
		node->nod_arg[e_trg_actions]->nod_arg[e_trg_act_body] : NULL;

	if (source && actions) 
		{
		fb_assert(source->str_length <= MAX_USHORT);
		request->appendDynString(isc_dyn_trg_source, source->str_data, source->str_length);
		}

	dsql_nod* constant;
	
	if (constant = node->nod_arg[e_trg_active])
		request->appendNumber(isc_dyn_trg_inactive, getInt(constant));

	if (constant = node->nod_arg[e_trg_position])
		request->appendNumber(isc_dyn_trg_sequence,getInt(constant));

	if (constant = node->nod_arg[e_trg_type]) 
		{
		trig_type = getInt(constant);
		request->appendNumber(isc_dyn_trg_type, trig_type);
		}
	else 
		fb_assert(node->nod_type == nod_mod_trigger);

	if (actions)
		{
		/* create the "OLD" and "NEW" contexts for the trigger --
		   the new one could be a dummy place holder to avoid resolving
		   fields to that context but prevent relations referenced in
		   the trigger actions from referencing the predefined "1" context */

		if (request->contextNumber) 
			reset_context_stack(request);

		dsql_nod* const temp = relation_node->nod_arg[e_rln_alias];
		
		if (hasOldContext(trig_type))
			{
			relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, OLD_CONTEXT);
			PASS1_make_context(request, relation_node);
			}
		else
			request->contextNumber++;

		if (hasNewContext(trig_type))
			{
			relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, NEW_CONTEXT);
			PASS1_make_context(request, relation_node);
			}
		else
			request->contextNumber++;

		relation_node->nod_arg[e_rln_alias] = temp;

		// generate the trigger blr

		request->blrBegin(isc_dyn_trg_blr);
		request->appendUCHAR(blr_begin);
		put_local_variables(request, node->nod_arg[e_trg_actions]->nod_arg[e_trg_act_dcls], 0);
		request->scopeLevel++;
		
		// dimitr: I see no reason to deny EXIT command in triggers,
		//		   hence I've added zero label at the beginning.
		//		   My first suspicion regarding an obvious conflict
		//		   with trigger messages (nod_abort) is wrong,
		//		   although the fact that they use the same BLR code
		//		   is still a potential danger and must be fixed.
		//		   Hopefully, system triggers are never recompiled.
		
		request->appendUCHAR(blr_label);
		request->appendUCHAR(0);
		request->loopLevel = 0;
		request->cursorNumber = 0;
		GEN_statement(request, PASS1_statement(request, actions, true));
		request->scopeLevel--;
		request->appendUCHAR(blr_end);
		request->blrEnd();

		/* the request type may have been set incorrectly when parsing
		   the trigger actions, so reset it to reflect the fact that this
		   is a data definition request; also reset the ddl node */

		request->req_type = REQ_DDL;
		}

	/* const dsql_nod* temp = node->nod_arg[e_trg_messages];	
	if (temp)
		{
		dsql_nod* const* const end = temp->nod_arg + temp->nod_count;
		
		for (dsql_nod* const* ptr = temp->nod_arg; ptr < end; ++ptr)
			{
			dsql_nod*    message = *ptr;
			const SSHORT number  = (SSHORT)(long) message->nod_arg[e_msg_number];
			
			if (message->nod_type == nod_del_trigger_msg)
				{
				request->appendNumber(isc_dyn_delete_trigger_msg, number);
				request->appendUCHAR(isc_dyn_end);
				}
			else
				{
				const dsql_str* message_text = (dsql_str*) message->nod_arg[e_msg_text];
				
				if (message->nod_type == nod_def_trigger_msg) 
					request->appendNumber(isc_dyn_def_trigger_msg, number);
				else 
					request->appendNumber(isc_dyn_mod_trigger_msg, number);

				fb_assert(message_text->str_length <= MAX_USHORT);
				request->appendDynString(	isc_dyn_trg_msg,
										message_text->str_data,
										message_text->str_length);
				request->appendUCHAR(isc_dyn_end);
				}
			}
		}
	*/

	request->appendUCHAR(isc_dyn_end);
}


static void define_udf( CStatement* request)
{
/**************************************
 *
 *	d e f i n e _ u d f
 *
 **************************************
 *
 * Function
 *	define a udf to the database.
 *
 **************************************/
	SSHORT position, blob_position = -1;

	dsql_nod*  udf_node = request->ddlNode;
	dsql_nod*  arguments = udf_node->nod_arg[e_udf_args];
	dsql_nod** ptr = udf_node->nod_arg;
	const char* udf_name = ((dsql_str*) (ptr[e_udf_name]))->str_data;
	const dsql_str* func_entry_point_name = reinterpret_cast<dsql_str*>(ptr[e_udf_entry_pt]);
	const dsql_str* func_module_name      = reinterpret_cast<dsql_str*>(ptr[e_udf_module]);
	request->appendDynString(isc_dyn_def_function, udf_name);
	request->appendDynString(isc_dyn_func_entry_point, func_entry_point_name->str_data);
	request->appendDynString(isc_dyn_func_module_name, func_module_name->str_data);

	dsql_nod** ret_val_ptr = ptr[e_udf_return_value]->nod_arg;

	dsql_fld* field = (dsql_fld*) ret_val_ptr[0];
	if (field) {

        // CVC: This is case of "returns <type> [by value|reference]"
		// Some data types can not be returned as value 

		/* Fix sizeof(ptr)/int agreement error.  SAS S0282984 */
		if (((int)((long)*(SLONG*)(ret_val_ptr[1]->nod_arg)) == FUN_value) &&
			(field->fld_dtype == dtype_text ||
			 field->fld_dtype == dtype_varying ||
			 field->fld_dtype == dtype_cstring ||
			 field->fld_dtype == dtype_blob ||
			 field->fld_dtype == dtype_timestamp))
			{
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
						  isc_arg_gds, isc_dsql_command_err,
						  isc_arg_gds, isc_return_mode_err,
						  // Return mode by value not allowed for this data type 
						  0);
			}

		/* For functions returning a blob, coerce return argument position to
		   be the last parameter. */

		if (field->fld_dtype == dtype_blob)
			{
			blob_position = (arguments) ? arguments->nod_count + 1 : 1;
			
			if (blob_position > MAX_UDF_ARGUMENTS)
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
						  isc_arg_gds, isc_dsql_command_err,
						  isc_arg_gds, isc_extern_func_err,
						  // External functions can not have more than 10 parameters 
						  // Or 9 if the function returns a BLOB 
						  0);

			request->appendNumber(isc_dyn_func_return_argument, blob_position);
			}
		else
			request->appendNumber(isc_dyn_func_return_argument, (SSHORT) 0);

		position = 0;
		}
	else 
		{

        // CVC: This is case of "returns parameter <N>"

		position = getInt(ret_val_ptr[1]); //(SSHORT)(long) (ret_val_ptr[1]->nod_arg[0]);
		
		// Function modifies an argument whose value is the function return value 

		if (!arguments || position > arguments->nod_count || position < 1) 
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
                      isc_arg_gds, isc_dsql_udf_return_pos_err, //gds__extern_func_err, 
                      isc_arg_number, (SLONG) (arguments ? arguments->nod_count : 0),
                      // CVC: We should devise new msg "position should be between 1 and #params";
                      // here it is: dsql_udf_return_pos_err

					  // External functions can not have more than 10 parameters 
					  // Not strictly correct -- return position error 
					  0);

		// We'll verify that SCALAR_ARRAY can't be used as a return type.
		// The support for SCALAR_ARRAY is only for input parameters.
		const dsql_nod* ret_arg = arguments->nod_arg[position - 1];
		const dsql_nod* const* param_node = ret_arg->nod_arg;
		if (param_node[e_udf_param_type]) {
			const SSHORT arg_mechanism = (SSHORT)(IPTR) (param_node[e_udf_param_type]->nod_arg[0]);
			if (arg_mechanism == FUN_scalar_array)
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					isc_arg_gds, isc_random,
					isc_arg_string, "BY SCALAR_ARRAY can't be used as a return parameter",
					0);
		}

		request->appendNumber(isc_dyn_func_return_argument, position);
		position = 1;
		}

	// Now define all the arguments 
	
	if (!position)
		{
		/* CVC: This is case of "returns <type> [by value|reference]" */
		
		if (field->fld_dtype == dtype_blob)
			{
			/* CVC: I need to test returning blobs by descriptor before allowing the
			   change there. For now, I ignore the return type specification. */
			bool free_it = ((SSHORT)(long) ret_val_ptr[1]->nod_arg[0] < 0);
			request->appendNumber(isc_dyn_def_function_arg, blob_position);
			request->appendNumber(isc_dyn_func_mechanism,
					   (SSHORT)(long) ((free_it ? -1 : 1) * FUN_blob_struct));
			/* if we have the free_it set then the blob has
			   to be freed on return */
			}
		else
			{
			request->appendNumber(isc_dyn_def_function_arg, (SSHORT) 0);
			request->appendNumber(isc_dyn_func_mechanism,
					   (SSHORT)(long) (ret_val_ptr[1]->nod_arg[0]));
			}

		request->appendDynString(isc_dyn_function_name, udf_name);
		DDL_resolve_intl_type(request, field, NULL);
		put_field(request, field, true);
		request->appendUCHAR(isc_dyn_end);
		position = 1;
		}

	fb_assert(position == 1);

    /* CVC: This for all params, including the case of "returns parameter <N>" */

	if (arguments)
	{
		ptr = arguments->nod_arg;
		for (dsql_nod* const* const end = ptr + arguments->nod_count;
			 ptr < end; ptr++, position++)
		{
			if (position > MAX_UDF_ARGUMENTS)
			{
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
						  isc_arg_gds, isc_dsql_command_err,
						  isc_arg_gds, isc_extern_func_err,
						  // External functions can not have more than 10 parameters 
						  0);
			}

            /*field = (dsql_fld*) *ptr; */
            dsql_nod** param_node = (*ptr)->nod_arg;
            field = (dsql_fld*) param_node[e_udf_param_field];

			request->appendNumber(isc_dyn_def_function_arg, (SSHORT) position);

            if (param_node[e_udf_param_type]) 
				{
                SSHORT arg_mechanism = getInt(param_node[e_udf_param_type]); //(SSHORT)(long) (param_node[e_udf_param_type]->nod_arg[0]);
				request->appendNumber(isc_dyn_func_mechanism, arg_mechanism);
				}
            else if (field->fld_dtype == dtype_blob) 
				request->appendNumber(isc_dyn_func_mechanism, FUN_blob_struct);
			else 
				request->appendNumber(isc_dyn_func_mechanism, FUN_reference);

			request->appendDynString(isc_dyn_function_name, udf_name);
			DDL_resolve_intl_type(request, field, NULL);
			put_field(request, field, true);
			request->appendUCHAR(isc_dyn_end);
		}
	}

	request->appendUCHAR(isc_dyn_end);
}



static void define_update_action( CStatement* request,
								  dsql_nod** base_and_node, 
								  dsql_nod** base_relation,
								  dsql_nod* items)
{
/* *************************************
 *
 *	d e f i n e _ u p d a t e _ a c t i o n
 *
 **************************************
 *
 * Function
 *	Define an action statement which, given a view
 *	definition, will map an update to a  record from
 *	a view of a single relation into the
 *	base relation.
 *
 **************************************/
	dsql_nod* ddl_node = request->ddlNode;

// check whether this is an updatable view definition 

	dsql_nod* select_node = 0;
	dsql_nod* select_expr = 0;
	dsql_nod* from_list = 0;
	if ((ddl_node->nod_type != nod_def_view && ddl_node->nod_type != nod_redef_view) ||
		!(select_node = ddl_node->nod_arg[e_view_select]) ||
		!(select_expr = select_node->nod_arg[e_sel_query_spec]) ||
		!(from_list = select_expr->nod_arg[e_qry_from]) ||
		from_list->nod_count != 1)
	{
		return;
	}

// use the relation referenced in the select statement for rse

	dsql_nod* relation_node = MAKE_node(request->threadData, nod_relation_name, (int) e_rln_count);
	relation_node->nod_arg[e_rln_name] =
		from_list->nod_arg[0]->nod_arg[e_rln_name];
	relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, TEMP_CONTEXT);
	*base_relation = relation_node;

/* get the list of values and fields to compare to -- if there is
   no list of fields, get all fields in the base relation that
   are not computed */

	dsql_nod* values_node = ddl_node->nod_arg[e_view_fields];
	dsql_nod* fields_node = select_expr->nod_arg[e_qry_list];
	
	if (!fields_node)
		{
		dsql_str* rel_name =
			reinterpret_cast<dsql_str*>(relation_node->nod_arg[e_rln_name]);
		dsql_rel* relation = request->findRelation (*rel_name); //METD_get_relation(request, rel_name);
		//dsql_lls* field_stack = NULL;
		Stack field_stack;

#ifdef SHARED_CACHE
		Sync sync(&relation->syncFields, "define_update_action");
		sync.lock(Shared);
#endif
	
		for (dsql_fld* field = relation->rel_fields; field; field = field->fld_next)
			{
			if (field->fld_flags & FLD_computed)
				continue;
			dsql_nod* field_node = MAKE_node(request->threadData, nod_field_name, (int) e_fln_count);
			field_node->nod_arg[e_fln_name] =
				(dsql_nod*) MAKE_cstring(request->threadData, field->fld_name);
			LLS_PUSH(field_node, &field_stack);
			}
			
		fields_node = MAKE_list(request->threadData, &field_stack);
		}
		
	if (!values_node)
		values_node = fields_node;

// generate the list of assignments to fields in the base relation 

	dsql_nod** ptr = fields_node->nod_arg;
	dsql_nod* const* const end = ptr + fields_node->nod_count;
	dsql_nod** ptr2 = values_node->nod_arg;
	dsql_nod* const* const end2 = ptr2 + values_node->nod_count;
	dsql_nod* and_node = MAKE_node(request->threadData, nod_and, (int) 2);
	int and_arg = 0;
	for (; (ptr < end) && (ptr2 < end2); ptr++, ptr2++) {
		dsql_nod* field_node = *ptr;
		if (field_node->nod_type == nod_alias)
			field_node = field_node->nod_arg[e_alias_value];

		// generate the actual comparisons 

		if (field_node->nod_type == nod_field_name) {
			field_node->nod_arg[e_fln_context] =
				(dsql_nod*) MAKE_cstring(request->threadData, TEMP_CONTEXT);

			// CVC: This code serves no purpose.
			//dsql_nod* value_node = MAKE_node(request->threadData, nod_field_name, (int) e_fln_count);
			//value_node->nod_arg[e_fln_name] = (*ptr2)->nod_arg[e_fln_name];
			//value_node->nod_arg[e_fln_context] =
			//	(dsql_nod*) MAKE_cstring(request->threadData, NEW_CONTEXT);

			dsql_nod* old_value_node = MAKE_node(request->threadData, nod_field_name, (int) e_fln_count);
			old_value_node->nod_arg[e_fln_name] =
				(*ptr2)->nod_arg[e_fln_name];
			old_value_node->nod_arg[e_fln_context] =
				(dsql_nod*) MAKE_cstring(request->threadData, OLD_CONTEXT);
				
			dsql_nod* eql_node = MAKE_node(request->threadData, nod_eql, (int) 2);
			eql_node->nod_arg[0] = old_value_node;
			eql_node->nod_arg[1] = field_node;

			dsql_nod* anull_node = MAKE_node(request->threadData, nod_missing, 1);
			anull_node->nod_arg[0] = old_value_node;
			dsql_nod* bnull_node = MAKE_node(request->threadData, nod_missing, 1);
			bnull_node->nod_arg[0] = field_node;

			dsql_nod* iand_node = MAKE_node(request->threadData, nod_and, (int) 2);
			iand_node->nod_arg[0] = anull_node;
			iand_node->nod_arg[1] = bnull_node;

			dsql_nod* or_node = MAKE_node(request->threadData, nod_or, (int) 2);
			or_node->nod_arg[0] = eql_node;
			or_node->nod_arg[1] = iand_node;

			if (and_arg <= 1)
				and_node->nod_arg[and_arg++] = or_node;
			else {
				dsql_nod* old_and = and_node;
				and_node = MAKE_node(request->threadData, nod_and, (int) 2);
				and_node->nod_arg[0] = old_and;
				and_node->nod_arg[1] = or_node;
			}
		}
	}

	if (and_arg <= 1)
		and_node->nod_arg[and_arg] = 
			replace_field_names(request, select_expr->nod_arg[e_qry_where], 
				items, NULL, false, TEMP_CONTEXT);
	else {
		dsql_nod* old_and = and_node;
		and_node = MAKE_node(request->threadData, nod_and, (int) 2);
		and_node->nod_arg[0] = old_and;
		and_node->nod_arg[1] =
			replace_field_names(request, select_expr->nod_arg[e_qry_where], 
				items, NULL, false, TEMP_CONTEXT);

	}
	*base_and_node = and_node;
}


static void define_upd_cascade_trg(	CStatement*    request,
									const dsql_nod*    element,
									dsql_nod*    for_columns,
									dsql_nod*    prim_columns,
									const char* prim_rel_name,
									const char* for_rel_name)
{
/*****************************************************
 *
 *	d e f i n e _ u p d _ c a s c a d e _ t r g
 *
 *****************************************************
 *
 * Function
 *	define "on update cascade" trigger (for referential integrity)
 *      along with the trigger blr.
 *
 *****************************************************/

	if (element->nod_type != nod_foreign) {
		return;
	}

	// count of foreign key columns
	fb_assert(prim_columns->nod_count == for_columns->nod_count);
	fb_assert(prim_columns->nod_count != 0);

	request->genUnnamedTriggerBeginning(true, prim_rel_name, prim_columns, for_rel_name,for_columns);

	USHORT num_fields = 0;
	const dsql_nod* const*   for_key_flds  = for_columns->nod_arg;
	const dsql_nod* const*   prim_key_flds = prim_columns->nod_arg;

	do {
		const dsql_str* for_key_fld_name_str  = (dsql_str*) (*for_key_flds)->nod_arg[1];
		const dsql_str* prim_key_fld_name_str = (dsql_str*) (*prim_key_flds)->nod_arg[1];

		request->appendUCHAR(blr_assignment);
		request->appendUCHAR(blr_field);
		request->appendUCHAR(1);
		request->appendBlrString(prim_key_fld_name_str->str_data);
		request->appendUCHAR(blr_field);
		request->appendUCHAR(2);
		request->appendBlrString(for_key_fld_name_str->str_data);

		num_fields++;
		prim_key_flds++;
		for_key_flds++;

	} while (num_fields < for_columns->nod_count);

	request->appendUCHARs(blr_end, 4);
	request->blrEnd();
	// end of the blr

    request->appendNumber(isc_dyn_system_flag, 
                           frb_sysflag_referential_constraint);

	// no trg_source and no trg_description
	request->appendUCHAR(isc_dyn_end);

}

static void define_user( CStatement* request, int dynOp)
{
/**************************************
 *
 *	d e f i n e _ u s e r
 *
 **************************************
 *
 * Function
 *	Generate ddl to create an exception code.
 *
 **************************************/
	dsql_nod* ddl_node = request->ddlNode;
	const dsql_str* name = (dsql_str*) ddl_node->nod_arg[e_usr_name];
	request->appendDynString(dynOp, name->str_data);
	dsql_nod *options = ddl_node->nod_arg[e_usr_options];
	
	if (options)
		for (int n = 0; n < options->nod_count; ++n)
			{
			dsql_nod *option = options->nod_arg[n];
			
			switch (option->nod_type)
				{
				case nod_password:
					{
					const dsql_str* password = (dsql_str*) option->nod_arg[0];
					request->appendDynString(isc_dyn_password, password->str_data);
					}
					break;
				}
			}

	request->appendUCHAR(isc_dyn_end);
}




static void define_view( CStatement* request, NOD_TYPE op)
{
/**************************************
 *
 *	d e f i n e _ v i e w
 *
 **************************************
 *
 * Function
 *	Create the ddl to define a view, using a SELECT
 *	statement as the source of the view.
 *
 **************************************/
	dsql_nod* node = request->ddlNode;
	dsql_str* view_name = (dsql_str*) node->nod_arg[e_view_name];

	if (op == nod_replace_view)
	{
		if (request->findRelation (*view_name)) //METD_get_relation(request, view_name))
		{
			define_view(request, nod_mod_view);
		}
		else
		{
			define_view(request, nod_def_view);
		}
		return;
	}
	else if (op == nod_def_view || op == nod_redef_view)
		{
		request->appendDynString(isc_dyn_def_view, view_name->str_data);
		request->appendNumber(isc_dyn_rel_sql_protection, 1);
		save_relation(request, view_name);
		}
	else // op == nod_mod_view
		{
		request->appendDynString(isc_dyn_mod_view,
					view_name->str_data);
		dsql_rel* relation = request->findRelation (*view_name); //METD_get_relation(request, view_name);
		
		if (relation)
			{
#ifdef SHARED_CACHE
			Sync sync(&relation->syncFields, "define_view");
			sync.lock(Shared);
#endif

			for (dsql_fld* field = relation->rel_fields; field; field = field->fld_next)
				{
				request->appendDynString(isc_dyn_delete_local_fld, field->fld_name);
				request->appendUCHAR(isc_dyn_end);
				}
			}
		else
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  /* isc_arg_gds, isc_dsql_command_err,
						 isc_arg_gds, isc_dsql_view_not_found, */
					  isc_arg_gds, 336068783L,
					  isc_arg_string, view_name->str_data,
					  isc_arg_end);
		}

/* compile the SELECT statement into a record selection expression,
   making sure to bump the context number since view contexts start
   at 1 (except for computed fields)  -- note that calling PASS1_rse
   directly rather than PASS1_statement saves the context stack */

	if (request->contextNumber)
		reset_context_stack(request);
		
	request->contextNumber++;
	dsql_nod* select_expr = node->nod_arg[e_view_select];
	dsql_nod* rse = PASS1_rse(request, select_expr, NULL);

	// store the blr and source string for the view definition

	request->blrBegin(isc_dyn_view_blr);
	GEN_expr(request, rse);
	request->blrEnd();

/* Store source for view. gdef -e cannot cope with it.
   We need to add something to rdb$views to indicate source type.
   Source will be for documentation purposes. */

	const dsql_str* source = (dsql_str*) node->nod_arg[e_view_source];
	fb_assert(source->str_length <= MAX_USHORT);
	request->appendDynString(	isc_dyn_view_source,
							source->str_data,
							source->str_length);


	define_view_relations(request, &request->context);
	define_view_relations(request, &request->unionContext);

/* define the view source relations from the request contexts & union contexts
	FOR_STACK (dsql_ctx*, context, &request->context)
		dsql_rel* relation = context->ctx_relation;
		if (relation)
			{
			request->appendDynString(isc_dyn_view_relation, relation->rel_name);
			request->appendNumber(isc_dyn_view_context, context->ctx_context);
			request->appendDynString(isc_dyn_view_context_name,
						context->ctx_alias ? 
							context->ctx_alias : (const char*) relation->rel_name);
			request->appendUCHAR(isc_dyn_end);
			}
	END_FOR*/

/* if there are field names defined for the view, match them in order
   with the items from the SELECT.  Otherwise use all the fields from
   the rse node that was created from the select expression */

    const dsql_nod* const* ptr = NULL;
	const dsql_nod* const* end =  NULL;
	const dsql_nod* view_fields = node->nod_arg[e_view_fields];
	if (view_fields != NULL) {
		ptr = view_fields->nod_arg;
		end = ptr + view_fields->nod_count;
	}

	const TEXT* field_string;
	bool updatable = true;
	SSHORT position = 0;
/* go through the fields list, defining the local fields;
   if an expression is specified rather than a field, define
   a global field for the computed value as well */

	dsql_nod* items = rse->nod_arg[e_rse_items];
	dsql_nod** i_ptr = items->nod_arg;
	for (dsql_nod* const* const i_end = i_ptr + items->nod_count;
		i_ptr < i_end; i_ptr++, position++) 
	{
		dsql_nod* field_node = *i_ptr;

		// check if this is a field or an expression 

		dsql_fld* field = NULL;
		const dsql_ctx* context = NULL;
		if (field_node->nod_type == nod_field) {
			field = (dsql_fld*) field_node->nod_arg[e_fld_field];
			context = (dsql_ctx*) field_node->nod_arg[e_fld_context];
		}
		else
			updatable = false;

		// if this is an expression, check to make sure there is a name specified 

		if (!ptr && !field)
		{
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_specify_field_err,
					  // must specify field name for view select expression 
					  0);
		}

		// determine the proper field name, replacing the default if necessary 

		if (field) {
			field_string = field->fld_name;
		}
		/* CVC: Small modification here to catch any mismatch between number of
				explicit field names in a view and number of fields in the select expression,
				see comment below. This closes Firebird Bug #223059. */
		if (ptr)
		{
			if (ptr < end)
			{
				const dsql_str* field_name = (dsql_str*) (*ptr)->nod_arg[1];
				field_string = (TEXT*) field_name->str_data;
			}
			ptr++;
		}

		/* if not an expression, point to the proper base relation field,
		   else make up an SQL field with generated global field for calculations */

		if (field)
		{
			request->appendDynString(isc_dyn_def_local_fld, field_string);
			request->appendDynString(isc_dyn_fld_base_fld, field->fld_name);
			request->appendNumber(isc_dyn_view_context, context->ctx_context);
		}
		else
		{
			request->appendDynString(isc_dyn_def_sql_fld, field_string);
			MAKE_desc(request->threadData, &field_node->nod_desc, field_node, NULL);
			put_descriptor(request, &field_node->nod_desc);
			request->blrBegin(isc_dyn_fld_computed_blr);
			GEN_expr(request, field_node);
			request->blrEnd();
			request->appendNumber(isc_dyn_view_context, (SSHORT) 0);
		}

		save_field(request, field_string);

		request->appendNumber(isc_dyn_fld_position, position);
		request->appendUCHAR(isc_dyn_end);
	}

    /* CVC: This message was not catching the case when
       #fields<items in select list, see comment above. */

	if (ptr != end)
	{
		ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
				  isc_arg_gds, isc_dsql_command_err,
				  isc_arg_gds, isc_num_field_err,
				  // number of fields does not match select list 
				  0);
	}

	// setup to define triggers for WITH CHECK OPTION

	dsql_nod* check = node->nod_arg[e_view_check];

	if (check)
	{
		if (!updatable)
		{
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_col_name_err,
					  // Only simple column names permitted for VIEW WITH CHECK OPTION 
					  0);
		}

		select_expr = select_expr->nod_arg[e_sel_query_spec];

		if (select_expr->nod_type == nod_list)
		{
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_table_view_err,
					  // Only one table allowed for VIEW WITH CHECK OPTION 
					  0);
		}

		if (select_expr->nod_arg[e_qry_from]->nod_count != 1)
		{
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_table_view_err,
					  // Only one table allowed for VIEW WITH CHECK OPTION 
					  0);
		}

		if (!(select_expr->nod_arg[e_qry_where]))
		{
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_where_err,
					  // No where clause for VIEW WITH CHECK OPTION 
					  0);
		}

		if (select_expr->nod_arg[e_qry_distinct] ||
			select_expr->nod_arg[e_qry_group] ||
			select_expr->nod_arg[e_qry_having])
		{
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
						  isc_arg_gds, isc_dsql_command_err,
						  isc_arg_gds, isc_distinct_err,
						  // DISTINCT, GROUP or HAVING not permitted for VIEW WITH CHECK OPTION 
						  0);
		}

		dsql_nod* relation_node = MAKE_node(request->threadData, nod_relation_name, e_rln_count);
		// Warning: implicit const_cast
		relation_node->nod_arg[e_rln_name] = (dsql_nod*) view_name;
		check->nod_arg[e_cnstr_table] = relation_node;

		check->nod_arg[e_cnstr_source] = (dsql_nod*) source;

		/* the condition for the trigger is the converse of the selection
		   criteria for the view, suitably fixed up so that the fields in
		   the view are referenced */

		check->nod_arg[e_cnstr_condition] = select_expr->nod_arg[e_qry_where];

		// Define the triggers   

		create_view_triggers(request, check, rse->nod_arg[e_rse_items]);
	}

	request->appendUCHAR(isc_dyn_end);
	reset_context_stack(request);
}


static void define_view_relations(CStatement* request, Stack* stack)
{								// The fields in VIEW actually  
/**************************************
 *
 *	d e f i n e _ v i e w _ r e l a t i o n s
 *
 **************************************
 *
 * Function
 *	define the view source relations from the request contexts.
 *
 **************************************/

	FOR_STACK (dsql_ctx*, context, stack)
		dsql_rel* relation = context->ctx_relation;
		if (relation)
			{
			request->appendDynString(isc_dyn_view_relation, relation->rel_name);
			request->appendNumber(isc_dyn_view_context, context->ctx_context);
			request->appendDynString(isc_dyn_view_context_name,
						context->ctx_alias ? 
							context->ctx_alias : (const char*) relation->rel_name);
			request->appendUCHAR(isc_dyn_end);
			}
		else if (!context->ctx_procedure && context->ctx_rse)
			{
				// Derived table
				define_view_relations(request, &context->ctx_childs_derived_table);
			}
	END_FOR

}


static void define_view_trigger( CStatement* request, dsql_nod* node, dsql_nod* rse,
	dsql_nod* items)
{								// The fields in VIEW actually  
/**************************************
 *
 *	d e f i n e _ v i e w _ t r i g g e r
 *
 **************************************
 *
 * Function
 *	Create the ddl to define a trigger for a VIEW WITH CHECK OPTION.
 *
 **************************************/
	//TSQL tdsql = GET_THREAD_DATA;

	dsql_nod* ddl_node = request->ddlNode;

	dsql_nod* select_expr = ddl_node->nod_arg[e_view_select];
	select_expr = select_expr->nod_arg[e_sel_query_spec];
	dsql_nod* view_fields = ddl_node->nod_arg[e_view_fields];

/* make the "define trigger" node the current request ddl node so
   that generating of BLR will be appropriate for trigger */

	request->ddlNode = node;

	const dsql_str* trigger_name = (dsql_str*) node->nod_arg[e_cnstr_name];
	dsql_nod* relation_node = NULL;

	if (node->nod_type == nod_def_constraint)
	{
		fb_assert(trigger_name->str_length <= MAX_USHORT);
		request->appendDynString(	isc_dyn_def_trigger,
								trigger_name->str_data,
								trigger_name->str_length);
		relation_node = node->nod_arg[e_cnstr_table];
		const dsql_str* relation_name = (dsql_str*) relation_node->nod_arg[e_rln_name];
		fb_assert(relation_name->str_length <= MAX_USHORT);
		request->appendDynString(	isc_dyn_rel_name,
								relation_name->str_data,
								relation_name->str_length);
	}
	else
	{
		return;
	}

	dsql_nod* constant = node->nod_arg[e_cnstr_position];
	
	if (constant)
		request->appendNumber(isc_dyn_trg_sequence, (constant) ? getInt(constant) : 0);

	constant = node->nod_arg[e_cnstr_type];
	USHORT trig_type;
	
	if (constant)
		{
		trig_type = getInt(constant);
		request->appendNumber(isc_dyn_trg_type, trig_type);
		}
	else
		{
		/* If we don't have a trigger type assigned, then this is just a template
		   definition for use with domains.  The real triggers are defined when
		   the domain is used. */
		trig_type = 0;
		}

	request->appendUCHAR(isc_dyn_sql_object);
	const dsql_str* message = (dsql_str*) node->nod_arg[e_cnstr_message];
	
	if (message)
		{
		request->appendNumber(isc_dyn_def_trigger_msg, 0);
		fb_assert(message->str_length <= MAX_USHORT);
		request->appendDynString(isc_dyn_trg_msg, message->str_data, message->str_length);
		request->appendUCHAR(isc_dyn_end);
		}

	// generate the trigger blr

	if (node->nod_arg[e_cnstr_condition] && node->nod_arg[e_cnstr_actions])
		{
		request->blrBegin(isc_dyn_trg_blr);
		request->appendUCHAR(blr_begin);

		/* create the "OLD" and "NEW" contexts for the trigger --
		   the new one could be a dummy place holder to avoid resolving
		   fields to that context but prevent relations referenced in
		   the trigger actions from referencing the predefined "1" context */

		dsql_ctx* sav_context = 0;
		dsql_ctx* context = 0;
		
		if (request->contextNumber) 
			{
			/* If an alias is specified for the single base table involved,
			   save and then add the context                               */

			//dsql_lls* stack = request->context;
			//context = (dsql_ctx*) stack->lls_object;
			context = (dsql_ctx*) request->context.peek();
			
			if (context->ctx_alias) 
				{
				sav_context = FB_NEW(*request->threadData->tsql_default) dsql_ctx;
				*sav_context = *context;
				}
			}
			
		reset_context_stack(request);
		dsql_nod* temp_alias = relation_node->nod_arg[e_rln_alias];
		relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, OLD_CONTEXT);
		PASS1_make_context(request, relation_node);
		relation_node->nod_arg[e_rln_alias] = (dsql_nod*) MAKE_cstring(request->threadData, NEW_CONTEXT);
		PASS1_make_context(request, relation_node);
		relation_node->nod_arg[e_rln_alias] = temp_alias;

		if (sav_context) 
			{
			sav_context->ctx_context = request->contextNumber++;
			context->ctx_scope_level = request->scopeLevel;
			//LLS_PUSH(sav_context, &request->context);
			request->context.push (sav_context);
			}

		if (trig_type == PRE_MODIFY_TRIGGER) {
			request->appendUCHAR(blr_for);
			dsql_nod* temp = rse->nod_arg[e_rse_streams];
			temp->nod_arg[0] = PASS1_node(request, temp->nod_arg[0], false);
			temp = rse->nod_arg[e_rse_boolean];
			rse->nod_arg[e_rse_boolean] = PASS1_node(request, temp, false);
			GEN_expr(request, rse);

			dsql_nod* condition = MAKE_node(request->threadData, nod_not, 1);
			condition->nod_arg[0] =
				replace_field_names(request, select_expr->nod_arg[e_qry_where], items,
									view_fields, false, NEW_CONTEXT);
			request->appendUCHAR(blr_begin);
			request->appendUCHAR(blr_if);
			GEN_expr(request, PASS1_node(request, condition->nod_arg[0], false));
			request->appendUCHAR(blr_begin);
			request->appendUCHAR(blr_end);
		}

		if (trig_type == PRE_STORE_TRIGGER) {
			dsql_nod* condition = MAKE_node(request->threadData, nod_not, 1);
			condition->nod_arg[0] =
				replace_field_names(request, select_expr->nod_arg[e_qry_where], items,
									view_fields, true, NEW_CONTEXT);
			request->appendUCHAR(blr_if);
			GEN_expr(request, PASS1_node(request, condition->nod_arg[0], false));
			request->appendUCHAR(blr_begin);
			request->appendUCHAR(blr_end);
		}

		// generate the action statements for the trigger 

		dsql_nod* actions = node->nod_arg[e_cnstr_actions];
		dsql_nod** ptr = actions->nod_arg;
		for (const dsql_nod* const* const end = ptr + actions->nod_count;
			 ptr < end; ptr++)
		{
			GEN_statement(request, PASS1_statement(request, *ptr, false));
		}

		// generate the action statements for the trigger

		actions = node->nod_arg[e_cnstr_else];
		if (actions)
		{
			request->appendUCHAR(blr_begin);
			dsql_nod** ptr2 = actions->nod_arg;
			for (const dsql_nod* const* const end2 = ptr2 + actions->nod_count;
				 ptr2 < end2; ptr++)
			{
				dsql_nod* action_node = PASS1_statement(request, *ptr2, false);
				if (action_node->nod_type == nod_modify)
				{
					dsql_nod* temp_rse = action_node->nod_arg[e_mod_rse];
					temp_rse->nod_arg[e_rse_first] =
						MAKE_constant(request->threadData, (dsql_str*) 1, CONSTANT_SLONG);
				}
				GEN_statement(request, action_node);
			}
			request->appendUCHAR(blr_end);		// of begin 
		}

		request->appendUCHAR(blr_end);			// of if 
		if (trig_type == PRE_MODIFY_TRIGGER) {
			request->appendUCHAR(blr_end);		// of for  
		}
		request->blrEnd();
	}
    request->appendNumber(isc_dyn_system_flag, frb_sysflag_view_check);
	request->appendUCHAR(isc_dyn_end);

/* the request type may have been set incorrectly when parsing
   the trigger actions, so reset it to reflect the fact that this
   is a data definition request; also reset the ddl node */

	request->req_type = REQ_DDL;
	request->ddlNode = ddl_node;
	reset_context_stack(request);
}

//
// clean out parameters for a procedure that's on the way out.
//
static void delete_parameters (CStatement *request, Procedure *procedure)
{
	ProcParam* param;
		
	for (param = procedure->findInputParameters(); param; param = param->findNext())
		{
		request->appendDynString(isc_dyn_delete_parameter,
					(const TEXT*) param->fld_name);
		request->appendUCHAR(isc_dyn_end);
		}
		
	for (param = procedure->findOutputParameters(); param; param = param->findNext())
		{
		request->appendDynString(isc_dyn_delete_parameter,
					(const TEXT*) param->fld_name);
		request->appendUCHAR(isc_dyn_end);
		}

}


static void delete_exception (CStatement* request,
                              dsql_nod* node,
                              bool silent_deletion)
{
/**************************************
 *
 *	d e l e t e _ e x c e p t i o n
 *
 **************************************
 *
 * Function
 *  Do nothing and don't throw error if the exception doesn't exist
 *  and silent_deletion is true.
 *
 **************************************/
    const dsql_str* name = (dsql_str*) node->nod_arg[e_xcp_name];
    fb_assert(name);
    if (node->nod_type == nod_redef_exception || silent_deletion) {
        //if (!METD_get_exception(request, string)) {
		if (!request->existsException(name->str_data))
			return;
    }

	request->appendDynString(isc_dyn_del_exception, name->str_data);
	request->appendUCHAR(isc_dyn_end);
}


static void delete_procedure (CStatement*     request,
                              dsql_nod*     node,
                              bool silent_deletion)
{
/**************************************
 *
 *  d e l e t e _ p r o c e d u r e
 *
 **************************************
 *
 * Function
 *  Do nothing and don't throw error if the procedure doesn't exist
 *  and silent_deletion is true.
 *  CVC: Created this function to not clutter generate_dyn().
 *
 **************************************/
    dsql_str* string = (dsql_str*) node->nod_arg[e_prc_name];
    fb_assert (string);

    if (node->nod_type == nod_redef_procedure || silent_deletion)
		{
        Procedure* procedure = request->findProcedure (*string);
        if (!procedure)
            return;
		}

    request->appendDynString(isc_dyn_delete_procedure, string->str_data);
    request->appendUCHAR(isc_dyn_end);

}


static void delete_relation_view (
    CStatement*     request,
    dsql_nod*     node,
    bool silent_deletion)
{
/**************************************
 *
 *  d e l e t e _ r e l a t i o n _ v i e w
 *
 **************************************
 *
 * Function
 *  Check that DROP TABLE is dropping a table and that
 *  DROP VIEW is dropping a view.
 *  Do nothing and don't throw error if the table or view doesn't exist
 *  and silent_deletion is true.
 *  CVC: Created this function to not clutter generate_dyn().
 *
 **************************************/
	dsql_str* string = 0;

    if (node->nod_type == nod_redef_relation) 
		{
        dsql_nod* relation_node = node->nod_arg[e_alt_name];
        fb_assert (relation_node);
        string = (dsql_str*) relation_node->nod_arg[e_rln_name];
		}
    else
        string = (dsql_str*) node->nod_arg[e_alt_name];

    fb_assert (string);

    const dsql_rel* relation = request->findRelation (*string); //METD_get_relation (request, string);

    if (node->nod_type == nod_del_relation || node->nod_type == nod_redef_relation)
		{
        if (!relation && !silent_deletion || relation && (relation->rel_flags & REL_view))
            ERRD_post (isc_sqlerr, isc_arg_number, (SLONG) -607,
                       /* isc_arg_gds, isc_dsql_command_err,
                          isc_arg_gds, isc_dsql_table_not_found, */
                       isc_arg_gds, 336068783L,
                       isc_arg_string, string->str_data,
                       isc_arg_end);
		}
    else { /* node->nod_type == nod_del_view, nod_redef_view */
        if (!relation && !silent_deletion ||
			relation && !(relation->rel_flags & REL_view)) {
            ERRD_post (isc_sqlerr, isc_arg_number, (SLONG) -607,
                       /* isc_arg_gds, isc_dsql_command_err,
                          isc_arg_gds, isc_dsql_view_not_found, */
                       isc_arg_gds, 336068783L,
                       isc_arg_string, string->str_data,
                       isc_arg_end);
        }
    }
    if (relation) {
        request->appendDynString(isc_dyn_delete_rel, string->str_data);
        request->appendUCHAR(isc_dyn_end);
    }
}


/**

 	fix_default_source

    @brief Get rid of newlines between DEFAULT and the value.

    @param string the source text to be fixed if necessary.

 **/
static void fix_default_source(dsql_str* string)
{
	// CVC: I know this is not very brilliant, but some people are annoyed
	// at this for years.
	// We assume the first position is used by "default"
#ifdef DEV_BUILD
	// Verify that assumption about "default"
	const char* token = "default\0DEFAULT";
	for (int t = 0; t < 7; ++t)
	{
		const char c = string->str_data[t];
		if (c != token[t] && c != token[t + 8])
			return; // something is screwed, skip town.
	}
#endif

	for (int i = 7; i < string->str_length; ++i)
	{
		switch (string->str_data[i])
		{
		case ' ':
		case '\n':
		case '\r':
		case '\t':
			string->str_data[i] = ' ';
			break;
		default:
			i = string->str_length - 1;
		}
	}
}


static void foreign_key( CStatement* request, dsql_nod* element, const char* index_name)
{
/* *************************************
 *
 *	f o r e i g n _ k e y
 *
 **************************************
 *
 * Function
 *	Generate ddl to create a foreign key
 *	constraint.
 *
 **************************************/
	dsql_nod* columns1 = element->nod_arg[e_for_columns];

	dsql_nod* relation2_node = element->nod_arg[e_for_reftable];
	dsql_str* relation2 = (dsql_str*) relation2_node->nod_arg[e_rln_name];

	/* If there is a referenced table name but no referenced field names, the
	   primary key of the referenced table designates the referenced fields. */

	dsql_nod* columns2 = element->nod_arg[e_for_refcolumns];

	if (!columns2)
		{
		element->nod_arg[e_for_refcolumns] = columns2 = request->getPrimaryKey (*relation2);
		//METD_get_primary_key(request, relation2);

		if (!columns2)
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) - 204, isc_arg_gds,
						isc_dsql_relation_err, isc_arg_gds, isc_random,
						isc_arg_string, relation2->str_data, 
						//isc_arg_gds,  isc_random, isc_arg_string, linecol, 
						isc_arg_end);
						
		/* If there is NEITHER an explicitly referenced field name, NOR does
		   the referenced table have a primary key to serve as the implicitly
		   referenced field, fail. */
		   
		if (!columns2)
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_reftable_requires_pk,
					  /* "REFERENCES table" without "(column)" requires PRIMARY
					     KEY on referenced table */
					  0);
		}

	if (columns2 && (columns1->nod_count != columns2->nod_count))
		ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
				  isc_arg_gds, isc_dsql_command_err,
				  isc_arg_gds, isc_key_field_count_err,
				  // foreign key field count does not match primary key 
				  0);

	/* define the foreign key index and the triggers that may be needed
	   for referential integrity action. */

	make_index_trg_ref_int(request, element, columns1,
						   element->nod_arg[e_for_refcolumns],
						   relation2->str_data,
						   index_name);
}


static void generate_dyn( CStatement* request, dsql_nod* node)
{
/**************************************
 *
 *	g e n e r a t e _ d y n
 *
 **************************************
 *
 * Functional description
 *	Switch off the type of node to generate a
 *	DYN string.
 *
 **************************************/
	const dsql_str* string;

	request->ddlNode = node;

	switch (node->nod_type) 
		{
		case nod_def_domain:
			define_domain(request);
			break;

		case nod_mod_domain:
			modify_domain(request);
			break;

		case nod_def_index:
			define_index(request);
			break;

		case nod_def_relation:
			define_relation(request);
			break;

		case nod_redef_relation:
			stuff(request, isc_dyn_begin);
			delete_relation_view(request, node, true); // silent.
			define_relation (request);
			stuff(request, isc_dyn_end);
			break;

		case nod_def_view:
		case nod_mod_view:
		case nod_replace_view:
			define_view(request, node->nod_type);
			break;

		case nod_redef_view:
			stuff(request, isc_dyn_begin);
			delete_relation_view(request, node, true); // silent.
			define_view(request, node->nod_type);
			stuff(request, isc_dyn_end);
			break;

		case nod_def_exception:
		case nod_mod_exception:
		case nod_replace_exception:
			define_exception(request, node->nod_type);
			break;

		case nod_redef_exception:
			stuff(request, isc_dyn_begin);
			delete_exception(request, node, true);	// silent
			define_exception(request, node->nod_type);
			stuff(request, isc_dyn_end);
			break;

		case nod_del_exception:
			delete_exception(request, node, false);	// no silent
			break;

		case nod_def_user:
			define_user(request, isc_dyn_def_user);
			break;
			
		case nod_mod_user:
			define_user(request, isc_dyn_mod_user);
			break;
			
		case nod_del_user:
			define_user(request, isc_dyn_del_user);
			break;
			
		case nod_upg_user:
			define_user(request, isc_dyn_def_user);
			break;

		case nod_def_procedure:
		case nod_mod_procedure:
		case nod_replace_procedure:
			define_procedure(request, node->nod_type);
			break;

		case nod_redef_procedure:
			stuff(request, isc_dyn_begin);
			delete_procedure(request, node, true); // silent.
			define_procedure(request, node->nod_type);
			stuff(request, isc_dyn_end);
			break;


		case nod_def_constraint:
			define_constraint_trigger(request, node);
			break;

		case nod_def_trigger:
		case nod_mod_trigger:
		case nod_replace_trigger:
			define_trigger(request, node);
			break;

		case nod_mod_relation:
			modify_relation(request);
			break;

		case nod_del_domain:
			string = (dsql_str*) node->nod_arg[0];
			request->appendDynString(isc_dyn_delete_global_fld, string->str_data);
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_del_index:
			string = (dsql_str*) node->nod_arg[0];
			request->appendDynString(isc_dyn_delete_idx, string->str_data);
			request->appendUCHAR(isc_dyn_end);
			break;

		// CVC: Handling drop table and drop view properly. 
		case nod_del_relation:
		case nod_del_view:
			delete_relation_view (request, node, false); // no silent. 
			break;

		case nod_del_procedure:
			delete_procedure(request, node, false); // no silent.         
			break;

		case nod_del_trigger:
			string = (dsql_str*) node->nod_arg[0];
			request->appendDynString(isc_dyn_delete_trigger, string->str_data);
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_del_role:
			string = (dsql_str*) node->nod_arg[0];
			request->appendDynString(isc_dyn_del_sql_role, string->str_data);
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_grant:
		case nod_revoke:
			grant_revoke(request);
			break;

		case nod_def_generator:
			define_generator(request);
			break;

		case nod_def_role:
			define_role(request);
			break;

		case nod_def_filter:
			define_filter(request);
			break;

		case nod_del_generator:
			string = (dsql_str*) node->nod_arg[0];
			request->appendDynString(isc_dyn_delete_generator, string->str_data);
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_del_filter:
			string = (dsql_str*) node->nod_arg[0];
			request->appendDynString(isc_dyn_delete_filter, string->str_data);
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_def_udf:
			define_udf(request);
			break;

		case nod_del_udf:
			string = (dsql_str*) node->nod_arg[0];
			request->appendDynString(isc_dyn_delete_function, string->str_data);
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_def_shadow:
			define_shadow(request);
			break;

		case nod_del_shadow:
			request->appendNumber(isc_dyn_delete_shadow, getInt(node));
					//(SSHORT)(long) (node->nod_arg[0]));
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_mod_database:
			modify_database(request);
			break;

		case nod_def_database:
			define_database(request);
			break;

		case nod_mod_index:
			modify_index(request);
			break;

		case nod_set_statistics:
			set_statistics(request);
			break;

		default:
			break;
		}
}


static void grant_revoke( CStatement* request)
{
/**************************************
 *
 *	g r a n t _ r e v o k e
 *
 **************************************
 *
 * Functional description
 *	Build DYN string for GRANT/REVOKE statements
 *
 **************************************/

	dsql_nod** uptr;
	dsql_nod** uend;

	SSHORT option = 0; // no grant/admin option
	dsql_nod*    ddl_node = request->ddlNode;
	dsql_nod*    privs    = ddl_node->nod_arg[e_grant_privs];

    bool process_grant_role = false;
	if (privs->nod_arg[0] != NULL) {
		if (privs->nod_arg[0]->nod_type == nod_role_name) {
			process_grant_role = true;
		}
	}

	if (!process_grant_role)
	{
		dsql_nod* table = ddl_node->nod_arg[e_grant_table];
		dsql_nod* users = ddl_node->nod_arg[e_grant_users];
		if (ddl_node->nod_arg[e_grant_grant]) {
			option = 1; // with grant option
		}

		request->appendUCHAR(isc_dyn_begin);

		uend = users->nod_arg + users->nod_count;
		for (uptr = users->nod_arg; uptr < uend; ++uptr)
		{
			modify_privileges(	request,
								ddl_node->nod_type,
								option,
								privs,
								table,
								*uptr);
		}
	}
	else
	{
		dsql_nod* role_list = ddl_node->nod_arg[0];
		dsql_nod* users = ddl_node->nod_arg[1];
		if (ddl_node->nod_arg[3]) {
			option = 2; // with admin option
		}
		request->appendUCHAR(isc_dyn_begin);

		dsql_nod** role_end = role_list->nod_arg + role_list->nod_count;
		for (dsql_nod** role_ptr = role_list->nod_arg; role_ptr < role_end; ++role_ptr)
		{
			uend = users->nod_arg + users->nod_count;
			for (uptr = users->nod_arg; uptr < uend; ++uptr)
			{
				process_role_nm_list(	request,
										option,
										*uptr,
										*role_ptr,
										ddl_node->nod_type);
			}
		}
	}

	request->appendUCHAR(isc_dyn_end);
}


static void make_index(	CStatement*    request,
						const dsql_nod*    element,
						const dsql_nod*    columns,
						const dsql_nod*    referenced_columns, // unused
						const char* relation_name,
						const char* index_name)
{
/* *************************************
 *
 *	m a k e _ i n d e x
 *
 **************************************
 *
 * Function
 *	Generate ddl to create an index for a unique
 *	or primary key constraint.
 *      This is not called for a foreign key constraint.
 *      The func. make_index_trf_ref_int handles foreign key constraint
 *
 **************************************/

	/* stuff either user-defined name or
	   zero-length name, indicating that an index name
	   should be generated */

	fb_assert(element->nod_type != nod_foreign);

	const dsql_nod* index = element->nod_arg[e_pri_index];
	fb_assert(index);

	const dsql_str* string = (dsql_str*) index->nod_arg[e_idx_name];
	if (string)
	{
		index_name = string->str_data;
	}

	if (element->nod_type == nod_primary)
	{
		request->appendDynString(isc_dyn_def_primary_key, index_name);
	}
	else if (element->nod_type == nod_unique)
	{
		request->appendDynString(isc_dyn_def_unique, index_name);
	}

	request->appendNumber(isc_dyn_idx_unique, 1);

	if (index->nod_arg[e_idx_asc_dsc])
	{
		request->appendNumber(isc_dyn_idx_type, 1);
	}

	dsql_nod* const* const end = columns->nod_arg + columns->nod_count;
	for (dsql_nod* const* ptr = columns->nod_arg; ptr < end; ++ptr)
	{
		const dsql_str* field_name = (dsql_str*) (*ptr)->nod_arg[1];
		request->appendDynString(isc_dyn_fld_name, field_name->str_data);
	}

	request->appendUCHAR(isc_dyn_end);
}


static void make_index_trg_ref_int(	CStatement*    request,
									dsql_nod*    element,
									dsql_nod*    columns,
									dsql_nod*    referenced_columns,
									const char*	relation_name,
									const char* index_name)
{
/******************************************************
 *
 *	m a k e _ i n d e x _ t r g _ r e f _ i n t
 *
 ******************************************************
 *
 * Function
 *      This is called only when the element->nod_type == nod_foreign_key
 *
 *     o Generate ddl to create an index for a unique
 *       or primary key constraint.
 *     o Also make an index for the foreign key constraint
 *     o in the caase of foreign key, also generate an appropriate trigger for
 *       cascading referential integrity.
 *
 *
 *****************************************************/

	fb_assert(element->nod_type == nod_foreign)

	/* for_rel_name_str is the name of the relation
	   on which the ddl operation is being done,
	   in this case the foreign key table  */

	dsql_nod* ddl_node         = request->ddlNode;
	dsql_nod* for_rel_node     = ddl_node->nod_arg[e_drl_name];
	const dsql_str* for_rel_name_str = (dsql_str*) for_rel_node->nod_arg[e_rln_name];

	/* stuff either user-defined name or
	   zero-length name, indicating that an index name
	   should be generated */

	dsql_nod* index = element->nod_arg[e_for_index];
	fb_assert(index);

	const dsql_str* string = (dsql_str*) index->nod_arg[e_idx_name];
	if (string)
	{
		index_name = string->str_data;
	}

	request->appendDynString(isc_dyn_def_foreign_key, index_name);

	if (index->nod_arg[e_idx_asc_dsc])
	{
		request->appendNumber(isc_dyn_idx_type, 1);
	}

	if (element->nod_arg[e_for_action])
	{
		dsql_nod* nod_for_action = element->nod_arg[e_for_action];
		fb_assert(nod_for_action->nod_type == nod_ref_upd_del);

		dsql_nod* nod_ref_upd_action = nod_for_action->nod_arg[e_ref_upd];
		if (nod_ref_upd_action)
		{
			fb_assert(nod_ref_upd_action->nod_type == nod_ref_trig_action);

			request->appendUCHAR(isc_dyn_foreign_key_update);
			switch (nod_ref_upd_action->nod_flags)
			{
			case REF_ACTION_CASCADE:
				request->appendUCHAR(isc_dyn_foreign_key_cascade);
				define_upd_cascade_trg(request, element, columns,
									   referenced_columns, relation_name,
									   for_rel_name_str->str_data);
				break;
			case REF_ACTION_SET_DEFAULT:
				request->appendUCHAR(isc_dyn_foreign_key_default);
				define_set_default_trg(request, element, columns,
									   referenced_columns, relation_name,
									   for_rel_name_str->str_data,
									   true);
				break;
			case REF_ACTION_SET_NULL:
				request->appendUCHAR(isc_dyn_foreign_key_null);
				define_set_null_trg(request, element, columns,
									referenced_columns, relation_name,
									for_rel_name_str->str_data,
									true);
				break;
			case REF_ACTION_NONE:
				request->appendUCHAR(isc_dyn_foreign_key_none);
				break;
			default:
				fb_assert(0);
				request->appendUCHAR(isc_dyn_foreign_key_none);	// just in case 
				break;
			}
		}

		dsql_nod* nod_ref_del_action = nod_for_action->nod_arg[e_ref_del];
		if (nod_ref_del_action)
		{
			fb_assert(nod_ref_del_action->nod_type == nod_ref_trig_action);

			request->appendUCHAR(isc_dyn_foreign_key_delete);
			switch (nod_ref_del_action->nod_flags) {
			case REF_ACTION_CASCADE:
				request->appendUCHAR(isc_dyn_foreign_key_cascade);
				define_del_cascade_trg(request, element, columns,
									   referenced_columns, relation_name,
									   for_rel_name_str->str_data);
				break;
			case REF_ACTION_SET_DEFAULT:
				request->appendUCHAR(isc_dyn_foreign_key_default);
				define_set_default_trg(request, element, columns,
									   referenced_columns, relation_name,
									   for_rel_name_str->str_data,
									   false);
				break;
			case REF_ACTION_SET_NULL:
				request->appendUCHAR(isc_dyn_foreign_key_null);
				define_set_null_trg(request, element, columns,
									referenced_columns, relation_name,
									for_rel_name_str->str_data,
									false);
				break;
			case REF_ACTION_NONE:
				request->appendUCHAR(isc_dyn_foreign_key_none);
				break;
			default:
				fb_assert(0);
				request->appendUCHAR(isc_dyn_foreign_key_none);	// just in case 
				break;
				// Error 
			}
		}
	}


	dsql_nod** ptr;
	dsql_nod** end = columns->nod_arg + columns->nod_count;
	for (ptr = columns->nod_arg; ptr < end; ++ptr)
	{
		const dsql_str* field_name = (dsql_str*) (*ptr)->nod_arg[1];
		request->appendDynString(isc_dyn_fld_name,
					field_name->str_data);
	}

	request->appendDynString(isc_dyn_idx_foreign_key, relation_name);
	if (referenced_columns)
	{
		end = referenced_columns->nod_arg + referenced_columns->nod_count;
		for (ptr = referenced_columns->nod_arg; ptr < end; ++ptr)
		{
			const dsql_str* field_name = (dsql_str*) (*ptr)->nod_arg[1];
			request->appendDynString(isc_dyn_idx_ref_column,
						field_name->str_data);
		}
	}

	request->appendUCHAR(isc_dyn_end);
}


static void modify_database( CStatement* request)
{
/**************************************
 *
 *	m o d i f y _ d a t a b a s e
 *
 **************************************
 *
 * Function
 *	Modify a database.
 *
 **************************************/
	const dsql_nod* ddl_node = request->ddlNode;

	request->appendUCHAR(isc_dyn_mod_database);
//	request->appendNumber(isc_dyn_rel_sql_protection, 1);
//	bool drop_log = false;
//	bool drop_cache = false;
	bool drop_difference = false;

	dsql_nod* elements = ddl_node->nod_arg[e_adb_all];
	dsql_nod** end = elements->nod_arg + elements->nod_count;
	dsql_nod** ptr;
	
	for (ptr = elements->nod_arg; ptr < end; ptr++)
	{
		const dsql_nod* element = *ptr;
		switch (element->nod_type) {
/*
		case nod_drop_log:
			drop_log = true;
			break;
		case nod_drop_cache:
			drop_cache = true;
			break;
*/
		case nod_drop_difference:
			drop_difference = true;
			break;

		default:
			break;
		}
	}

/*
	if (drop_log) {
		request->appendUCHAR(isc_dyn_drop_log);
	}
	if (drop_cache) {
		request->appendUCHAR(isc_dyn_drop_cache);
	}
*/
	if (drop_difference) {
		request->appendUCHAR(isc_dyn_drop_difference);
	}

	SLONG start = 0;
	//SSHORT number = 0;
	//SLONG temp_long;
	//SSHORT temp_short;

	elements = ddl_node->nod_arg[e_adb_all];
	end = elements->nod_arg + elements->nod_count;
	for (ptr = elements->nod_arg; ptr < end; ptr++)
	{
		const dsql_fil* file;
		const dsql_nod* element = *ptr;

		switch (element->nod_type) {
		case nod_file_desc:
			file = (dsql_fil*) element->nod_arg[0];
			request->appendDynString(isc_dyn_def_file,
						file->fil_name->str_data);

			start = MAX(start, file->fil_start);
			request->appendNumber (isc_dyn_file_start, start);

			request->appendNumber (isc_dyn_file_length, file->fil_length);
			request->appendUCHAR(isc_dyn_end);
			start += file->fil_length;
			break;

/*
		case nod_log_file_desc:
			file = (dsql_fil*) element->nod_arg[0];

			if (file->fil_flags & LOG_default) {
				request->appendUCHAR(isc_dyn_def_default_log);
				break;
			}
			request->appendDynString(isc_dyn_def_log_file,
						file->fil_name->str_data);
			request->appendNumber (isc_dyn_file_length, file->fil_length);
			request->appendUCHAR(isc_dyn_log_file_sequence);
			request->appendNumber(number);
			number++;
			request->appendUCHAR(isc_dyn_log_file_partitions);
			request->appendNumber(file->fil_partitions);
			if (file->fil_flags & LOG_serial) {
				request->appendUCHAR(isc_dyn_log_file_serial);
			}
			if (file->fil_flags & LOG_overflow) {
				request->appendUCHAR(isc_dyn_log_file_overflow);
			}
			if (file->fil_flags & LOG_raw) {
				request->appendUCHAR(isc_dyn_log_file_raw);
			}
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_cache_file_desc:
			file = (dsql_fil*) element->nod_arg[0];
			request->appendDynString(isc_dyn_def_cache_file,
						file->fil_name->str_data);
			request->appendNumber (isc_dyn_file_length, file->fil_length);
			request->appendUCHAR(isc_dyn_end);
			break;

		case nod_group_commit_wait:
			request->appendUCHAR(isc_dyn_log_group_commit_wait);
			temp_long = (long) (element->nod_arg[0]);
			request->appendNumber(temp_long);
			break;

		case nod_check_point_len:
			request->appendUCHAR(isc_dyn_log_check_point_length);
			temp_long = (long) (element->nod_arg[0]);
			request->appendNumber(temp_long);
			break;

		case nod_num_log_buffers:
			request->appendUCHAR(isc_dyn_log_num_of_buffers);
			temp_short = getInt(element); //(SSHORT)(long) (element->nod_arg[0]);
			request->appendNumber(temp_short);
			break;

		case nod_log_buffer_size:
			request->appendUCHAR(isc_dyn_log_buffer_size);
			temp_short = getInt(element); //(SSHORT)(long) (element->nod_arg[0]);
			request->appendNumber(temp_short);
			break;
*/

		case nod_difference_file:
			request->appendDynString(isc_dyn_def_difference, 
				((dsql_str*)element->nod_arg[0])->str_data);
			break;
		case nod_begin_backup:
			request->appendUCHAR(isc_dyn_begin_backup);
			break;
		case nod_end_backup:
			request->appendUCHAR(isc_dyn_end_backup);
			break;
//		case nod_drop_log:
//		case nod_drop_cache:
//			break;

		default:
			break;
		}
	}

	request->appendUCHAR(isc_dyn_end);
}


static void modify_domain( CStatement* request)
{
/**************************************
 *
 *	m o d i f y _ d o m a i n
 *
 **************************************
 *
 * Function
 *	Alter an SQL domain.
 *
 **************************************/
	const dsql_str* string;
	dsql_fld* field;
	dsql_fld local_field;
	/* CVC: This array used with check_one_call to ensure each modification 
	   option is called only once. Enlarge it if the switch() below gets more 
	   cases. */
	USHORT repetition_count[6];

	dsql_nod* ddl_node = request->ddlNode;

	dsql_nod* domain_node = ddl_node->nod_arg[e_alt_dom_name];
	dsql_str* domain_name = (dsql_str*) domain_node->nod_arg[e_fln_name];

	request->appendDynString(isc_dyn_mod_global_fld,
				domain_name->str_data);


	/* Is MOVE_CLEAR enough for all platforms?
	MOVE_CLEAR (repetition_count, sizeof (repetition_count)); */
	const USHORT rtop = FB_NELEM(repetition_count);
	USHORT* p = repetition_count;
	while (p < repetition_count + rtop) {
		*p++ = 0;
	}

	dsql_nod* ops = ddl_node->nod_arg[e_alt_dom_ops];
	dsql_nod** ptr = ops->nod_arg;

	for (dsql_nod** end = ptr + ops->nod_count; ptr < end; ptr++)
	{
		dsql_nod* element = *ptr;
		switch (element->nod_type)
		{
		case nod_def_default:
			check_one_call (repetition_count, 0, "DOMAIN DEFAULT");
			/* CVC: So do you want to crash me with ALTER DOMAIN dom SET; ??? */
			if (!element->nod_arg[e_dft_default]) 
			{
				ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -104,
							isc_arg_gds, isc_command_end_err,    // Unexpected end of command 
							0);
			}
			// CVC End modification. 
			element->nod_arg[e_dft_default] =
				PASS1_node(request, element->nod_arg[e_dft_default], false);

			request->blrBegin(isc_dyn_fld_default_value);
			GEN_expr(request, element->nod_arg[e_dft_default]);
			request->blrEnd();

			string = (dsql_str*) element->nod_arg[e_dft_default_source];
			if (string)
			{
				fb_assert(string->str_length <= MAX_USHORT);
				request->appendDynString(	isc_dyn_fld_default_source,
										string->str_data,
										(USHORT) string->str_length);
			}
			break;

		case nod_def_constraint:
			check_one_call (repetition_count, 1, "DOMAIN CONSTRAINT");
			request->appendUCHAR(isc_dyn_single_validation);
			request->blrBegin(isc_dyn_fld_validation_blr);

			/* Get the attributes of the domain, and set any occurances of
			   nod_dom_value (corresponding to the keyword VALUE) to the
			   correct type, length, scale, etc. */
			//if (!METD_get_domain(request, &local_field, domain_name->str_data))
			if (!request->getDomain (*domain_name, &local_field))
			{
					ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
							  isc_arg_gds, isc_dsql_command_err,
							  isc_arg_gds, isc_dsql_domain_not_found,
                              isc_arg_string, domain_name->str_data,
							  // Specified domain or source field does not exist 
							  0);
			}
			if (element->nod_arg[e_cnstr_condition])
			{
				set_nod_value_attributes(element->nod_arg[e_cnstr_condition],
										 &local_field);
			}

			/* Increment the context level for this request, so that
			   the context number for any RSE generated for a SELECT
			   within the CHECK clause will be greater than 0.  In the
			   environment of a domain check constraint, context
			   number 0 is reserved for the "blr_fid, 0, 0, 0," which
			   is emitted for a nod_dom_value, corresponding to an
			   occurance of the VALUE keyword in the body of the check
			   constraint.  -- chrisj 1999-08-20 */

			request->contextNumber++;

			GEN_expr(request,
					 PASS1_node(request, element->nod_arg[e_cnstr_condition],
								false));

			request->blrEnd();
			if ((string = (dsql_str*) element->nod_arg[e_cnstr_source]) != NULL) {
				fb_assert(string->str_length <= MAX_USHORT);
				request->appendDynString(	isc_dyn_fld_validation_source,
										string->str_data,
										string->str_length);
			}
			break;

		case nod_mod_domain_type:
			field = (dsql_fld*) element->nod_arg[e_mod_dom_new_dom_type];
			DDL_resolve_intl_type(request, field, NULL);
			put_field(request, field, false);
			break;

		case nod_field_name:
			{
				check_one_call(repetition_count, 3, "DOMAIN NAME");

				const dsql_str* new_dom_name = (dsql_str*) element->nod_arg[e_fln_name];
				request->appendDynString(isc_dyn_fld_name,
							new_dom_name->str_data);
				break;
			}

		case nod_delete_rel_constraint:
			check_one_call (repetition_count, 4, "DOMAIN DROP CONSTRAINT");
			request->appendUCHAR(isc_dyn_del_validation);
			break;

		case nod_del_default:
			check_one_call (repetition_count, 5, "DOMAIN DROP DEFAULT");
			request->appendUCHAR(isc_dyn_del_default);
			break;

		default:
			break;
		}
	}

	request->appendUCHAR(isc_dyn_end);
}


static void modify_index( CStatement* request)
{
/**************************************
 *
 *	m o d i f y _ i n d e x
 *
 **************************************
 *
 * Function
 *	Alter an index (only active or inactive for now)
 *
 **************************************/
	dsql_nod* ddl_node = request->ddlNode;

	dsql_nod* index_node = ddl_node->nod_arg[e_alt_index];
	const dsql_str* index_name = (dsql_str*) index_node->nod_arg[e_alt_idx_name];

	request->appendDynString(isc_dyn_mod_idx, index_name->str_data);

	if (index_node->nod_type == nod_idx_active) {
		request->appendNumber(isc_dyn_idx_inactive, 0);
	} else if (index_node->nod_type == nod_idx_inactive) {
		request->appendNumber(isc_dyn_idx_inactive, 1);
	}

	request->appendUCHAR(isc_dyn_end);
}


static void modify_privilege(	CStatement*			request,
								NOD_TYPE	type,
								SSHORT		option,
								const char*		privs,
								const dsql_nod*			table,
								const dsql_nod*			user,
								const dsql_str*			field_name)
{
/**************************************
 *
 *	m o d i f y _ p r i v i l e g e
 *
 **************************************
 *
 * Functional description
 *	Stuff a single grant/revoke verb and all its options.
 *
 **************************************/

	if (type == nod_grant) 
		request->appendUCHAR(isc_dyn_grant);
	else 
		request->appendUCHAR(isc_dyn_revoke);

	// stuff the privileges string 

	SSHORT priv_count = 0;
	request->appendShort(0);
	
	for (; *privs; privs++) 
		{
		priv_count++;
		request->appendUCHAR(*privs);
		}

	UCHAR* dynsave = request->blrGen->ptr;

	for (SSHORT i = priv_count + 2; i; i--)
		--dynsave;

	*dynsave++ = (UCHAR) priv_count;
	*dynsave = (UCHAR) (priv_count >> 8);

	const dsql_str* name = (dsql_str*) table->nod_arg[0];

	if (table->nod_type == nod_procedure_name)
		request->appendDynString(isc_dyn_prc_name, name->str_data);
	else
		request->appendDynString(isc_dyn_rel_name, name->str_data);

	name = (dsql_str*) user->nod_arg[0];
	
	switch (user->nod_type) 
		{
		case nod_user_group:		// GRANT priv ON tbl TO GROUP unix_group 
			request->appendDynString(isc_dyn_grant_user_group, name->str_data);
			break;

		case nod_user_name:
			if (user->nod_count == 2) 
			   request->appendDynString(isc_dyn_grant_user_explicit, name->str_data);
			else 
				request->appendDynString(isc_dyn_grant_user, name->str_data);
			break;

		case nod_proc_obj:
			request->appendDynString(isc_dyn_grant_proc, name->str_data);
			break;

		case nod_trig_obj:
			request->appendDynString(isc_dyn_grant_trig, name->str_data);
			break;

		case nod_view_obj:
			request->appendDynString(isc_dyn_grant_view, name->str_data);
			break;

		case nod_role_name:
			request->appendDynString(isc_dyn_grant_role, name->str_data);
			break;

		default:
			/* CVC: Here we should complain: DYN doesn't check parameters
			   and it will write trash in rdb$user_privileges. We probably
			   should complain in most cases when "name" is blank, too. */        
			break;
		}

	if (field_name)
		request->appendDynString(isc_dyn_fld_name, field_name->str_data);

	if ((option) &&
		((type == nod_grant) ||
		//(!(request->dbb_flags & DBB_v3))))
		(!(request->dbb_flags & DBB_v3))))
		request->appendNumber(isc_dyn_grant_options, option);

	request->appendUCHAR(isc_dyn_end);
}



static SCHAR modify_privileges(CStatement*	request,
							   NOD_TYPE		type,
							   SSHORT		option,
							   dsql_nod*	privs,
							   const dsql_nod*	table,
							   const dsql_nod*	user)
{
/**************************************
 *
 *	m o d i f y _ p r i v i l e g e s
 *
 **************************************
 *
 * Functional description
 *     Return a SCHAR indicating the privilege to be modified
 *
 **************************************/

	char		temp [10];
	//char*		p;
	const char	*privileges = "";
	dsql_nod*	fields;
	dsql_nod**	ptr;
	dsql_nod**	end;

	switch (privs->nod_type) 
		{
		case nod_all:
			privileges = "A";
			break;

		case nod_select:
			return 'S';

		case nod_execute:
			return 'X';

		case nod_insert:
			return 'I';

		case nod_references:
		case nod_update:
			privileges = (privs->nod_type == nod_references) ? "R" : "U";
			fields = privs->nod_arg[0];
			
			if (!fields) 
				return *privileges;

			for (ptr = fields->nod_arg, end = ptr + fields->nod_count; ptr < end; ptr++)
				modify_privilege(request, type, option, privileges, table, user,
								reinterpret_cast<dsql_str*>((*ptr)->nod_arg[1]));
			return 0;

		case nod_delete:
			return 'D';

		case nod_list:
			{
			char *p = temp;
			
			for (ptr = privs->nod_arg, end = ptr + privs->nod_count; ptr < end; ptr++)
				{
				*p = modify_privileges(request, type, option, *ptr, table, user);
				if (*p)
					p++;
				}
			*p = 0;
			privileges = temp;
			}
			break;

		default:
			break;
		}

	if (*privileges) 
		modify_privilege(request, type, option, privileges, table, user, 0);

	return 0;
}


static void modify_relation( CStatement* request)
{
/**************************************
 *
 *	m o d i f y _ r e l a t i o n
 *
 **************************************
 *
 * Function
 *	Alter an SQL table, relying on DYN to generate
 *	global fields for the local fields.
 *
 **************************************/
	//TSQL tdsql = GET_THREAD_DATA;

	dsql_nod* ddl_node = request->ddlNode;

	dsql_nod* relation_node = ddl_node->nod_arg[e_alt_name];
	dsql_str* relation_name = (dsql_str*) relation_node->nod_arg[e_rln_name];

	request->appendDynString(isc_dyn_mod_rel, relation_name->str_data);
	save_relation(request, relation_name);

/* need to handle error that occur in generating dyn string.
 * If there is an error, get rid of the cached data
 */

	try 
		{
		dsql_nod* ops = ddl_node->nod_arg[e_alt_ops];
		dsql_nod** ptr = ops->nod_arg;
		for (const dsql_nod* const* const end = ptr + ops->nod_count; 
			ptr < end; ptr++)
			{
			const dsql_nod* field_node;
			const dsql_str* field_name;
			dsql_nod* element = *ptr;

			switch (element->nod_type) {
				case nod_mod_field_name:
					{
					const dsql_nod* old_field = element->nod_arg[e_mod_fld_name_orig_name];
					const dsql_str* old_field_name = (dsql_str*) old_field->nod_arg[e_fln_name];
					request->appendDynString(isc_dyn_mod_local_fld,
								old_field_name->str_data);

					dsql_nod* new_field = element->nod_arg[e_mod_fld_name_new_name];
					const dsql_str* new_field_name = (dsql_str*) new_field->nod_arg[e_fln_name];
					request->appendDynString(isc_dyn_rel_name,
								relation_name->str_data);
					request->appendDynString(isc_dyn_new_fld_name,
								new_field_name->str_data);
					request->appendUCHAR(isc_dyn_end);
					break;
					}

				case nod_mod_field_pos:
					{
					field_node = element->nod_arg[e_mod_fld_pos_orig_name];
					field_name = (dsql_str*) field_node->nod_arg[e_fln_name];
					request->appendDynString(isc_dyn_mod_local_fld, field_name->str_data);
					dsql_nod* const_node = element->nod_arg[e_mod_fld_pos_new_position];

					/* CVC: Since now the parser accepts pos=1..N, let's subtract one here. */
					
					//constant = (SSHORT)(long) const_node->nod_arg[0] - 1;
					const SSHORT constant = getInt(const_node) - 1;

					request->appendDynString(isc_dyn_rel_name, relation_name->str_data);
					request->appendNumber(isc_dyn_fld_position, constant);
					request->appendUCHAR(isc_dyn_end);
					break;
					}

				case nod_mod_field_type:
					modify_field(request, element, (SSHORT) -1, relation_name);
					break;

				case nod_def_field:
					define_field(request, element, (SSHORT) -1, relation_name);
					break;

				case nod_del_field:
					/* Fix for bug 8054:

					[CASCADE | RESTRICT] syntax is available in IB4.5, but not
					required until v5.0.

					Option CASCADE causes an error :
					unsupported DSQL construct

					Option RESTRICT is default behaviour.
					*/

					field_node = element->nod_arg[0];
					field_name = (dsql_str*) field_node->nod_arg[e_fln_name];

					if ((element->nod_arg[1])->nod_type == nod_cascade)
						// Unsupported DSQL construct 
						ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -901,
								isc_arg_gds, isc_dsql_command_err,
								isc_arg_gds, isc_dsql_construct_err, 0);

					fb_assert((element->nod_arg[1])->nod_type == nod_restrict);
					request->appendDynString(isc_dyn_delete_local_fld, field_name->str_data);
					request->appendUCHAR(isc_dyn_end);
					break;

				case nod_delete_rel_constraint:
					field_name = (dsql_str*) element->nod_arg[0];
					request->appendDynString(isc_dyn_delete_rel_constraint, field_name->str_data);
					break;

				case nod_rel_constraint:
					define_rel_constraint(request, element);
					break;

				default:
					break;
				}
			}

		request->appendUCHAR(isc_dyn_end);
		}
	catch (...)
		{
		//METD_drop_relation(request, relation_name);
		request->dropRelation (*relation_name);
		request->req_relation = 0;
		throw;
		}
}

static par* parameter_reverse_order(par* parameter, par* prev)
{
/**************************************
 *
 *	p a r a m e t e r _ r e v e r s e _ o r d e r
 *
 **************************************
 *
 * Function
 *	Reverse parameters order for EXECUTE BLOCK statement
 *
 **************************************/
	par* result;

	if (parameter->par_next)
		result = parameter_reverse_order(parameter->par_next, parameter);
	else
		result = parameter;
	parameter->par_next = prev;

	return result;
}


static void process_role_nm_list(	CStatement*			request,
									SSHORT		option,
									dsql_nod*			user_ptr,
									dsql_nod*			role_ptr,
									NOD_TYPE	type)
{
/**************************************
 *
 *  p r o c e s s _ r o l e _ n m _ l i s t
 *
 **************************************
 *
 * Functional description
 *     Build req_blr for grant & revoke role stmt
 *
 **************************************/
	if (type == nod_grant) {
		request->appendUCHAR(isc_dyn_grant);
	} else {
		request->appendUCHAR(isc_dyn_revoke);
	}

	request->appendShort(1);
	request->appendUCHAR('M');

	const dsql_str* role_nm = (dsql_str*) role_ptr->nod_arg[0];
	request->appendDynString(isc_dyn_sql_role_name, role_nm->str_data);

	const dsql_str* user_nm = (dsql_str*) user_ptr->nod_arg[0];
	request->appendDynString(isc_dyn_grant_user, user_nm->str_data);

	if (option) {
		request->appendNumber(isc_dyn_grant_admin_options, option);
	}

	request->appendUCHAR(isc_dyn_end);
}


static void put_descriptor(CStatement* request, const dsc* desc)
{
/**************************************
 *
 *	p u t _ d e s c r i p t o r
 *
 **************************************
 *
 * Function
 *	Write out field description in ddl, given the
 *	input descriptor.
 *
 **************************************/
	
	request->appendNumber(isc_dyn_fld_type, blr_dtypes[desc->dsc_dtype]);
	if (desc->dsc_dtype == dtype_varying) 

		request->appendNumber(isc_dyn_fld_length,
				   (SSHORT) (desc->dsc_length - sizeof(USHORT)));
	else
		request->appendNumber(isc_dyn_fld_length, desc->dsc_length);

/* TODO:AB  No idea if this code is conscious removed? 
	if (desc->dsc_dtype <= dtype_any_text) {
		request->appendNumber(isc_dyn_fld_character_set, DSC_GET_CHARSET(desc));
	}
	else if (desc->dsc_dtype == dtype_blob) {
		request->appendNumber(isc_dyn_fld_sub_type, desc->dsc_sub_type);
		if (desc->dsc_sub_type == isc_blob_text) {
			request->appendNumber(isc_dyn_fld_character_set, desc->dsc_scale);
		}
	}
	else {
*/

	request->appendNumber(isc_dyn_fld_scale, desc->dsc_scale);
	request->appendNumber(isc_dyn_fld_sub_type, desc->dsc_sub_type);

/* TODO:AB
	}
*/

}


//
// Write out field data type
// Taking special care to declare international text.
//
static void put_dtype(CStatement* request, dsql_fld* field, bool use_subtype)
{

#ifdef DEV_BUILD
// Check if the field describes a known datatype 

	if (field->fld_dtype > FB_NELEM(blr_dtypes) ||
		!blr_dtypes[field->fld_dtype]) 
		{
		SCHAR buffer[100];

		sprintf(buffer, "Invalid dtype %d in put_dtype", field->fld_dtype);
		ERRD_bugcheck(buffer);
		}
#endif

	if (field->fld_dtype == dtype_cstring ||
		field->fld_dtype == dtype_text || field->fld_dtype == dtype_varying)
		{
		if (!use_subtype || (request->dbb_flags & DBB_v3)) 
			request->appendUCHAR(blr_dtypes[field->fld_dtype]);
		else if (field->fld_dtype == dtype_varying) 
			{
			request->appendUCHAR(blr_varying2);
			request->appendShort(field->fld_ttype);
			}
		else if (field->fld_dtype == dtype_cstring) 
			{
			request->appendUCHAR(blr_cstring2);
			request->appendShort(field->fld_ttype);
			}
		else 
			{
			request->appendUCHAR(blr_text2);
			request->appendShort(field->fld_ttype);
			}

		if (field->fld_dtype == dtype_varying)
			request->appendShort(field->fld_length - sizeof(USHORT));
		else 
			request->appendShort(field->fld_length);
		}
	else
		{
		request->appendUCHAR(blr_dtypes[field->fld_dtype]);

		if (DTYPE_IS_EXACT(field->fld_dtype) || (dtype_quad == field->fld_dtype))
			request->appendUCHAR(field->fld_scale);
		}
}


static void put_field( CStatement* request, dsql_fld* field, bool udf_flag)
{
/**************************************
 *
 *	p u t _ f i e l d
 *
 **************************************
 *
 * Function
 *	Emit dyn which describes a field data type.
 *	This field could be a column, a procedure input,
 *	or a procedure output.
 *
 **************************************/

	request->appendNumber(isc_dyn_fld_type, blr_dtypes[field->fld_dtype]);
	if (field->fld_dtype == dtype_blob)
		{
		request->appendNumber(isc_dyn_fld_sub_type, field->fld_sub_type);
		request->appendNumber(isc_dyn_fld_scale, 0);
		if (!udf_flag)
			{
			if (!field->fld_seg_length) 
				field->fld_seg_length = DEFAULT_BLOB_SEGMENT_SIZE;

			request->appendNumber(isc_dyn_fld_segment_length,
					   field->fld_seg_length);
			}
		if (!(request->dbb_flags & DBB_v3))
			{
			if (field->fld_sub_type == BLOB_text) 
				request->appendNumber(isc_dyn_fld_character_set,
						   field->fld_character_set_id);
			}
		}
	
	else if (field->fld_dtype <= dtype_any_text)
		{
		if (field->fld_sub_type) 
			request->appendNumber(isc_dyn_fld_sub_type, field->fld_sub_type);

		request->appendNumber(isc_dyn_fld_scale, 0);
		if (field->fld_dtype == dtype_varying)
			{
            // CVC: Fix the assertion 
            fb_assert((field->fld_length) <= MAX_SSHORT);
			request->appendNumber(isc_dyn_fld_length,
					   (SSHORT) (field->fld_length - sizeof(USHORT)));
			}
		else
			request->appendNumber(isc_dyn_fld_length, field->fld_length);

		if (!(request->dbb_flags & DBB_v3))
			{
			request->appendNumber(isc_dyn_fld_char_length,
					   field->fld_character_length);
			request->appendNumber(isc_dyn_fld_character_set,
					   field->fld_character_set_id);
			if (!udf_flag)
				request->appendNumber(isc_dyn_fld_collation,
						   field->fld_collation_id);
			}
		}
	else 
		{
		request->appendNumber(isc_dyn_fld_scale, field->fld_scale);
		request->appendNumber(isc_dyn_fld_length, field->fld_length);
		if (DTYPE_IS_EXACT(field->fld_dtype))
			{
			request->appendNumber(isc_dyn_fld_precision, field->fld_precision);

			if (field->fld_sub_type)
				request->appendNumber(isc_dyn_fld_sub_type,
						   field->fld_sub_type);
			}
		}
}


static void put_local_variable( CStatement* request, var* variable,
	dsql_nod* host_param)
{
/**************************************
 *
 *	p u t _ l o c a l _ v a r i a b l e
 *
 **************************************
 *
 * Function
 *	Write out local variable field data type
 *
 **************************************/

	dsql_fld* field = variable->var_field;

	request->appendUCHAR(blr_dcl_variable);
	request->appendShort(variable->var_variable_number);
	DDL_resolve_intl_type(request, field, NULL);

	const USHORT dtype = field->fld_dtype;

	if (dtype == dtype_blob) 
		field->fld_dtype = dtype_quad;

	put_dtype(request, field, true);
	field->fld_dtype = dtype;

	// Check for a default value, borrowed from define_domain 

	request->appendUCHAR(blr_assignment);
	dsql_nod* node = (host_param) ? host_param->nod_arg[e_dfl_default] : 0;
	
	if (node)
		{
		node = PASS1_node(request, node, false);
		GEN_expr(request, node);
		}
	else
		request->appendUCHAR(blr_null);		// Initialize variable to NULL
		
	request->appendUCHAR(blr_variable);
	request->appendShort(variable->var_variable_number);
}


static void put_local_variables(CStatement* request, dsql_nod* parameters,
	SSHORT locals)
{
/**************************************
 *
 *	p u t _ l o c a l _ v a r i a b l e s
 *
 **************************************
 *
 * Function
 *	Emit dyn for the local variables declared
 *	in a procedure or trigger.
 *
 **************************************/

	if (parameters)
		{
		dsql_nod** ptr = parameters->nod_arg;
		
		for (const dsql_nod* const* const end = ptr + parameters->nod_count; 
			ptr < end; ptr++)
			{
			dsql_nod* parameter = *ptr;
			
			if (parameter->nod_type == nod_def_field)
				{
				dsql_fld* field = (dsql_fld*) parameter->nod_arg[e_dfl_field];
				dsql_nod** rest = ptr;
				
				while ((++rest) != end)
					{
					if ((*rest)->nod_type == nod_def_field)
						{
						dsql_fld* rest_field = (dsql_fld*) (*rest)->nod_arg[e_dfl_field];
						if (!strcmp(field->fld_name, rest_field->fld_name))
							ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -637,
									  isc_arg_gds, isc_dsql_duplicate_spec,
									  isc_arg_string, 
									  (const char*) field->fld_name, 0);
						}
					}

				dsql_nod* var_node =
					MAKE_variable(request->threadData, field, field->fld_name, VAR_output, 0, 0,
									  locals);
				*ptr = var_node;
				VAR variable = (VAR) var_node->nod_arg[e_var_variable];
				put_local_variable(request, variable, parameter);

				// fld_length is calculated inside put_local_variable(),
				// so we copy here the length
				var_node->nod_desc.dsc_length = field->fld_length;
				locals++;
				}
			else if (parameter->nod_type == nod_cursor)
				{
				PASS1_statement(request, parameter, true);
				GEN_statement(request, parameter);
				}
			}
		}
}


static void put_msg_field( CStatement* request, dsql_fld* field)
{
/**************************************
 *
 *	p u t _ m s g _ f i e l d
 *
 **************************************
 *
 * Function
 *	Write out message field data type
 *
 **************************************/

	const USHORT dtype = field->fld_dtype;

	if (dtype == dtype_blob) {
		field->fld_dtype = dtype_quad;
	}

	put_dtype(request, field, true);
	field->fld_dtype = dtype;

	// add slot for null flag (parameter2)
	request->appendUCHAR(blr_short);
	request->appendUCHAR(0);
}


static dsql_nod* replace_field_names(CStatement* request, dsql_nod*		input,
							   dsql_nod*		search_fields,
							   dsql_nod*		replace_fields,
							   bool	null_them,
							   const char* context_name)
{
/* *************************************
 *
 *	r e p l a c e _ f i e l d _ n a m e s
 *
 **************************************
 *
 * Function
 *	Given an input node tree, find any field name nodes
 *	and replace them according to the mapping provided.
 *	Used to create view  WITH CHECK OPTION.
 *
 **************************************/

	if (!input) // || MemoryPool::blk_type(input) != dsql_type_nod) 
		return input;

	const dsql_nod* const* const endo = input->nod_arg + input->nod_count;

	for (dsql_nod** ptr = input->nod_arg; ptr < endo; ++ptr)
	{

		if ((*ptr)->nod_type == nod_select_expr)
		{
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_subquery_err,
					  // No subqueries permitted for VIEW WITH CHECK OPTION 
					  0);
		}

		if ((*ptr)->nod_type == nod_field_name)
		{
			// found a field node, check if it needs to be replaced

			const dsql_str* field_name = (dsql_str*) (*ptr)->nod_arg[e_fln_name];
			dsql_nod** search     = search_fields->nod_arg;
			dsql_nod** end        = search + search_fields->nod_count;
			dsql_nod** replace = NULL;
			if (replace_fields) {
				replace = replace_fields->nod_arg;
			}
			bool found = false;
			for (; search < end; search++, (replace_fields) ? replace++ : NULL)
			{
				const dsql_str* replace_name;
				if (replace_fields) {
					replace_name = (dsql_str*) (*replace)->nod_arg[e_fln_name];
				}
				dsql_nod* field_node = *search;
				dsql_fld* field = (dsql_fld*) field_node->nod_arg[e_fld_field];
				const TEXT* search_name = field->fld_name;
				if (!strcmp((SCHAR *) field_name->str_data,
							(SCHAR *) search_name))
				{
					found = true;
					if (replace_fields) {
						(*ptr)->nod_arg[e_fln_name] = (*replace)->nod_arg[e_fln_name];
					}
					(*ptr)->nod_arg[e_fln_context] = (dsql_nod*) MAKE_cstring(request->threadData, context_name);

				}
				if (null_them &&
					replace_fields &&
					!strcmp((SCHAR *) field_name->str_data,
							(SCHAR *) replace_name->str_data))
				{
					found = true;
				}
			}
			if (null_them && !found) {
				(*ptr) = MAKE_node(request->threadData, nod_null, (int) 0);
			}
		}
		else
		{
			// recursively go through the input tree
			// looking for field name nodes
			replace_field_names(request, *ptr, search_fields, replace_fields,
								null_them, context_name);
		}
	}

	return input;
}


static void reset_context_stack( CStatement* request)
{
/**************************************
 *
 *	r e s e t _ c o n t e x t _ s t a c k
 *
 **************************************
 *
 * Function
 *	Get rid of any predefined contexts created
 *	for a view or trigger definition.
 *
 **************************************/

	request->context.clear();
	request->contextNumber = 0;
}


static void save_field(CStatement* request, const TEXT* field_name)
{
/**************************************
 *
 *	s a v e _ f i e l d
 *
 **************************************
 *
 * Function
 *	Save the name of a field in the relation or view currently
 *	being defined.  This is done to support definition
 *	of triggers which will depend on the metadata created
 *	in this request.
 *
 **************************************/

	dsql_rel* relation = request->req_relation;
	
	if (!relation) 
		return;

#ifdef SHARED_CACHE
	Sync sync(&relation->syncFields, "save_field");
	sync.lock(Exclusive);
#endif

	dsql_fld* field = new dsql_fld;
	field->fld_name = field_name;
	field->fld_next = relation->rel_fields;
	relation->rel_fields = field;
}


static void save_relation( CStatement* request, dsql_str* relation_name)
{
/**************************************
 *
 *	s a v e _ r e l a t i o n
 *
 **************************************
 *
 * Function
 *	Save the name of the relation or view currently
 *	being defined.  This is done to support definition
 *	of triggers which will depend on the metadata created
 *	in this request.
 *
 **************************************/

	//TSQL tdsql = GET_THREAD_DATA;

	if (request->flags & REQ_save_metadata) 
		return;

	request->flags |= REQ_save_metadata;
	dsql_nod* ddl_node = request->ddlNode;
	dsql_rel* relation;

	if (ddl_node->nod_type == nod_mod_relation)
		relation = request->findRelation (*relation_name); //METD_get_relation(request, relation_name);
	else
		{
		//relation = FB_NEW_RPT(*tdsql->tsql_default, relation_name->str_length) dsql_rel;
		relation = new dsql_rel;
		relation->rel_name = relation_name->str_data;
		//relation->rel_owner =relation->rel_data + relation_name->str_length + 1;
		//strcpy(relation->rel_name, (SCHAR *) relation_name->str_data);
		//*relation->rel_owner = 0;
		}
		
	request->req_relation = relation;
}


static void set_statistics( CStatement* request)
{
/**************************************
 *
 *	s e t _ s t a t i s t i c s
 *
 **************************************
 *
 * Function
 *	Alter an index/.. statistics
 *
 **************************************/
	dsql_nod* ddl_node = request->ddlNode;
	const dsql_str* index_name = (dsql_str*) ddl_node->nod_arg[e_stat_name];
	request->appendDynString(isc_dyn_mod_idx, index_name->str_data);
	request->appendUCHAR(isc_dyn_idx_statistic);
	request->appendUCHAR(isc_dyn_end);
}


static void stuff_default_blr(	CStatement*		request,
								const TEXT*	default_buff,
								USHORT	buff_size)
{
/********************************************
 *
 *      s t u f f _ d e f a u l t _ b l r
 *
 ********************************************
 * Function:
 *   The default_blr is passed in default_buffer. It is of the form:
 *   blr_version4 blr_literal ..... blr_eoc.
 *   strip the blr_version4 and blr_eoc verbs and stuff the remaining
 *   blr in the blr stream in the request.
 *
 *********************************************/
	fb_assert((*default_buff == blr_version4) || (*default_buff == blr_version5));

	unsigned int i;

	for (i = 1; ((i < buff_size) && (default_buff[i] != blr_eoc)); ++i)
	{
		request->appendUCHAR(default_buff[i]);
	}

	fb_assert(default_buff[i] == blr_eoc);
}


static void stuff_matching_blr(CStatement* request, const dsql_nod* for_columns,
	const dsql_nod* prim_columns)
{
/********************************************
 *
 *      s t u f f _ m a t c h i n g _ b l r
 *
 ********************************************
 *
 * Function
 *   Generate blr to express: foreign_key == primary_key
 *   ie.,  for_key.column_1 = prim_key.column_1 and
 *         for_key.column_2 = prim_key.column_2 and ....  so on..
 *
 **************************************/

// count of foreign key columns 
	fb_assert(prim_columns->nod_count == for_columns->nod_count);
	fb_assert(prim_columns->nod_count != 0);

	request->appendUCHAR(blr_boolean);
	if (prim_columns->nod_count > 1) {
		request->appendUCHAR(blr_and);
	}

	USHORT num_fields = 0;
	const dsql_nod* const* for_key_flds = for_columns->nod_arg;
	const dsql_nod* const* prim_key_flds = prim_columns->nod_arg;

	do {
		request->appendUCHAR(blr_eql);

		const dsql_str* for_key_fld_name_str = (dsql_str*) (*for_key_flds)->nod_arg[1];
		const dsql_str* prim_key_fld_name_str = (dsql_str*) (*prim_key_flds)->nod_arg[1];

		request->appendUCHAR(blr_field);
		request->appendUCHAR(2);
		request->appendBlrString(for_key_fld_name_str->str_data);
		request->appendUCHAR(blr_field);
		request->appendUCHAR(0);
		request->appendBlrString(prim_key_fld_name_str->str_data);

		num_fields++;

		if (prim_columns->nod_count - num_fields >= 2) {
			request->appendUCHAR(blr_and);
		}

		for_key_flds++;
		prim_key_flds++;

	} while (num_fields < for_columns->nod_count);

	request->appendUCHAR(blr_end);
}


static void stuff_trg_firing_cond(CStatement* request,
	dsql_nod* prim_columns)
{
/********************************************
 *
 *      s t u f f _ t r g _ f i r i n g _ c o n d
 *
 ********************************************
 *
 * Function
 *   Generate blr to express: if (old.primary_key != new.primary_key).
 *   do a column by column comparison.
 *
 **************************************/

	request->appendUCHAR(blr_if);

	if (prim_columns->nod_count > 1) {
		request->appendUCHAR(blr_or);
	}

	USHORT num_fields = 0;
	const dsql_nod* const* prim_key_flds = prim_columns->nod_arg;

	do {
		request->appendUCHAR(blr_neq);

		const dsql_str* prim_key_fld_name_str = (dsql_str*) (*prim_key_flds)->nod_arg[1];

		request->appendUCHAR(blr_field);
		request->appendUCHAR(0);
		request->appendBlrString(prim_key_fld_name_str->str_data);
		request->appendUCHAR(blr_field);
		request->appendUCHAR(1);
		request->appendBlrString(prim_key_fld_name_str->str_data);

		num_fields++;

		if (prim_columns->nod_count - num_fields >= 2)
			request->appendUCHAR(blr_or);

		prim_key_flds++;

	} while (num_fields < prim_columns->nod_count);
}


static void modify_field(CStatement*	request,
						 dsql_nod*	element,
						 SSHORT	position,
						 const dsql_str*	relation_name)
{
/**************************************
 *
 *	m o d i f y _ f i e l d
 *
 **************************************
 *
 * Function
 *	Modify a field, either as part of an
 *	alter table or alter domain statement.
 *
 **************************************/
	dsql_fld* field = (dsql_fld*) element->nod_arg[e_dfl_field];
	request->appendDynString(isc_dyn_mod_sql_fld, field->fld_name);

	// add the field to the relation being defined for parsing purposes

	dsql_rel* relation = request->req_relation;

	if (relation != NULL)
		{
#ifdef SHARED_CACHE
		Sync sync(&relation->syncFields, "modify_field");
		sync.lock(Exclusive);
#endif
		field->fld_next = relation->rel_fields;
		relation->rel_fields = field;
		}

	dsql_nod* domain_node = element->nod_arg[e_mod_fld_type_dom_name];

	if (domain_node)
		{
		dsql_nod* node1 = domain_node->nod_arg[e_dom_name];
		dsql_str* domain_name = (dsql_str*) node1->nod_arg[e_fln_name];
		request->appendDynString(isc_dyn_fld_source, domain_name->str_data);

		// Get the domain information

		//if (!METD_get_domain(request, field, domain_name->str_data))
		if (!(request->getDomain (*domain_name, field)))
			ERRD_post(isc_sqlerr, isc_arg_number, (SLONG) -607,
					  isc_arg_gds, isc_dsql_command_err,
					  isc_arg_gds, isc_dsql_domain_not_found,
					  // Specified domain or source field does not exist 
					  0);
		DDL_resolve_intl_type(request, field, NULL);
		}
	else
		{
		if (relation_name)
			request->appendDynString(isc_dyn_rel_name, relation_name->str_data);
		DDL_resolve_intl_type2(request, field, NULL, true);
		put_field(request, field, false);
		}

	request->appendUCHAR(isc_dyn_end);
}

//
// new_parameter_list --
//    create a list of parameter definitions in DYN
//

int	new_parameter_list (CStatement *request, dsql_nod *parameters, int parameterType)
{
	int position = 0;
	dsql_nod** ptr = parameters->nod_arg;

	for (dsql_nod* const* const end = ptr + parameters->nod_count; ptr < end; ptr++)
		{
		dsql_nod* parameter = *ptr;
		dsql_fld* field = (dsql_fld*) parameter->nod_arg[e_dfl_field];
		request->appendDynString(isc_dyn_def_parameter, field->fld_name);
		request->appendNumber(isc_dyn_prm_number, position);
		request->appendNumber(isc_dyn_prm_type, parameterType);

		DDL_resolve_intl_type(request, field, NULL);
		put_field(request, field, false);

		*ptr = MAKE_variable(request->threadData, field, field->fld_name,
								(parameterType == inputParameter) ? VAR_input : 0, 
								parameterType, 2 * position,
								position);

		// the position is relative to the list of parameters of this type
		// output parameters count as locals.  

		position++;

		request->appendUCHAR(isc_dyn_end);
		}

	return position;
}

//
// new_parameter_message --
//    create dyn etc. for input and output messages for a procedure
//
static void new_parameter_message (CStatement *request,
							dsql_nod * parameters)
{
	dsql_nod** ptr = parameters->nod_arg;

	for (dsql_nod* const* const end = ptr + parameters->nod_count;
			ptr < end; ptr++)
		{
		dsql_nod* parameter = *ptr;
		var* variable = (var*) parameter->nod_arg[e_var_variable];
		dsql_fld* field = variable->var_field;
		put_msg_field(request, field);
		}
}

//
//
// new_parameters --
//
//  create blr etc. for procedure parameters
//
static int  new_parameters (CStatement *request, dsql_nod *procedure_node)
{
	int inputs = 0;
	int outputs = 0;
	dsql_nod* parameters;

	if (parameters = procedure_node->nod_arg[e_prc_inputs])
		inputs = new_parameter_list (request, parameters, inputParameter);

	request->appendNumber(isc_dyn_prc_inputs, inputs);

	if (parameters = procedure_node->nod_arg[e_prc_outputs])
		outputs = new_parameter_list (request, parameters, outputParameter);

	request->appendNumber(isc_dyn_prc_outputs, outputs);
	request->blrBegin(isc_dyn_prc_blr);
	request->appendUCHAR(blr_begin);
	
	// generate messages from parameters - the input message is optional 

	if (inputs)
		{
		request->appendUCHAR(blr_message);
		request->appendUCHAR(0);
		request->appendShort(2 * inputs);
		new_parameter_message (request, procedure_node->nod_arg[e_prc_inputs]);
		}

	// but there's always at least one output message to mark EOS

	request->appendUCHAR(blr_message);
	request->appendUCHAR(1);
	request->appendShort(2 * outputs + 1);

	if (outputs)
		new_parameter_message (request, procedure_node->nod_arg[e_prc_outputs]);

	// add slot for EOS

	request->appendUCHAR(blr_short);
	request->appendUCHAR(0);

	// if we've got input, be sure to read it
	if (inputs) 
		{
		request->appendUCHAR(blr_receive);
		request->appendUCHAR(0);
		}

	request->appendUCHAR(blr_begin);

	if (outputs)
		{
		parameters = procedure_node->nod_arg[e_prc_outputs];
		dsql_nod** ptr = parameters->nod_arg;

		for (dsql_nod* const* const end = ptr + parameters->nod_count;
			 ptr < end; ptr++)
			{
			dsql_nod* parameter = *ptr;
			var* variable = (var*) parameter->nod_arg[e_var_variable];
			put_local_variable(request, variable, 0);
			}
		}

	return outputs;
}

//
// new_procedure -- 
//     create dyn to define a new procedure
//
static void  new_procedure (CStatement *request, 
					dsql_str *procedure_name,
					dsql_nod* procedure_node)
{
	const dsql_str* source = (dsql_str*) procedure_node->nod_arg[e_prc_source];

	if (source)
		{
		fb_assert(source->str_length <= MAX_USHORT);
		request->appendDynString(isc_dyn_prc_source, source->str_data, source->str_length);
		}

	// create enough to allow procedure to self reference

	//const char *procName = procedure_name->str_data;
	//const char *procOwner = procedure_name->str_data + procedure_name->str_length + 1;
	
	int locals = new_parameters (request, procedure_node);
	put_local_variables(request, procedure_node->nod_arg[e_prc_dcls], locals);

	request->appendUCHAR(blr_stall);

	// put a label before body of procedure,
	// so that any EXIT statement can get out

	request->appendUCHAR(blr_label);
	request->appendUCHAR(0);
	request->loopLevel = 0;
	request->cursorNumber = 0;
	GEN_statement(request, PASS1_statement(request, procedure_node->nod_arg[e_prc_body], true));
	request->req_type = REQ_DDL;
	request->appendUCHAR(blr_end);
	GEN_return(request, procedure_node->nod_arg[e_prc_outputs], true);
	request->appendUCHAR(blr_end);
	request->blrEnd();

	request->appendUCHAR(isc_dyn_end);

}


static void set_nod_value_attributes( dsql_nod* node, const dsql_fld* field)
{
/**************************************
 *
 *	s e t _ n o d _ v a l u e _ a t t r i b u t e s
 *
 **************************************
 *
 * Function
 *	Examine all the children of the argument node:
 *	if any is a nod_dom_value, set its dtype, size, and scale
 *      to those of the field argument
 *
 **************************************/
 
	for (ULONG child_number = 0; child_number < node->nod_count; ++child_number)
		{
		dsql_nod* child = node->nod_arg[child_number];
		
		if (child) // && MemoryPool::blk_type(child) == dsql_type_nod)
			switch (child->nod_type)
				{
				case nod_dom_value:
					fb_assert(field->fld_dtype <= MAX_UCHAR);
					child->nod_desc.dsc_dtype = (UCHAR) field->fld_dtype;
					child->nod_desc.dsc_length = field->fld_length;
					fb_assert(field->fld_scale <= MAX_SCHAR);
					child->nod_desc.dsc_scale = (SCHAR) field->fld_scale;
					break;
				
				case nod_field_name:
					break;
					
				default:
					set_nod_value_attributes(child, field);
				}
		}							/* for (child_number ... */
		
	return;
}

static int getInt (dsql_nod *constant)
{
	JrdMove	mover;
	
	return mover.getLong (&constant->nod_desc, 0);
}

//
//	Write out a string valued attribute.
//
/***
void CStatement::appendDynString(UCHAR verb, const char* string)
{
	const USHORT length = string ? strlen(string) : 0;
	appendDynString(verb, string, length);
}
***/

//
//	Write out a string valued attribute.
//
/***
void CStatement::appendDynString(UCHAR verb, const char* string, USHORT length)
{
	// TMN: Doesn't this look pretty awkward? If we are given
	// a verb, the length is a ushort, else it's uchar.
	if (verb) {
		appendUCHAR(verb);
		appendShort(length);
	}
	else {
		fb_assert(length <= MAX_UCHAR);
		appendUCHAR(length);
	}

	if (string) {
		for (; *string && length--; string++) {
			appendUCHAR(*string);
		}
	}
}

void CStatement::appendUCHAR(UCHAR byte)
{
	if (req_blr < req_blr_yellow) {
		*req_blr++ = byte;
	} else {
		GEN_expand_buffer(this, byte);
	}
}

void CStatement::appendUCHARs(UCHAR byte, UCHAR count)
{
	for (int i = 0; i < count; ++i) {
		appendUCHAR(byte);
	}
}

void CStatement::appendShort(USHORT val)
{
	appendUCHAR(val);
	appendUCHAR(val >> 8);
}

void CStatement::append_ulong(ULONG val)
{
	appendShort(val);
	appendShort(val >> 16);
}

void CStatement::appendNumber(USHORT val)
{
	// append an USHORT value, prepended with the USHORT length of an USHORT
	appendShort(2);
	appendShort(val);
}

void CStatement::appendNumber(ULONG val)
{
	// append an ULONG value, prepended with the USHORT length of an ULONG
	appendShort(4);
	append_ulong(val);
}

void CStatement::appendNumber (isc_dyn_file_length, ULONG length)
{
	appendUCHAR(isc_dyn_file_length);
	appendNumber(length);
}

void CStatement::appendNumber (isc_dyn_file_start, ULONG start)
{
	appendUCHAR(isc_dyn_file_start);
	appendNumber(start);
}
***/

//
// common code factored out
//
#ifdef UNDEF
void CStatement::generate_unnamed_trigger_beginning(	bool		on_update_trigger,
												const char*		prim_rel_name,
												dsql_nod*	prim_columns,
												const char*		for_rel_name,
												dsql_nod*	for_columns)
{
	// no trigger name. It is generated by the engine
	appendDynString(isc_dyn_def_trigger, "", 0);

	appendNumber(isc_dyn_trg_type,
			   (SSHORT) (on_update_trigger ? POST_MODIFY_TRIGGER :
						 POST_ERASE_TRIGGER));

	appendUCHAR(isc_dyn_sql_object);
	appendNumber(isc_dyn_trg_sequence, 1);
	appendNumber(isc_dyn_trg_inactive, 0);
	appendDynString(isc_dyn_rel_name, prim_rel_name);

	// the trigger blr
	blrBegin(isc_dyn_trg_blr);

/* for ON UPDATE TRIGGER only: generate the trigger firing condition:
   if prim_key.old_value != prim_key.new value.
   Note that the key could consist of multiple columns */

	if (on_update_trigger) {
		stuff_trg_firing_cond(this, prim_columns);
		appendUCHARs(blr_begin, 2);
	}

	appendUCHAR(blr_for);
	appendUCHAR(blr_rse);

	// the context for the prim. key relation
	appendUCHAR(1);
	appendUCHAR(blr_relation);
	appendBlrString(for_rel_name);
	// the context for the foreign key relation
	appendUCHAR(2);

	// generate the blr for: foreign_key == primary_key
	stuff_matching_blr(this, for_columns, prim_columns);

	appendUCHAR(blr_modify);
	appendUCHAR(2);
	appendUCHAR(2);
	appendUCHAR(blr_begin);
}
#endif
